do local ffi=require("ffi");local clipboard=require("gamesense/clipboard");ffi.cdef([[
    typedef struct {
        float m_flWeight;
        float m_flWeightDeltaRate;
        float m_flCycle;
        float m_flPlaybackRate;
    } animation_layer_t;
]]);local client_latency=client.latency;local client_screen_size=client.screen_size;local client_system_time=client.system_time;local globals_tickinterval=globals.tickinterval;local globals_frametime=globals.frametime;local math_floor=math.floor;local math_sqrt=math.sqrt;local math_cos=math.cos;local math_sin=math.sin;local math_pi=math.pi;local renderer_measure_text=renderer.measure_text;local renderer_rectangle=renderer.rectangle;local renderer_text=renderer.text;local renderer_line=renderer.line;local string_format=string.format;local game_database={};local hit_stats={};local hit_miss_logs={};local margin_right=18;local margin_top=18;local padding=6;local spacing=5;local corner_radius=4;local custom_font=(renderer.load_font and renderer.load_font("Verdana",16,700)) or nil ;local border_outer={40,40,40,255};local border_inner={28,28,28,255};local background_col={19,8,14,255};local text_shadow={0,0,0,200};local text_col={255,255,255,255};local accent_col={34,179,246,255};local hit_col={0,255,0,255};local miss_col={255,0,0,255};local config_elements={enable_resolver=ui.new_checkbox("LUA","B","Enable Resolver"),enable_prediction=ui.new_checkbox("LUA","B","Enable Advanced Prediction"),enable_anti_aim_det=ui.new_checkbox("LUA","B","Detect Anti-Aim"),enable_teleport_det=ui.new_checkbox("LUA","B","Counter Teleport (DDT)"),enable_exploit=ui.new_checkbox("LUA","B","Enable TickShift Disruptor"),enable_fake_duck_det=ui.new_checkbox("LUA","B","Detect Fake Duck"),resolver_mode=ui.new_combobox("LUA","B","Resolver Mode","Aggressive","Defensive","Jitter","Brute Force","Median","DM Mode","Adaptive"),decay_factor_slider=ui.new_slider("LUA","B","Decay Factor",0,100,50,true,"%",1),default_yaw_adjustment=ui.new_slider("LUA","B","Default Yaw Adjustment", -180,180,0,true,"Â°",1),hitbox_selection=ui.new_combobox("LUA","B","Hitbox Selection","Head","Chest","Stomach","Dynamic"),hit_chance_per_hitbox=ui.new_slider("LUA","B","Hit Chance",0,100,50,true,"%",1),max_history_size=ui.new_slider("LUA","B","History Size",10,200,100,true," frames",1),exploit_intensity=ui.new_slider("LUA","B","Exploit Intensity",1,10,5,true,"x",1),debug_overlay=ui.new_checkbox("LUA","B","Debug Overlay")};local function serialize_config() local serialized="{";for key,element in pairs(config_elements) do local value=ui.get(element);local serialized_value=((type(value)=="string") and ('"'   .. value   .. '"')) or tostring(value) ;serialized=serialized   .. key   .. "="   .. serialized_value   .. "," ;end return serialized:sub(1, -2)   .. "}" ;end local function deserialize_config(data) local success,result=pcall(function() return assert(loadstring("return "   .. data ))();end);if success then for key,value in pairs(result) do local element=config_elements[key];if element then ui.set(element,value);end end else client.log("Error deserializing config: "   .. tostring(result) );end end local function save_config() clipboard.set(serialize_config());client.log("Config saved to clipboard");end local function load_config() local data=clipboard.get();if data then deserialize_config(data);client.log("Config loaded");else client.log("Clipboard empty");end end ui.new_button("LUA","B","Save Config",save_config);ui.new_button("LUA","B","Load Config",load_config);local function filled_circle(cx,cy,radius,r,g,b,a) for dy= -radius,radius do local dx=math_floor(math_sqrt((radius * radius) -(dy * dy) ));renderer_rectangle(cx-dx ,cy + dy ,dx * 2 ,1,r,g,b,a);end end local function draw_rounded_rect(x,y,w,h,radius,r,g,b,a) renderer_rectangle(x + radius ,y,w-(2 * radius) ,h,r,g,b,a);renderer_rectangle(x,y + radius ,radius,h-(2 * radius) ,r,g,b,a);renderer_rectangle((x + w) -radius ,y + radius ,radius,h-(2 * radius) ,r,g,b,a);filled_circle(x + radius ,y + radius ,radius,r,g,b,a);filled_circle((x + w) -radius ,y + radius ,radius,r,g,b,a);filled_circle(x + radius ,(y + h) -radius ,radius,r,g,b,a);filled_circle((x + w) -radius ,(y + h) -radius ,radius,r,g,b,a);end local function draw_arc(cx,cy,radius,start_angle,end_angle,color) local segments=50;local angle_step=(end_angle-start_angle)/segments ;for i=0,segments-1  do local a1=start_angle + (angle_step * i) ;local a2=start_angle + (angle_step * (i + 1)) ;local x1=cx + (radius * math_cos(a1)) ;local y1=cy + (radius * math_sin(a1)) ;local x2=cx + (radius * math_cos(a2)) ;local y2=cy + (radius * math_sin(a2)) ;renderer_line(x1,y1,x2,y2,color[1],color[2],color[3],color[4]);end end function get_animation_state(player_index) local anim_layers=entity.get_prop(player_index,"m_AnimationLayers");if  not anim_layers then return "unknown",0;end local layer=ffi.cast("animation_layer_t*",anim_layers);local weight=layer[0].m_flWeight;local cycle=layer[0].m_flCycle;local playback_rate=layer[0].m_flPlaybackRate;if ((weight>0.9) and (playback_rate>0)) then if (cycle<0.1) then return "shooting",weight;elseif (cycle>0.9) then return "reloading",weight;else return "moving",weight;end end return "idle",weight;end function kalman3d_create() return {x={0,0,0},P={{1,0,0},{0,1,0},{0,0,1}},q={0.0001,0.0001,0.0001},r=0.05,last_time=globals.realtime(),anomaly_count=0};end function kalman3d_update(kf,measurement,is_teleport) local dt=math.max(globals.realtime() -kf.last_time ,0.001);kf.last_time=globals.realtime();local F={{1,dt,0.5 * dt * dt },{0,1,dt},{0,0,1}};local x_pred={(F[1][1] * kf.x[1]) + (F[1][2] * kf.x[2]) + (F[1][3] * kf.x[3]) ,(F[2][1] * kf.x[1]) + (F[2][2] * kf.x[2]) + (F[2][3] * kf.x[3]) ,(F[3][1] * kf.x[1]) + (F[3][2] * kf.x[2]) + (F[3][3] * kf.x[3]) };local Q={{kf.q[1],0,0},{0,kf.q[2],0},{0,0,kf.q[3]}};local r_adjusted=(is_teleport and 0.5) or kf.r ;local function mat_mult(A,B) local result={};for i=1, #A do result[i]={};for j=1, #B[1] do result[i][j]=0;for k=1, #B do result[i][j]=result[i][j] + (A[i][k] * B[k][j]) ;end end end return result;end local function mat_transpose(M) local result={};for i=1, #M[1] do result[i]={};for j=1, #M do result[i][j]=M[j][i];end end return result;end local P_pred=mat_mult(mat_mult(F,kf.P),mat_transpose(F));for i=1,3 do P_pred[i][i]=P_pred[i][i] + Q[i][i] ;end local H={1,0,0};local z_pred=x_pred[1];local y=measurement-z_pred ;local S=P_pred[1][1] + r_adjusted ;local K={P_pred[1][1]/S ,P_pred[2][1]/S ,P_pred[3][1]/S };if (math.abs(y)>90) then kf.anomaly_count=kf.anomaly_count + 1 ;else kf.anomaly_count=math.max(0,kf.anomaly_count-1 );end kf.x[1]=x_pred[1] + (K[1] * y) ;kf.x[2]=x_pred[2] + (K[2] * y) ;kf.x[3]=x_pred[3] + (K[3] * y) ;for i=1,3 do P_pred[i][i]=(1 -(K[i] * H[i])) * P_pred[i][i] ;end kf.P=P_pred;return kf.x[1],kf.anomaly_count>5 ;end function get_player_state(player_index) local flags=entity.get_prop(player_index,"m_fFlags") or 0 ;local velocity={entity.get_prop(player_index,"m_vecVelocity[0]") or 0 ,entity.get_prop(player_index,"m_vecVelocity[1]") or 0 };local speed=math.sqrt((velocity[1]^2) + (velocity[2]^2) );local on_ground=bit.band(flags,1)==1 ;local ducking=bit.band(flags,2)==2 ;if  not on_ground then return "jump",speed;elseif ducking then return "duck",speed;elseif (speed<1) then return "stand",speed;else return "move",speed;end end function detect_teleport(player_index) local data=game_database[player_index];if ( not data or  not data.last_origin) then return false;end local current_origin={x=entity.get_prop(player_index,"m_vecOrigin[0]") or 0 ,y=entity.get_prop(player_index,"m_vecOrigin[1]") or 0 ,z=entity.get_prop(player_index,"m_vecOrigin[2]") or 0 };local delta_x=current_origin.x-data.last_origin.x ;local delta_y=current_origin.y-data.last_origin.y ;local delta_z=current_origin.z-data.last_origin.z ;local distance=math.sqrt((delta_x^2) + (delta_y^2) + (delta_z^2) );local dt=globals.realtime() -(data.last_update or globals.realtime()) ;local speed=distance/math.max(dt,0.001) ;data.last_origin=current_origin;data.last_update=globals.realtime();return speed>1000 ;end function reset_player_data(player_index) game_database[player_index]={yaw_history={},pitch_history={},kalman_yaw=kalman3d_create(),kalman_pitch=kalman3d_create(),behavior={aggressive=0,defensive=0,jitter=0,crouch_time=0,move_speed=0},last_resolved=0,last_origin={x=0,y=0,z=0},last_update=globals.realtime(),anim_state="unknown",misses=0,hits=0,duck_history={},last_duck_switch=0,fake_duck_detected=false};end function update_player_data(player_index,yaw,pitch,origin) if  not game_database[player_index] then reset_player_data(player_index);end local data=game_database[player_index];local max_history=ui.get(config_elements.max_history_size);table.insert(data.yaw_history,yaw);table.insert(data.pitch_history,pitch);if ( #data.yaw_history>max_history) then table.remove(data.yaw_history,1);table.remove(data.pitch_history,1);end data.last_origin=origin;data.last_update=globals.realtime();data.anim_state=get_animation_state(player_index);end function detect_fake_duck(player_index) local data=game_database[player_index];if  not data then return false;end local duck_amount=entity.get_prop(player_index,"m_flDuckAmount") or 0 ;local current_time=globals.realtime();table.insert(data.duck_history,{time=current_time,amount=duck_amount});local max_duck_history=20;if ( #data.duck_history>max_duck_history) then table.remove(data.duck_history,1);end local switch_count=0;local last_state=nil;for i,entry in ipairs(data.duck_history) do local state=((entry.amount>0.5) and 1) or 0 ;if (last_state and (last_state~=state)) then switch_count=switch_count + 1 ;end last_state=state;end local is_fake_duck=(switch_count>5) and ( #data.duck_history>=max_duck_history) ;if is_fake_duck then data.fake_duck_detected=true;data.last_duck_switch=current_time;elseif ((current_time-data.last_duck_switch)>1) then data.fake_duck_detected=false;end return data.fake_duck_detected;end function detect_anti_aim(player_index) local data=game_database[player_index];if ( not data or ( #data.yaw_history<10)) then return "none";end local variance=0;local avg_yaw=0;for _,v in ipairs(data.yaw_history) do avg_yaw=avg_yaw + v ;end avg_yaw=avg_yaw/ #data.yaw_history ;for _,v in ipairs(data.yaw_history) do variance=variance + ((v-avg_yaw)^2) ;end variance=variance/ #data.yaw_history ;if (data.kalman_yaw.anomaly_count>5) then return "spinbot";elseif (ui.get(config_elements.enable_fake_duck_det) and detect_fake_duck(player_index)) then return "fake_duck";elseif (variance>1500) then return "jitter";elseif (variance>500) then return "fake_angles";else return "normal";end end function adaptive_resolver(player_index,yaw) local aa_type=detect_anti_aim(player_index);if (aa_type=="spinbot") then return brute_force_resolver(player_index,yaw);elseif (aa_type=="fake_duck") then return fake_duck_resolver(player_index,yaw);elseif (aa_type=="jitter") then return jitter_resolver(player_index);elseif (aa_type=="fake_angles") then return aggressive_resolver(player_index,yaw);else return defensive_resolver(player_index,yaw);end end function aggressive_resolver(player_index,yaw) local data=game_database[player_index];local median=median_resolver(player_index);local delta=yaw-median ;return math.min(180,math.max( -180,yaw + (delta * 0.7) + 25 ));end function defensive_resolver(player_index,yaw) local data=game_database[player_index];local median=median_resolver(player_index);return (yaw * 0.7) + (median * 0.3) ;end function jitter_resolver(player_index) local data=game_database[player_index];return math.sin((globals.realtime() * 4) + player_index ) * 30 ;end function brute_force_resolver(player_index,yaw) local data=game_database[player_index];return math.min(180,math.max( -180,yaw + (math.sin((globals.realtime() * 2.5) + player_index ) * 60) ));end function median_resolver(player_index) local data=game_database[player_index];if ( #data.yaw_history==0) then return 0;end local sorted={table.unpack(data.yaw_history)};table.sort(sorted);return sorted[math.ceil( #sorted/2 )];end function dm_resolver(player_index,yaw) local state,speed=get_player_state(player_index);local adjustment=yaw;local t=(globals.realtime() * 3) + player_index ;if (state=="jump") then adjustment=yaw + (math.sin(t) * 25) ;elseif (state=="duck") then adjustment=(yaw-20) + (math.cos(t) * 15) ;elseif (state=="move") then adjustment=yaw + (math.sin(t) * (5 + (speed * 0.05))) ;else adjustment=yaw + (math.cos(t) * 10) ;end return math.min(180,math.max( -180,adjustment));end function teleport_counter_resolver(player_index,yaw) local velocity={entity.get_prop(player_index,"m_vecVelocity[0]") or 0 ,entity.get_prop(player_index,"m_vecVelocity[1]") or 0 };local speed=math.sqrt((velocity[1]^2) + (velocity[2]^2) );local direction=(math.atan2(velocity[2],velocity[1]) * 180)/math.pi ;local offset=((speed>50) and 30) or 15 ;return direction + offset ;end function fake_duck_resolver(player_index,yaw) local data=game_database[player_index];local duck_amount=entity.get_prop(player_index,"m_flDuckAmount") or 0 ;local state,speed=get_player_state(player_index);local adjustment=yaw + (math.sin((globals.realtime() * 8) + player_index ) * 20) ;if (speed>50) then adjustment=adjustment + (speed * 0.1) ;end if (duck_amount>0.5) then plist.set(player_index,"hitbox override","Stomach");else plist.set(player_index,"hitbox override","Head");end return math.min(180,math.max( -180,adjustment));end function predict_angles(player_index) local data=game_database[player_index];if  not data then return 0,0,false;end local is_teleport=ui.get(config_elements.enable_teleport_det) and detect_teleport(player_index) ;local yaw,is_aa=kalman3d_update(data.kalman_yaw,data.yaw_history[ #data.yaw_history] or 0 ,is_teleport);local pitch=kalman3d_update(data.kalman_pitch,data.pitch_history[ #data.pitch_history] or 0 ,is_teleport);return yaw,pitch,is_aa;end function get_dynamic_hitbox(player_index) local state,speed=get_player_state(player_index);local anim_state=game_database[player_index].anim_state;if (state=="jump") then return "Chest";elseif ((state=="duck") or (anim_state=="reloading")) then return "Stomach";elseif (speed>100) then return "Chest";else return "Head";end end local function update_hit_stats(player_index,hit) if  not hit_stats[player_index] then hit_stats[player_index]={hits=0,misses=0};end if hit then hit_stats[player_index].hits=hit_stats[player_index].hits + 1 ;else hit_stats[player_index].misses=hit_stats[player_index].misses + 1 ;end local log_text=(hit and ("Hit Player "   .. player_index)) or ("Missed Player "   .. player_index) ;table.insert(hit_miss_logs,{text=log_text,time=globals.realtime(),color=(hit and hit_col) or miss_col });end local function get_hit_weight(player_index) local stats=hit_stats[player_index] or {hits=0,misses=0} ;local total=stats.hits + stats.misses ;return ((total>0) and (stats.hits/total)) or 0.5 ;end function tickshift_disruptor(player_index) local intensity=ui.get(config_elements.exploit_intensity) * 0.1 ;local tick=globals.tickcount();local phase=math.sin(tick * intensity );local fake_yaw=((phase>0) and 180) or  -180 ;local real_yaw=entity.get_prop(player_index,"m_angEyeAngles[1]") or 0 ;local body_yaw_offset=math.sin(globals.realtime() * 10 ) * 60 * intensity ;plist.set(player_index,"body yaw",body_yaw_offset);local anim_layers=entity.get_prop(player_index,"m_AnimationLayers");if anim_layers then local layer=ffi.cast("animation_layer_t*",anim_layers);layer[0].m_flWeight=math.abs(phase);layer[0].m_flCycle=(((tick%2)==0) and 0) or 1 ;end return fake_yaw,real_yaw;end local bomb_planted=false;local bomb_explode_time=0;local bomb_duration=40;local function get_current_time_sec() local h,m,s=client_system_time();return (h * 3600) + (m * 60) + s ;end local function on_bomb_planted(event) bomb_planted=true;local now=get_current_time_sec();bomb_explode_time=now + bomb_duration ;end local function on_bomb_reset(event) bomb_planted=false;end client.set_event_callback("bomb_planted",on_bomb_planted);client.set_event_callback("bomb_defused",on_bomb_reset);client.set_event_callback("bomb_exploded",on_bomb_reset);client.set_event_callback("round_end",on_bomb_reset);local function draw_bomb_timer_box() if  not bomb_planted then return;end local now=get_current_time_sec();local remaining=bomb_explode_time-now ;if (remaining<0) then bomb_planted=false;return;end local percentage=remaining/bomb_duration ;local sw,sh=client_screen_size();local circle_radius=15;local circle_diameter=circle_radius * 2 ;local timer_text="timer";local text_w,text_h=renderer_measure_text(custom_font,timer_text);local h_spacing=10;local box_width=padding + circle_diameter + h_spacing + text_w + padding ;local box_height=math.max(circle_diameter,text_h) + (padding * 2) ;local box_x=math_floor((sw/2) -(box_width/2) );local box_y=50;draw_rounded_rect(box_x,box_y,box_width,box_height,corner_radius,border_outer[1],border_outer[2],border_outer[3],border_outer[4]);draw_rounded_rect(box_x + 1 ,box_y + 1 ,box_width,box_height,corner_radius,border_inner[1],border_inner[2],border_inner[3],border_inner[4]);draw_rounded_rect(box_x + 1 ,box_y + 1 ,box_width-2 ,box_height-2 ,corner_radius,background_col[1],background_col[2],background_col[3],background_col[4]);local circle_cx=box_x + padding + circle_radius ;local circle_cy=box_y + (box_height/2) ;draw_arc(circle_cx,circle_cy,circle_radius,0,2 * math_pi ,{80,80,80,255});local start_angle= -math_pi/2 ;local end_angle=start_angle + (2 * math_pi * percentage) ;draw_arc(circle_cx,circle_cy,circle_radius,start_angle,end_angle,accent_col);local time_text=string_format("%.1f",remaining);local t_w,t_h=renderer_measure_text(custom_font,time_text);renderer_text(circle_cx-(t_w/2) ,circle_cy-(t_h/2) ,text_col[1],text_col[2],text_col[3],text_col[4],custom_font,0,time_text);local text_x=box_x + padding + circle_diameter + h_spacing ;local text_y=(box_y + (box_height/2)) -(text_h/2) ;renderer_text(text_x + 1 ,text_y + 1 ,text_shadow[1],text_shadow[2],text_shadow[3],text_shadow[4],custom_font,0,timer_text);renderer_text(text_x,text_y,accent_col[1],accent_col[2],accent_col[3],accent_col[4],custom_font,0,timer_text);end local last_fps_update=0;local cached_fps=0;local function draw_top_menu() local sw,sh=client_screen_size();local latency=math_floor((client_latency() * 1000) + 0.5 );local h,m,s=client_system_time();local now=(h * 3600) + (m * 60) + s ;if (now>last_fps_update) then cached_fps=math_floor(1/globals_frametime() );last_fps_update=now;end local text_gs="GS";local text_ping=string_format("%dms",latency);local text_fps=string_format("%dFPS",cached_fps);local text_gamesense="gamesense";local gs_w,gs_h=renderer_measure_text(custom_font,text_gs);local ping_w,ping_h=renderer_measure_text(custom_font,text_ping);local fps_w,fps_h=renderer_measure_text(custom_font,text_fps);local gamesense_w,gamesense_h=renderer_measure_text(custom_font,text_gamesense);local box_gs={w=gs_w + (padding * 2) ,h=gs_h + (padding * 2) };local box_ping={w=ping_w + (padding * 2) ,h=ping_h + (padding * 2) };local box_fps={w=fps_w + (padding * 2) ,h=fps_h + (padding * 2) };local box_gsense={w=gamesense_w + (padding * 2) ,h=gamesense_h + (padding * 2) };local max_box_height=math_floor(math.max(box_gs.h,box_ping.h,box_fps.h,box_gsense.h));box_gs.h=max_box_height;box_ping.h=max_box_height;box_fps.h=max_box_height;box_gsense.h=max_box_height;local total_width=box_gs.w + box_ping.w + box_fps.w + box_gsense.w + (spacing * 3) ;local start_x=(sw-total_width) -margin_right ;local y=margin_top;local function draw_box(x,y,w,h,text,txt_col,shad) draw_rounded_rect(x,y,w,h,corner_radius,border_outer[1],border_outer[2],border_outer[3],border_outer[4]);draw_rounded_rect(x + 1 ,y + 1 ,w,h,corner_radius,border_inner[1],border_inner[2],border_inner[3],border_inner[4]);draw_rounded_rect(x + 1 ,y + 1 ,w-2 ,h-2 ,corner_radius,background_col[1],background_col[2],background_col[3],background_col[4]);renderer_text(x + padding + 1 ,y + padding + 1 ,shad[1],shad[2],shad[3],shad[4],custom_font,0,text);renderer_text(x + padding ,y + padding ,txt_col[1],txt_col[2],txt_col[3],txt_col[4],custom_font,0,text);end draw_box(start_x,y,box_gs.w,box_gs.h,text_gs,accent_col,{255,255,255,255});start_x=start_x + box_gs.w + spacing ;draw_box(start_x,y,box_ping.w,box_ping.h,text_ping,text_col,text_shadow);start_x=start_x + box_ping.w + spacing ;draw_box(start_x,y,box_fps.w,box_fps.h,text_fps,text_col,text_shadow);start_x=start_x + box_fps.w + spacing ;draw_box(start_x,y,box_gsense.w,box_gsense.h,text_gamesense,text_col,text_shadow);end local function draw_hit_miss_logs() local sw,sh=client_screen_size();local log_duration=5;local current_time=globals.realtime();for i= #hit_miss_logs,1, -1 do if ((current_time-hit_miss_logs[i].time)>log_duration) then table.remove(hit_miss_logs,i);end end if ( #hit_miss_logs==0) then return;end local total_height=0;local log_boxes={};for i,log in ipairs(hit_miss_logs) do local text_w,text_h=renderer_measure_text(custom_font,log.text);local box_width=text_w + (padding * 2) ;local box_height=text_h + (padding * 2) ;total_height=total_height + box_height + (((i>1) and spacing) or 0) ;log_boxes[i]={w=box_width,h=box_height,text=log.text,color=log.color};end local center_y=sh/2 ;local bottom_y=sh;local start_y=math_floor(((center_y + bottom_y)/2) -(total_height/2) );local base_x=math_floor(sw/2 );for i,box in ipairs(log_boxes) do local x=base_x-(box.w/2) ;local y=start_y + ((i-1) * (box.h + spacing)) ;draw_rounded_rect(x,y,box.w,box.h,corner_radius,border_outer[1],border_outer[2],border_outer[3],border_outer[4]);draw_rounded_rect(x + 1 ,y + 1 ,box.w,box.h,corner_radius,border_inner[1],border_inner[2],border_inner[3],border_inner[4]);draw_rounded_rect(x + 1 ,y + 1 ,box.w-2 ,box.h-2 ,corner_radius,background_col[1],background_col[2],background_col[3],background_col[4]);renderer_text(x + padding + 1 ,y + padding + 1 ,text_shadow[1],text_shadow[2],text_shadow[3],text_shadow[4],custom_font,0,box.text);renderer_text(x + padding ,y + padding ,box.color[1],box.color[2],box.color[3],box.color[4],custom_font,0,box.text);end end local function resolver_logic(player_index) if  not ui.get(config_elements.enable_resolver) then return;end local yaw=entity.get_prop(player_index,"m_angEyeAngles[1]");local pitch=entity.get_prop(player_index,"m_angEyeAngles[0]");local origin={x=entity.get_prop(player_index,"m_vecOrigin[0]") or 0 ,y=entity.get_prop(player_index,"m_vecOrigin[1]") or 0 ,z=entity.get_prop(player_index,"m_vecOrigin[2]") or 0 };if ( not yaw or  not pitch) then return;end update_player_data(player_index,yaw,pitch,origin);local mode=ui.get(config_elements.resolver_mode);local adjustment=yaw;local is_teleport=ui.get(config_elements.enable_teleport_det) and detect_teleport(player_index) ;if ui.get(config_elements.enable_fake_duck_det) then detect_fake_duck(player_index);end if ui.get(config_elements.enable_exploit) then local fake_yaw,real_yaw=tickshift_disruptor(player_index);adjustment=fake_yaw;yaw=real_yaw;end if is_teleport then adjustment=teleport_counter_resolver(player_index,yaw);elseif (mode=="Aggressive") then adjustment=aggressive_resolver(player_index,yaw);elseif (mode=="Defensive") then adjustment=defensive_resolver(player_index,yaw);elseif (mode=="Jitter") then adjustment=jitter_resolver(player_index);elseif (mode=="Brute Force") then adjustment=brute_force_resolver(player_index,yaw);elseif (mode=="Median") then adjustment=median_resolver(player_index);elseif (mode=="DM Mode") then adjustment=dm_resolver(player_index,yaw);elseif (mode=="Adaptive") then adjustment=adaptive_resolver(player_index,yaw);end if (ui.get(config_elements.enable_prediction) and  not is_teleport and  not ui.get(config_elements.enable_exploit)) then local pred_yaw,_,is_aa=predict_angles(player_index);local error=math.abs(yaw-pred_yaw );local weight=math.min(0.9,math.max(0.3,1 -(error * 0.02) ));if (is_aa and ui.get(config_elements.enable_anti_aim_det)) then weight=weight * 0.5 ;end adjustment=(adjustment * (1 -weight)) + (pred_yaw * weight) ;end local decay=ui.get(config_elements.decay_factor_slider)/100 ;adjustment=(adjustment * (1 -decay)) + (ui.get(config_elements.default_yaw_adjustment) * decay) ;local hitbox=ui.get(config_elements.hitbox_selection);if (hitbox=="Dynamic") then hitbox=get_dynamic_hitbox(player_index);end local hit_chance=ui.get(config_elements.hit_chance_per_hitbox) or 0 ;plist.set(player_index,"correction active",0);plist.set(player_index,"force body yaw",1);plist.set(player_index,"body yaw",adjustment);plist.set(player_index,"hitbox override",hitbox);plist.set(player_index,"hit chance",hit_chance);if ui.get(config_elements.debug_overlay) then local view_offset_z=entity.get_prop(player_index,"m_vecViewOffset[2]") or 64 ;local head_z=origin.z + view_offset_z ;local x,y=renderer.world_to_screen(origin.x,origin.y,head_z);if (x and y) then local debug_text=string_format("Target: %d\nYaw: %.1f\nHitbox: %s\nHit Chance: %d%%\nFake Duck: %s",player_index,adjustment,hitbox,hit_chance,(game_database[player_index].fake_duck_detected and "Yes") or "No" );renderer_text(x,y,255,255,255,255,"c",0,debug_text);end end end client.set_event_callback("paint",function() for _,player in ipairs(entity.get_players(true)) do resolver_logic(player);end draw_top_menu();draw_bomb_timer_box();draw_hit_miss_logs();end);client.set_event_callback("aim_hit",function(e) local player_index=e.target;update_hit_stats(player_index,true);end);client.set_event_callback("aim_miss",function(e) local player_index=e.target;update_hit_stats(player_index,false);end);client.set_event_callback("player_connect",function(e) local player_index=e.userid;if game_database[player_index] then reset_player_data(player_index);end end);client.log("ADAPTIVE RESOLVER v5.6 | by morf1kxxx"); end