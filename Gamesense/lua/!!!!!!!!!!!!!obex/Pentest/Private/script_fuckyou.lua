-- only retards change this links
print('https://discord.gg/b37eKFbkPE <- scriptleaks new server')
-- https://discord.gg/b37eKFbkPE <- scriptleaks new server


--> Platform lock to prevent debugging outside skeet's interpreter
while debug do end

--> Localize luraph macros so the code will run unobfuscated
LPH_ENCSTR = function(...) return (...) end
LPH_JIT = function(...) return (...) end
LPH_JIT_MAX = function(...) return (...) end
LPH_NO_VIRTUALIZE = function(...) return (...) end

--> Attempt to break deobfuscators by utilizing as many luraph macros as possible
LPH_JIT(function() local deobf = LPH_ENCSTR(':)') end)()
LPH_JIT_MAX(function() local deobf = LPH_ENCSTR(':)') end)()
LPH_NO_VIRTUALIZE(function() local hi = ':)' end)()

--> Require ffi & bit library
while ffi do end
local ffi = require('ffi')
local bit = require('bit')

--> Reconstruct global functions to prevent hooks
local char_map = {}
local byte_map = {}

for i = 0, 255 do
	char_map[i] = string.char(i)
end

--> Function remake [string.char]
local string_char = function(...)
    local args, char_str = {...}, ''

    for i=1, #args do
        char_str = char_str..char_map[args[i]]
    end

	return char_str
end

for i = 0, 255 do
	byte_map[string_char(i)] = i
end

--> Function remake [string.byte]
local string_byte = function(char, i, j)
	if (i == nil) then return byte_map[char] end
	if (j == nil) then return byte_map[string.sub(char, i, i)] end

	local res = {}
	for n = i, j do
		res[#res+1] = byte_map[string.sub(char, n, n)]
	end
	
	return unpack(res)
end

--> Function remake [ffi.string]
local ffi_string = function (src, len)
    local str = ''

    if len then
        for i = 0, len - 1 do
            str = str .. string_char(src[i])
        end
    else
        local ptr = 0
        repeat
            str = str .. string_char(src[ptr])
            ptr = ptr + 1
        until src[ptr] == 0
    end

    return str
end

--> Function remake [table.concat]
local table_concat = function(table, seperator)
    local str = ''

    for i = 1, #table do
        str = (i == #table or seperator == nil) and str..table[i] or str..seperator..table[i]
    end
    
    return str
end

--> Function remake [math.abs]
local math_abs = function(number)
    return number < 0 and number * -1 or number
end

--> Custom clamp & between functions
local clamp = function(v, min, max)
    return v < min and min or v > max and max or v
end

local between = function(v, min, max)
    return v > min and v < max
end

--> Difference function
local difference = function(x, y)
    return math_abs(x - y)
end

--> Save args from loader
local obex_pass = ({({...})[1]})[1]

--> Console colors
local _r, _g, _b = unpack(obex_pass[5])

--> Table random number
local a={}local b={}local c={}local z=0;local e=0;local f=0;for g=0,255 do local h={}local i={}if g%3~=1 then h=function()return{}end;i=function()return{}end end;b[h]=i;a[i]=g;c[h]=i end;for j,k in next,b do local l=a[k]if c[j]==k then f=f+1 end;e=e+1;if e<=32 then z=z-l elseif e<=64 then z=z+l elseif e<=128 then z=z-l else z=z+l end end;while f~=256 do end

--> Base 64 encoding
local a=function(b,c,d)return bit.band(bit.rshift(b,c),bit.lshift(1,d)-1)end;local e=function(f)local g,h={},{}for i=1,65 do local j=string_byte(string.sub(f,i,i))or 32;if h[j]~=nil then error("invalid alphabet: duplicate character "..(j..''),3)end;g[i-1]=j;h[j]=i-1 end;return g,h end;local k,h={},{}k["_obase64"],h["_obase64"]=e("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")k["_obase64url"],h["_obase64url"]=e("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")local l={__index=function(m,n)if type(n)=="string"and#n==64 or#n==65 then k[n],h[n]=e(n)return m[n]end end}setmetatable(k,l)setmetatable(h,l)local _obase64={}_obase64.encode=function(p,g)g=k[g or"_obase64"]local q,r,s={},1,#p;local t=s%3;local u={}for i=1,s-t,3 do local v,w,x=string_byte(p,i,i+2)local b=v*0x10000+w*0x100+x;local y=u[b]if not y then y=string_char(g[a(b,18,6)],g[a(b,12,6)],g[a(b,6,6)],g[a(b,0,6)])u[b]=y end;q[r]=y;r=r+1 end;if t==2 then local v,w=string_byte(p,s-1,s)local b=v*0x10000+w*0x100;q[r]=string_char(g[a(b,18,6)],g[a(b,12,6)],g[a(b,6,6)],g[64])elseif t==1 then local b=string_byte(p,s)*0x10000;q[r]=string_char(g[a(b,18,6)],g[a(b,12,6)],g[64],g[64])end;return table_concat(q)end;_obase64.decode=function(p,g)g=h[g or"_obase64"]local z="[^%w%+%/%=]"if g then local A,B;for C,D in pairs(g)do if D==62 then A=C elseif D==63 then B=C end end;z=string.format("[^%%w%%%s%%%s%%=]",string_char(A),string_char(B))end;b64=string.gsub((p..''),z,"")local u={}local q,r={},1;local s=#b64;local E=string.sub(b64,-2)=="=="and 2 or string.sub(b64,-1)=="="and 1 or 0;for i=1,E>0 and s-4 or s,4 do local v,w,x,F=string_byte(b64,i,i+3)local G=v*0x1000000+w*0x10000+x*0x100+F;local y=u[G]if not y then local b=g[v]*0x40000+g[w]*0x1000+g[x]*0x40+g[F]y=string_char(a(b,16,8),a(b,8,8),a(b,0,8))u[G]=y end;q[r]=y;r=r+1 end;if E==1 then local v,w,x=string_byte(b64,s-3,s-1)local b=g[v]*0x40000+g[w]*0x1000+g[x]*0x40;q[r]=string_char(a(b,16,8),a(b,8,8))elseif E==2 then local v,w=string_byte(b64,s-3,s-2)local b=g[v]*0x40000+g[w]*0x1000;q[r]=string_char(a(b,16,8))end;return table_concat(q)end

--> HTTP library
local axw=function()local b,c,d;do if not pcall(ffi.sizeof,"SteamAPICall_t")then ffi.cdef([[
    typedef uint64_t SteamAPICall_t;

    struct SteamAPI_callback_base_vtbl {
        void(__thiscall *run1)(struct SteamAPI_callback_base *, void *, bool, uint64_t);
        void(__thiscall *run2)(struct SteamAPI_callback_base *, void *);
        int(__thiscall *get_size)(struct SteamAPI_callback_base *);
    };

    struct SteamAPI_callback_base {
        struct SteamAPI_callback_base_vtbl *vtbl;
        uint8_t flags;
        int id;
        uint64_t api_call_handle;
        struct SteamAPI_callback_base_vtbl vtbl_storage[1];
    };
]])end;local e={[-1]="No failure",[0]="Steam gone",[1]="Network failure",[2]="Invalid handle",[3]="Mismatched callback"}local f,g;local h,i;local j;local k=ffi.typeof("struct SteamAPI_callback_base")local l=ffi.sizeof(k)local m=ffi.typeof("struct SteamAPI_callback_base[1]")local n=ffi.typeof("struct SteamAPI_callback_base*")local o=ffi.typeof("uintptr_t")local p={}local q={}local r={}local function s(t)return tonumber(ffi.cast(o,t))..""end;local function u(self,v,w)if w then w=e[j(self.api_call_handle)]or"Unknown error"end;self.api_call_handle=0;xpcall(function()local x=s(self)local y=p[x]if y~=nil then xpcall(y,client.error_log,v,w)end;if q[x]~=nil then p[x]=nil;q[x]=nil end end,client.error_log)end;local function z(self,v,w,A)if A==self.api_call_handle then u(self,v,w)end end;local function B(self,v)u(self,v,false)end;local function C(self)return l end;local function D(self)if self.api_call_handle~=0 then g(self,self.api_call_handle)self.api_call_handle=0;local x=s(self)p[x]=nil;q[x]=nil end end;pcall(ffi.metatype,k,{__gc=D,__index={cancel=D}})local E=ffi.cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *, bool, uint64_t)",z)local F=ffi.cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *)",B)local G=ffi.cast("int(__thiscall *)(struct SteamAPI_callback_base *)",C)function b(A,y,H)assert(A~=0)local I=m()local J=ffi.cast(n,I)J.vtbl_storage[0].run1=E;J.vtbl_storage[0].run2=F;J.vtbl_storage[0].get_size=G;J.vtbl=J.vtbl_storage;J.api_call_handle=A;J.id=H;local x=s(J)p[x]=y;q[x]=I;f(J,A)return J end;function c(H,y)assert(r[H]==nil)local I=m()local J=ffi.cast(n,I)J.vtbl_storage[0].run1=E;J.vtbl_storage[0].run2=F;J.vtbl_storage[0].get_size=G;J.vtbl=J.vtbl_storage;J.api_call_handle=0;J.id=H;local x=s(J)p[x]=y;r[H]=I;h(J,H)end;local function K(L,M,N,O,P)local Q=client.find_signature(L,M)or error("signature not found",2)local R=ffi.cast("uintptr_t",Q)if O~=nil and O~=0 then R=R+O end;if P~=nil then for S=1,P do R=ffi.cast("uintptr_t*",R)[0]if R==nil then return error("signature not found")end end end;return ffi.cast(N,R)end;local function T(J,U,type)return ffi.cast(type,ffi.cast("void***",J)[0][U])end;f=K("steam_api.dll","\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xFF\x75\x10","void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")g=K("steam_api.dll","\x55\x8B\xEC\xFF\x75\x10\xFF\x75\x0C","void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")h=K("steam_api.dll","\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xC7\x05","void(__cdecl*)(struct SteamAPI_callback_base *, int)")i=K("steam_api.dll","\x55\x8B\xEC\xFF\x75\x10\xFF\x75\x0C","void(__cdecl*)(struct SteamAPI_callback_base *)")d=K("client_panorama.dll","\xB9\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x0F\x84","uintptr_t",1,1)local V=ffi.cast("uintptr_t*",d)[3]local W=T(V,12,"int(__thiscall*)(void*, SteamAPICall_t)")function j(X)return W(V,X)end;client.set_event_callback("shutdown",function()for x,Y in pairs(q)do local J=ffi.cast(n,Y)D(J)end;for x,Y in pairs(r)do local J=ffi.cast(n,Y)i(J)end end)end;if not pcall(ffi.sizeof,"http_HTTPRequestHandle")then ffi.cdef([[
typedef uint32_t http_HTTPRequestHandle;
typedef uint32_t http_HTTPCookieContainerHandle;

enum http_EHTTPMethod {
    k_EHTTPMethodInvalid,
    k_EHTTPMethodGET,
    k_EHTTPMethodHEAD,
    k_EHTTPMethodPOST,
    k_EHTTPMethodPUT,
    k_EHTTPMethodDELETE,
    k_EHTTPMethodOPTIONS,
    k_EHTTPMethodPATCH,
};

struct http_ISteamHTTPVtbl {
    http_HTTPRequestHandle(__thiscall *CreateHTTPRequest)(uintptr_t, enum http_EHTTPMethod, const char *);
    bool(__thiscall *SetHTTPRequestContextValue)(uintptr_t, http_HTTPRequestHandle, uint64_t);
    bool(__thiscall *SetHTTPRequestNetworkActivityTimeout)(uintptr_t, http_HTTPRequestHandle, uint32_t);
    bool(__thiscall *SetHTTPRequestHeaderValue)(uintptr_t, http_HTTPRequestHandle, const char *, const char *);
    bool(__thiscall *SetHTTPRequestGetOrPostParameter)(uintptr_t, http_HTTPRequestHandle, const char *, const char *);
    bool(__thiscall *SendHTTPRequest)(uintptr_t, http_HTTPRequestHandle, SteamAPICall_t *);
    bool(__thiscall *SendHTTPRequestAndStreamResponse)(uintptr_t, http_HTTPRequestHandle, SteamAPICall_t *);
    bool(__thiscall *DeferHTTPRequest)(uintptr_t, http_HTTPRequestHandle);
    bool(__thiscall *PrioritizeHTTPRequest)(uintptr_t, http_HTTPRequestHandle);
    bool(__thiscall *GetHTTPResponseHeaderSize)(uintptr_t, http_HTTPRequestHandle, const char *, uint32_t *);
    bool(__thiscall *GetHTTPResponseHeaderValue)(uintptr_t, http_HTTPRequestHandle, const char *, uint8_t *, uint32_t);
    bool(__thiscall *GetHTTPResponseBodySize)(uintptr_t, http_HTTPRequestHandle, uint32_t *);
    bool(__thiscall *GetHTTPResponseBodyData)(uintptr_t, http_HTTPRequestHandle, uint8_t *, uint32_t);
    bool(__thiscall *GetHTTPStreamingResponseBodyData)(uintptr_t, http_HTTPRequestHandle, uint32_t, uint8_t *, uint32_t);
    bool(__thiscall *ReleaseHTTPRequest)(uintptr_t, http_HTTPRequestHandle);
    bool(__thiscall *GetHTTPDownloadProgressPct)(uintptr_t, http_HTTPRequestHandle, float *);
    bool(__thiscall *SetHTTPRequestRawPostBody)(uintptr_t, http_HTTPRequestHandle, const char *, uint8_t *, uint32_t);
    http_HTTPCookieContainerHandle(__thiscall *CreateCookieContainer)(uintptr_t, bool);
    bool(__thiscall *ReleaseCookieContainer)(uintptr_t, http_HTTPCookieContainerHandle);
    bool(__thiscall *SetCookie)(uintptr_t, http_HTTPCookieContainerHandle, const char *, const char *, const char *);
    bool(__thiscall *SetHTTPRequestCookieContainer)(uintptr_t, http_HTTPRequestHandle, http_HTTPCookieContainerHandle);
    bool(__thiscall *SetHTTPRequestUserAgentInfo)(uintptr_t, http_HTTPRequestHandle, const char *);
    bool(__thiscall *SetHTTPRequestRequiresVerifiedCertificate)(uintptr_t, http_HTTPRequestHandle, bool);
    bool(__thiscall *SetHTTPRequestAbsoluteTimeoutMS)(uintptr_t, http_HTTPRequestHandle, uint32_t);
    bool(__thiscall *GetHTTPRequestWasTimedOut)(uintptr_t, http_HTTPRequestHandle, bool *pbWasTimedOut);
};
]])end;local Z={get=ffi.C.k_EHTTPMethodGET,head=ffi.C.k_EHTTPMethodHEAD,post=ffi.C.k_EHTTPMethodPOST,put=ffi.C.k_EHTTPMethodPUT,delete=ffi.C.k_EHTTPMethodDELETE,options=ffi.C.k_EHTTPMethodOPTIONS,patch=ffi.C.k_EHTTPMethodPATCH}local _={[100]="Continue",[101]="Switching Protocols",[102]="Processing",[200]="OK",[201]="Created",[202]="Accepted",[203]="Non-Authoritative Information",[204]="No Content",[205]="Reset Content",[206]="Partial Content",[207]="Multi-Status",[208]="Already Reported",[250]="Low on Storage Space",[226]="IM Used",[300]="Multiple Choices",[301]="Moved Permanently",[302]="Found",[303]="See Other",[304]="Not Modified",[305]="Use Proxy",[306]="Switch Proxy",[307]="Temporary Redirect",[308]="Permanent Redirect",[400]="Bad Request",[401]="Unauthorized",[402]="Payment Required",[403]="Forbidden",[404]="Not Found",[405]="Method Not Allowed",[406]="Not Acceptable",[407]="Proxy Authentication Required",[408]="Request Timeout",[409]="Conflict",[410]="Gone",[411]="Length Required",[412]="Precondition Failed",[413]="Request Entity Too Large",[414]="Request-URI Too Long",[415]="Unsupported Media Type",[416]="Requested Range Not Satisfiable",[417]="Expectation Failed",[418]="I'm a teapot",[420]="Enhance Your Calm",[422]="Unprocessable Entity",[423]="Locked",[424]="Failed Dependency",[424]="Method Failure",[425]="Unordered Collection",[426]="Upgrade Required",[428]="Precondition Required",[429]="Too Many Requests",[431]="Request Header Fields Too Large",[444]="No Response",[449]="Retry With",[450]="Blocked by Windows Parental Controls",[451]="Parameter Not Understood",[451]="Unavailable For Legal Reasons",[451]="Redirect",[452]="Conference Not Found",[453]="Not Enough Bandwidth",[454]="Session Not Found",[455]="Method Not Valid in This State",[456]="Header Field Not Valid for Resource",[457]="Invalid Range",[458]="Parameter Is Read-Only",[459]="Aggregate Operation Not Allowed",[460]="Only Aggregate Operation Allowed",[461]="Unsupported Transport",[462]="Destination Unreachable",[494]="Request Header Too Large",[495]="Cert Error",[496]="No Cert",[497]="HTTP to HTTPS",[499]="Client Closed Request",[500]="Internal Server Error",[501]="Not Implemented",[502]="Bad Gateway",[503]="Service Unavailable",[504]="Gateway Timeout",[505]="HTTP Version Not Supported",[506]="Variant Also Negotiates",[507]="Insufficient Storage",[508]="Loop Detected",[509]="Bandwidth Limit Exceeded",[510]="Not Extended",[511]="Network Authentication Required",[551]="Option not supported",[598]="Network read timeout error",[599]="Network connect timeout error"}local a0={"params","body","json"}local a1=2101;local a2=2102;local a3=2103;local function a4()local a5=ffi.cast("uintptr_t*",d)[12]if a5==0 or a5==nil then return error("find_isteamhttp failed")end;local a6=ffi.cast("struct http_ISteamHTTPVtbl**",a5)[0]if a6==0 or a6==nil then return error("find_isteamhttp failed")end;return a5,a6 end;local function a7(a8)return function(...)local a9=a8[2]return a8[1](a9,...)end end;local aa=ffi.typeof([[
struct {
http_HTTPRequestHandle m_hRequest;
uint64_t m_ulContextValue;
bool m_bRequestSuccessful;
int m_eStatusCode;
uint32_t m_unBodySize;
} *
]])local ab=ffi.typeof([[
struct {
http_HTTPRequestHandle m_hRequest;
uint64_t m_ulContextValue;
} *
]])local ac=ffi.typeof([[
struct {
http_HTTPRequestHandle m_hRequest;
uint64_t m_ulContextValue;
uint32_t m_cOffset;
uint32_t m_cBytesReceived;
} *
]])local ad=ffi.typeof([[
struct {
http_HTTPCookieContainerHandle m_hCookieContainer;
}
]])local ae=ffi.typeof("SteamAPICall_t[1]")local af=ffi.typeof("const char[?]")local ag=ffi.typeof("uint8_t[?]")local ah=ffi.typeof("unsigned int[?]")local ai=ffi.typeof("bool[1]")local aj=ffi.typeof("float[1]")local ak,al=a4()local am=a7({al.CreateHTTPRequest,ak})local an=a7({al.SetHTTPRequestContextValue,ak})local ao=a7({al.SetHTTPRequestNetworkActivityTimeout,ak})local ap=a7({al.SetHTTPRequestHeaderValue,ak})local aq=a7({al.SetHTTPRequestGetOrPostParameter,ak})local ar=a7({al.SendHTTPRequest,ak})local as=a7({al.SendHTTPRequestAndStreamResponse,ak})local at=a7({al.DeferHTTPRequest,ak})local au=a7({al.PrioritizeHTTPRequest,ak})local av=a7({al.GetHTTPResponseHeaderSize,ak})local aw=a7({al.GetHTTPResponseHeaderValue,ak})local ax=a7({al.GetHTTPResponseBodySize,ak})local ay=a7({al.GetHTTPResponseBodyData,ak})local az=a7({al.GetHTTPStreamingResponseBodyData,ak})local aA=a7({al.ReleaseHTTPRequest,ak})local aB=a7({al.GetHTTPDownloadProgressPct,ak})local aC=a7({al.SetHTTPRequestRawPostBody,ak})local aD=a7({al.CreateCookieContainer,ak})local aE=a7({al.ReleaseCookieContainer,ak})local aF=a7({al.SetCookie,ak})local aG=a7({al.SetHTTPRequestCookieContainer,ak})local aH=a7({al.SetHTTPRequestUserAgentInfo,ak})local aI=a7({al.SetHTTPRequestRequiresVerifiedCertificate,ak})local aJ=a7({al.SetHTTPRequestAbsoluteTimeoutMS,ak})local aK=a7({al.GetHTTPRequestWasTimedOut,ak})local aL,aM={},false;local aN,aO=false,{}local aP,aQ=false,{}local aR=setmetatable({},{__mode="k"})local aS,aT=setmetatable({},{__mode="k"}),setmetatable({},{__mode="v"})local aU={}local aV={__index=function(aW,aX)local aY=aS[aW]if aY==nil then return end;aX=aX..""if aY.m_hRequest~=0 then local aZ=ah(1)if av(aY.m_hRequest,aX,aZ)then if aZ~=nil then aZ=aZ[0]if aZ<0 then return end;local a_=ag(aZ)if aw(aY.m_hRequest,aX,a_,aZ)then aW[aX]=ffi_string(a_,aZ-1)return aW[aX]end end end end end,__metatable=false}local b0={__index={set_cookie=function(b1,b2,b3,aX,Y)local X=aR[b1]if X==nil or X.m_hCookieContainer==0 then return end;aF(X.m_hCookieContainer,b2,b3,(aX.."").."="..Y.."")end},__metatable=false}local function b4(X)if X.m_hCookieContainer~=0 then aE(X.m_hCookieContainer)X.m_hCookieContainer=0 end end;local function b5(aY)if aY.m_hRequest~=0 then aA(aY.m_hRequest)aY.m_hRequest=0 end end;local function b6(b7,...)aA(b7)return error(...)end;local function b8(aY,b9,ba,bb,...)local bc=aT[aY.m_hRequest]if bc==nil then bc=setmetatable({},aV)aT[aY.m_hRequest]=bc end;aS[bc]=aY;bb.headers=bc;aM=true;xpcall(b9,client.error_log,ba,bb,...)aM=false end;local function bd(v,w)if v==nil then return end;local aY=ffi.cast(aa,v)if aY.m_hRequest~=0 then local b9=aL[aY.m_hRequest]if b9~=nil then aL[aY.m_hRequest]=nil;aQ[aY.m_hRequest]=nil;aO[aY.m_hRequest]=nil;if b9 then local ba=w==false and aY.m_bRequestSuccessful;local be=aY.m_eStatusCode;local bf={status=be}local bg=aY.m_unBodySize;if ba and bg>0 then local a_=ag(bg)if ay(aY.m_hRequest,a_,bg)then bf.body=bg>=15000 and ffi.string(a_,bg)or ffi_string(a_,bg)if#bf.body~=bg then while true do end end end elseif not aY.m_bRequestSuccessful then local bh=ai()aK(aY.m_hRequest,bh)bf.timed_out=bh~=nil and bh[0]==true end;if be>0 then bf.status_message=_[be]or"Unknown status"elseif w then bf.status_message=string.format("IO Failure: %s",w)else bf.status_message=bf.timed_out and"Timed out"or"Unknown error"end;b8(aY,b9,ba,bf)end;b5(aY)end end end;local function bi(v,w)if v==nil then return end;local aY=ffi.cast(ab,v)if aY.m_hRequest~=0 then local b9=aO[aY.m_hRequest]if b9 then b8(aY,b9,w==false,{})end end end;local function bj(v,w)if v==nil then return end;local aY=ffi.cast(ac,v)if aY.m_hRequest~=0 then local b9=aQ[aY.m_hRequest]if aQ[aY.m_hRequest]then local bb={}local bk=aj()if aB(aY.m_hRequest,bk)then bb.download_progress=tonumber(bk[0])end;local a_=ag(aY.m_cBytesReceived)if az(aY.m_hRequest,aY.m_cOffset,a_,aY.m_cBytesReceived)then bb.body=ffi_string(a_,aY.m_cBytesReceived)end;b8(aY,b9,w==false,bb)end end end;local function bl(bm,b3,bn,bo)if type(bn)=="function"and bo==nil then bo=bn;bn={}end;bn=bn or{}local bm=Z[string.lower(bm.."")]if bm==nil then return error("invalid HTTP method")end;if type(b3)~="string"then return error("URL has to be a string")end;local bp,bq,br;if type(bo)=="function"then bp=bo elseif type(bo)=="table"then bp=bo.completed or bo.complete;bq=bo.headers_received or bo.headers;br=bo.data_received or bo.data;if bp~=nil and type(bp)~="function"then return error("callbacks.completed callback has to be a function")elseif bq~=nil and type(bq)~="function"then return error("callbacks.headers_received callback has to be a function")elseif br~=nil and type(br)~="function"then return error("callbacks.data_received callback has to be a function")end else return error("callbacks has to be a function or table")end;bm=tonumber(bm)local bs={bm}bm=bs[1]local b7=am(bm,b3)if b7==0 then return error("Failed to create HTTP request")end;local bt=false;for S,x in ipairs(a0)do if bn[x]~=nil then if bt then return error("can only set options.params, options.body or options.json")else bt=true end end end;local bu;if bn.json~=nil then local bv;bv,bu=pcall(json.stringify,bn.json)if not bv then return error("options.json is invalid: "..bu)end end;local bw=bn.network_timeout;if bw==nil then bw=30 end;if type(bw)=="number"and bw>0 then if not ao(b7,bw)then return b6(b7,"failed to set network_timeout")end elseif bw~=nil then return b6(b7,"options.network_timeout has to be of type number and greater than 0")end;local bx=bn.absolute_timeout;if bx==nil then bx=60 end;if type(bx)=="number"and bx>0 then if not aJ(b7,bx*1000)then return b6(b7,"failed to set absolute_timeout")end elseif bx~=nil then return b6(b7,"options.absolute_timeout has to be of type number and greater than 0")end;local by=bu~=nil and"application/json"or"text/plain"local bz;local bc=bn.headers;if type(bc)=="table"then for aX,Y in pairs(bc)do aX=aX..""Y=Y..""local bA=string.lower(aX)if bA=="content-type"then by=Y elseif bA=="authorization"then bz=true end;if not ap(b7,aX,Y)then return b6(b7,"failed to set header "..aX)end end elseif bc~=nil then return b6(b7,"options.headers has to be of type table")end;local bB=bn.authorization;if type(bB)=="table"then if bz then return b6(b7,"Cannot set both options.authorization and the 'Authorization' header.")end;local bC,bD=bB[1],bB[2]local bE=string.format("Basic %s",_obase64(string.format("%s:%s",bC.."",bD..""),1))if not ap(b7,"Authorization",bE)then return b6(b7,"failed to apply options.authorization")end elseif bB~=nil then return b6(b7,"options.authorization has to be of type table")end;local bF=bu or bn.body;if type(bF)=="string"then local bG=#bF;if not aC(b7,by,ffi.cast("unsigned char*",bF),bG)then return b6(b7,"failed to set post body")end elseif bF~=nil then return b6(b7,"options.body has to be of type string")end;local bH=bn.params;if type(bH)=="table"then for aX,Y in pairs(bH)do aX=aX..""if not aq(b7,aX,Y.."")then return b6(b7,"failed to set parameter "..aX)end end elseif bH~=nil then return b6(b7,"options.params has to be of type table")end;local bI=bn.require_ssl;if type(bI)=="boolean"then if not aI(b7,bI==true)then return b6(b7,"failed to set require_ssl")end elseif bI~=nil then return b6(b7,"options.require_ssl has to be of type boolean")end;local bJ=bn.user_agent_info;if type(bJ)=="string"then if not aH(b7,bJ.."")then return b6(b7,"failed to set user_agent_info")end elseif bJ~=nil then return b6(b7,"options.user_agent_info has to be of type string")end;local bK=bn.cookie_container;if type(bK)=="table"then local X=aR[bK]if X~=nil and X.m_hCookieContainer~=0 then if not aG(b7,X.m_hCookieContainer)then return b6(b7,"failed to set user_agent_info")end else return b6(b7,"options.cookie_container has to a valid cookie container")end elseif bK~=nil then return b6(b7,"options.cookie_container has to a valid cookie container")end;local bL=ar;local bM=bn.stream_response;if type(bM)=="boolean"then if bM then bL=as;if bp==nil and bq==nil and br==nil then return b6(b7,"a 'completed', 'headers_received' or 'data_received' callback is required")end else if bp==nil then return b6(b7,"'completed' callback has to be set for non-streamed requests")elseif bq~=nil or br~=nil then return b6(b7,"non-streamed requests only support 'completed' callbacks")end end elseif bM~=nil then return b6(b7,"options.stream_response has to be of type boolean")end;if bq~=nil or br~=nil then aO[b7]=bq or false;if bq~=nil then if not aN then c(a2,bi)aN=true end end;aQ[b7]=br or false;if br~=nil then if not aP then c(a3,bj)aP=true end end end;local bN=ae()if not bL(b7,bN)then aA(b7)if bp~=nil then bp(false,{status=0,status_message="Failed to send request"})end;return end;if bn.priority=="defer"or bn.priority=="prioritize"then local bO=bn.priority=="prioritize"and au or at;if not bO(b7)then return b6(b7,"failed to set priority")end elseif bn.priority~=nil then return b6(b7,"options.priority has to be 'defer' of 'prioritize'")end;aL[b7]=bp or false;if bp~=nil then b(bN[0],bd,a1)end end;local function bP(bQ)if bQ~=nil and type(bQ)~="boolean"then return error("allow_modification has to be of type boolean")end;local bR=aD(bQ==true)if bR~=nil then local X=ad(bR)ffi.gc(X,b4)local x=setmetatable({},b0)aR[x]=X;return x end end;local bS={request=bl,create_cookie_container=bP}for bm in pairs(Z)do bS[bm]=function(...)return bl(bm,...)end end;return bS end;local http = axw()

--> obex_tbl
local obex_tbl = {
    --> Authorization
    logged_in = false,
    lua_table = {},

    --> Console interaction
    console_entries = {},

    --> Count randomization
    count = 1,

    --> Retarded callback stuff
    loadscript_var = true,
}

--> sha256 lib
local sha256 = function(arg)
    arg = arg..''
	local a=2^32;local b=a-1;local function c(d)local e={}local f=setmetatable({},e)function e:__index(g)local h=d(g)f[g]=h;return h end;return f end;local function i(f,j)local function k(l,m)local n,o=0,1;while l~=0 and m~=0 do local p,q=l%j,m%j;n=n+f[p][q]*o;l=(l-p)/j;m=(m-q)/j;o=o*j end;n=n+(l+m)*o;return n end;return k end;local function r(f)local s=i(f,2^1)local t=c(function(l)return c(function(m)return s(l,m)end)end)return i(t,2^(f.n or 1))end;local u=r({[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0},n=4})local function v(l,m,w,...)local x=nil;if m then l=l%a;m=m%a;x=u(l,m)if w then x=v(x,w,...)end;return x elseif l then return l%a else return 0 end end;local function y(l,m,w,...)local x;if m then l=l%a;m=m%a;x=(l+m-u(l,m))/2;if w then x=bit.band(x,w,...)end;return x elseif l then return l%a else return b end end;local function z(A)return(-1-A)%a end;local function B(l,C)if C<0 then return lshift(l,-C)end;return math.floor(l%2^32/2^C)end;local function D(A,C)if C>31 or C<-31 then return 0 end;return B(A%a,C)end;local function lshift(l,C)if C<0 then return D(l,-C)end;return l*2^C%2^32 end;local function E(A,C)A=A%a;C=C%32;local F=y(A,2^C-1)return D(A,C)+lshift(F,32-C)end;local g={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}local function G(H)return string.gsub(H,'.',function(w)return string.format('%02x',string_byte(w))end)end;local function I(J,K)local H=''for L=1,K do local M=J%256;H=string_char(M)..H;J=(J-M)/256 end;return H end;local function N(H,L)local K=0;for L=L,L+3 do K=K*256+string_byte(H,L)end;return K end;local function O(P,Q)local R=64-(Q+9)%64;Q=I(8*Q,8)P=P..'\128'..string.rep('\0',R)..Q;assert(#P%64==0)return P end;local function S(T)T[1]=0x6a09e667;T[2]=0xbb67ae85;T[3]=0x3c6ef372;T[4]=0xa54ff53a;T[5]=0x510e527f;T[6]=0x9b05688c;T[7]=0x1f83d9ab;T[8]=0x5be0cd19;return T end;local function U(P,L,T)local V={}for W=1,16 do V[W]=N(P,L+(W-1)*4)end;for W=17,64 do local h=V[W-15]local X=v(E(h,7),E(h,18),D(h,3))h=V[W-2]V[W]=V[W-16]+X+V[W-7]+v(E(h,17),E(h,19),D(h,10))end;local l,m,w,Y,Z,d,_,a0=T[1],T[2],T[3],T[4],T[5],T[6],T[7],T[8]for L=1,64 do local X=v(E(l,2),E(l,13),E(l,22))local a1=v(y(l,m),y(l,w),y(m,w))local a2=X+a1;local a3=v(E(Z,6),E(Z,11),E(Z,25))local a4=v(y(Z,d),y(z(Z),_))local a5=a0+a3+a4+g[L]+V[L]a0,_,d,Z,Y,w,m,l=_,d,Z,Y+a5,w,m,l,a5+a2 end;T[1]=y(T[1]+l)T[2]=y(T[2]+m)T[3]=y(T[3]+w)T[4]=y(T[4]+Y)T[5]=y(T[5]+Z)T[6]=y(T[6]+d)T[7]=y(T[7]+_)T[8]=y(T[8]+a0)end;local function call_sha(P)P=O(P,#P)local T=S({})for L=1,#P,64 do U(P,L,T)end;return G(I(T[1],4)..I(T[2],4)..I(T[3],4)..I(T[4],4)..I(T[5],4)..I(T[6],4)..I(T[7],4)..I(T[8],4))end return call_sha(arg)
end

--> RC4 encryption
local a = function(b)
    local c = {}

    for d = 0, 255 do
        c[d] = {}
    end

    c[0][0] = b[1] * 255
    local e = 1

    for f = 0, 7 do
        for d = 0, e - 1 do
            for g = 0, e - 1 do
                local h = c[d][g] - b[1] * e
                c[d][g + e] = h + b[2] * e
                c[d + e][g] = h + b[3] * e
                c[d + e][g + e] = h + b[4] * e
            end
        end
        e = e * 2
    end

    return c
end

local i = a{0, 1, 1, 0}

local j = function(self, k)
    local l, d, g = self.S, self.i, self.j
    local m = {}
    local n = string_char

    for o = 1, k do
        d = (d + 1) % 256
        g = (g + l[d]) % 256
        l[d], l[g] = l[g], l[d]
        m[o] = n(l[(l[d] + l[g]) % 256])
    end

    self.i, self.j = d, g

    return table_concat(m)
end

local p = function(self, q)
    local r = j(self, #q)
    local s = {}
    local t = string_byte
    local n = string_char

    for d = 1, #q do
        s[d] = n(i[t(q, d)][t(r, d)])
    end

    return table_concat(s)
end

local u = function(self, v)
    local l = self.S
    local g, w = 0, #v
    local t = string_byte

    for d = 0, 255 do
        g = (g + l[d] + t(v, d % w + 1)) % 256
        l[d], l[g] = l[g], l[d]
    end
end

local new_enc_key = function(v)
    local l = {}
    local s = {S = l, i = 0, j = 0, generate = j, cipher = p, schedule = u}

    for d = 0, 255 do
        l[d] = d
    end

    if v then
        s:schedule(v)
    end
    
    return s
end

_G[(function()local t = {};t.str = {210,102,55,208,122,146,222};t.key = 'a8e9f4099ecb12c0d02e22c725e24fb8d35450c049c53f78327381adfb9bf515';local s = "";for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)()][(function()local t = {};t.str = {199,195,166,252,192,149};t.key = 'fe487187365f5e336a265fe6b8049f2e90dbad0bfca9d252f6258ec77893bd6d';local s = "";for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)()][(function()local t = {};t.str = {129,27,130,100,202,235,2,196};t.key = 'f6aa8cba874078735ff9246fb6365ae5683b5d367f180ec490e143cae7cf1a22';local s = "";for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)()] = nil

--> Protected constants
local constants = {
    -- Obex reborn 1.0 (273a60f6a4769ef93d59c675778f42cd6a70af118cf9d695f5b134a396956297)
    param_key = (function()local t = {};t.str = {0,99,219,53,119,148,216,248,253,189,55,31,245,240,212,126,31,61,150,112,216,23,24,240,96,237,214,145,252,34,30,245,30,113,110,243,227,210,235,106,249,205,252,71,174,45,108,25,198,29,52,32,65,72,182,67,0,65,66,8,179,164,75,26};t.key = '8c640a41b6b427a5b099429ef11572a352f7e5af616c8b50d5e35b7a97c9898f';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- Tried to hook: function list of hooked functions.
    hook_ban = (function()local t = {};t.str = {249,44,99,83,108,118,23,62,68,214,221,193,86,229,7};t.key = '87828db02d0aceaa124e26f30b4194d5a3b198c1f116ca30b1cd58067d83e737';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- Loader sharing detected, mismatched hwid.
    mismatched_hwid = (function()local t = {};t.str = {35,244,224,250,188,218,168,169,19,130,6,16,127,226,191,252,201,224,173,199,122,71,201,4,125,144,246,122,236,153,212,163,190,91,246,219,231,21,253,182,0};t.key = 'a5d49ee2a4946deedd160cc80d73f24538367d3742afa54b16be657f1b474ce5';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- Tried to debug http requests.
    debugging_http_req = (function()local t = {};t.str = {92,10,32,77,68,5,192,110,11,163,127,214,74,99,204,186,108,92,124,119,247,231,172,209,237,191,156,197,244};t.key = 'c32f8b646347a49484fa4822a2fd57d7f4a74831ba0de7f4fe9006686908f92d';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- FindWindowA
    find_window = (function()local t = {};t.str = {194,160,196,74,170,124,18,131,199,221,51};t.key = 'f9d130f9b24df25e793c42c8da5ce4158e1b05f50f429516a3a6e7132b13bd7a';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- XTPMainFrame
    http_debugger_pro = (function()local t = {};t.str = {156,171,206,23,141,4,31,114,99,188,45,246};t.key = 'dec8de8d4d49f8df88990598ed916a6fb5db85bcca1f1bea34d68f684289cf1c';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- TStdHttpAnalyzerForm
    http_analyzer_v7 = (function()local t = {};t.str = {173,8,1,199,109,8,97,117,118,225,10,124,61,122,81,239,160,104,32,235};t.key = 'c401a2f40f02d91cc01b70b39221ba5e54bf0e0f42176f79cf1a28a3767d1953';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- Software\\Microsoft\\UserData
    database_location = (function()local t = {};t.str = {34,31,175,161,193,27,148,42,169,68,35,203,23,190};t.key = '65ae65283c5b9f07070a923a1a7944f32b337b6bd668141225df963010a8cc84';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),
    
    -- tostring
    tostring = (function()local t = {};t.str = {180,245,81,222,7,169,250,172};t.key = '9c5e31deff9901d0091f72e8a4d7baed93b148e602c3984090b1306a76a1cf5a';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),

    -- function: builtin#19
    tostring_sig = (function()local t = {};t.str = {251,205,95,57,58,98,195,221,164,95,114,64,169,232,32,18,183,18,95,244};t.key = '814cab13cca859f5e0801e7889ce444bd290203b348f6634fbf68a179b988e6e';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)(),
}

--> FFI
local jmp_ecx = client.find_signature('engine.dll', '\xFF\xE1')

--> Random integer function
--> ida sig: 68 FF FF FF 7F 68 00 00 00 80 FF 15 ?? ?? ?? ?? (plus 12)
local random_int_sig = client.find_signature('engine.dll', '\x68\xFF\xFF\xFF\x7F\x68\x00\x00\x00\x80\xFF\x15\xCC\xCC\xCC\xCC')
local random_int_ptr = ffi.cast('uint32_t**', ffi.cast('uint32_t', random_int_sig) + 12)[0][0]
local random_int_fn = ffi.cast('int32_t(__fastcall*)(unsigned int, unsigned int, int, int)', jmp_ecx)
local ffi_random = function(min, max) return random_int_fn(random_int_ptr, 0, min, max) end

ffi.cdef[[
    typedef uint32_t(__fastcall* create)(unsigned int, unsigned int, uint32_t, const char*, uint32_t, unsigned long, uint32_t, uint32_t, uint32_t, uint32_t*, uint32_t);
    typedef uint32_t(__fastcall* set)(unsigned int, unsigned int, uint32_t, unsigned char*, uint32_t, uint32_t, unsigned char*, uint32_t);
    typedef uint32_t(__fastcall* open)(unsigned int, unsigned int, uint32_t, const char*, uint32_t, uint32_t, uint32_t*);
    typedef uint32_t(__fastcall* query)(unsigned int, unsigned int, uint32_t, const char*, uint32_t, uint32_t, unsigned char*, uint32_t*);
    typedef uint32_t(__fastcall* close)(unsigned int, unsigned int, uint32_t);
]]

local get_import_func = function(dll, sig, offset, typedef)
    local call_address = client.find_signature(dll, sig)
    local import_address = ffi.cast('uint32_t**', ffi.cast('uint32_t', call_address) + offset)[0][0]
    local import_fn = ffi.cast(typedef, jmp_ecx)

    return function(...)
        return import_fn(import_address, 0, ...)
    end
end

local create_reg_key = get_import_func('engine.dll', '\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0D', 7, 'create')
local set_reg_key = get_import_func('engine.dll', '\xFF\x71\x08\xFF\x15\xCC\xCC\xCC\xCC\x5D', 5, 'set')

local open_reg_key = get_import_func('engine.dll', '\x8B\xF9\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0', 4, 'open')
local query_reg_key = get_import_func('engine.dll', '\xFF\x74\x24\x24\xFF\x15\xCC\xCC\xCC\xCC', 6, 'query')
local close_reg_key = get_import_func('engine.dll', '\xFF\x74\x24\x10\xFF\x15\xCC\xCC\xCC\xCC', 6, 'close')

local database_read = function(key)
    local hkey = ffi.new('uint32_t[1]')
    local value = ffi.new('char[1024]')
    local len = ffi.new('uint32_t[1]', 1024)

    open_reg_key(0x80000001, constants.database_location, 0, 0x0001, hkey)
    query_reg_key(hkey[0], key, 0, 0, value, len)
    close_reg_key(hkey[0])

    if key == 'username' or key == 'password' then
        return ffi.string(value)
    else
        return ffi_string(value)
    end
end

local database_write = function(key, data)
    local hkey = ffi.new('uint32_t[1]')
    local key_w = ffi.new('unsigned char[1024]', key)
    local data_w = ffi.new('unsigned char[1024]', data)

    create_reg_key(0x80000001, constants.database_location, 0, 0, 0, 0x0002, 0, hkey, 0)
    set_reg_key(hkey[0], key_w, 0, 1, data_w, #ffi_string(data_w) + 1)
    close_reg_key(hkey[0])
end

local material_adapter_info_t = ffi.typeof[[ 
	struct {
		char driver_name[512];
		uint32_t vendor_id;
		uint32_t device_id;
		uint32_t sub_sys_id;
		uint32_t revision;
		int dx_support_level;
		int min_dx_support_level;
		int max_dx_support_level;
		uint32_t driver_version_high;
		uint32_t driver_version_low;
	}
]]
local native_GetCurrentAdapter = vtable_bind('materialsystem.dll', 'VMaterialSystem080', 25, 'int(__thiscall*)(void*)')
local native_GetAdapterInfo = vtable_bind('materialsystem.dll', 'VMaterialSystem080', 26, 'void(__thiscall*)(void*, int, void*)')

local log = function(string)
    client.color_log(_r, _g, _b, 'Ob\0')client.color_log(200, 200, 200, 'ex \0')client.color_log(_r, _g, _b, '-> \0')client.color_log(200, 200, 200, string)
end

--> FindWindowA
local get_process_address_sig = client.find_signature('engine.dll', '\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05')
local get_module_uint32_t_sig = client.find_signature('engine.dll', '\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B')

local get_proc_address_ptr = ffi.cast('uint32_t**', ffi.cast('uint32_t', get_process_address_sig) + 2)[0][0]
local get_module_uint32_t_ptr = ffi.cast('uint32_t**', ffi.cast('uint32_t', get_module_uint32_t_sig) + 2)[0][0]
local get_proc_address_fn = ffi.cast('uint32_t(__fastcall*)(unsigned int, unsigned int, uint32_t, const char*)', jmp_ecx)
local get_module_uint32_t_fn = ffi.cast('uint32_t(__fastcall*)(unsigned int, unsigned int, const char*)', jmp_ecx)

local function sig_bind(module, interface, signature, typestring)
	local iface = client.create_interface(module, interface) or error('invalid interface', 2)
	local instance = client.find_signature(module, signature) or error('invalid signature', 2)
	local success, typeof = pcall(ffi.typeof, typestring)
	if not success then
		error(typeof, 2)
	end
	local fnptr = ffi.cast(typeof, instance) or error('invalid typecast', 2)
	return function(...)
		return fnptr(iface, ...)
	end
end

local proc_bind = function(b, c, d)
    local e = get_module_uint32_t_fn(get_module_uint32_t_ptr, 0, b)
    local f = get_proc_address_fn(get_proc_address_ptr, 0, e, c)
    local g = ffi.cast(ffi.typeof(d), jmp_ecx)

    return function(...)
        return g(f, 0, ...)
    end
end
local find_window_a = proc_bind('User32.dll', constants.find_window, 'uint32_t(__fastcall*)(unsigned int, unsigned int, const char*, uint32_t)')

--> Hardware id
local hwid = database_read('hwid')
local unix = database_read('unix')
while (#hwid < 8 or #unix < 8) do end

local current_adapter = native_GetCurrentAdapter()
local adapter_info = material_adapter_info_t()
native_GetAdapterInfo(current_adapter, adapter_info)

if adapter_info.vendor_id == 0 or adapter_info.device_id == 0 then
    while true do end;LPH_CRASH();ffi.cast('uint32_t*', 0)[0] = 1
end

hwid = hwid..(adapter_info.vendor_id + adapter_info.device_id + adapter_info.sub_sys_id)

local param_enc = function(string)
    string = string..'';return _obase64.encode(new_enc_key(constants.param_key):cipher(string))
end

--> Table for http requests
local http_data = {
    ['handshake'] = param_enc('unknown_not_set_error'), -- Handshake number
    ['shared'] = param_enc('unknown_not_set_error'), -- Shared encryption key
    ['type'] = param_enc('unknown_not_set_error'), -- Request type

    ['script'] = param_enc('unknown_not_set_error'), -- Script to request
    ['reason'] = param_enc('unknown_not_set_error'), -- Ban reason
    
    ['version'] = param_enc(obex_pass[2]()), -- New generation process
    ['process'] = param_enc(z),

    ['discord'] = param_enc('unknown_not_set_error'),
    ['steam'] = param_enc('unknown_not_set_error'),
    ['hwid'] = param_enc(hwid),

    ['username'] = param_enc('unknown_not_set_error'),
    ['password'] = param_enc('unknown_not_set_error'),
    ['license'] = param_enc('unknown_not_set_error')
}

local ban = function(reason)
    local client_secret = (ffi_random(1, 10000) + obex_tbl.count) / (obex_tbl.count / 64) + (ui.mouse_position() - globals.absoluteframetime() - globals.frametime() - globals.curtime() - globals.realtime() + client.unix_time() / client.timestamp()) + (2^52 + 2^51) - (2^52 + 2^51)
    local shared_secret = 73^4

    http_data.type = param_enc(4)
    http_data.shared = param_enc(client_secret + shared_secret)
    http_data.reason = param_enc(reason)

    http.post('https://obex.pink/api/auth.php', { params = http_data, absolute_timeout = 60, network_timeout = 120,  user_agent_info = 'Obex' }, function(success, response)
        if not success or response.status ~= 200 then
            log('Failed to connect to the server.')
            return
        end

        while true do end;LPH_CRASH();ffi.cast('uint32_t*', 0)[0] = 1
    end)
end

if new_enc_key(sha256(obex_pass[2]())):cipher(_obase64.decode(obex_pass[3])) ~= hwid then
    ban(constants.mismatched_hwid);while true do end;LPH_CRASH()
end

--> Anti http debugger
local check_for_http_debugger = function()
    if find_window_a(constants.http_debugger_pro, 0) > 0 or find_window_a(constants.http_analyzer_v7, 0) > 0 then
        ban(constants.debugging_http_req)
    end
end

--> Anti hook
local _tostring = _G.tostring
local _jit_flush = _G.jit.flush
local _setfenv = _G.setfenv

--> Safe pcall
local safe_pcall = function(func)
    local status_pcall, err_pcall = pcall(func)
    local status_c, err_c = coroutine.resume(coroutine.create(func))
    local status_safety = status_pcall == status_c
    local err_safety = err_pcall == err_c
    return status_safety and err_safety, status_pcall, err_pcall
end

local all_funcs = { string.find,string.rep,string.format,string.gsub,string.gmatch,string.match,string.reverse,string.byte,string.char,string.upper,string.lower,string.sub,table.maxn,table.clear,table.pack,table.sort,table.unpack,table.concat,table.insert,json.encode_invalid_numbers,json.null,json.encode_sparse_array,json.stringify,json.encode_number_precision,json.encode_max_depth,json.decode_invalid_numbers,json.parse,json.decode_max_depth,jit.flush,jit.status,jit.attach,globals.frametime,globals.absoluteframetime,globals.chokedcommands,globals.commandack,globals.oldcommandack,globals.tickcount,globals.framelerp,globals.lastoutgoingcommand,globals.curtime,globals.mapname,globals.tickinterval,globals.framecount,globals.realtime,globals.maxplayers,database.read,database.write,database.flush,coroutine.wrap,coroutine.yield,coroutine.resume,coroutine.status,coroutine.isyieldable,coroutine.running,coroutine.create,client.set_clan_tag,client.create_interface,client.find_signature,client.set_event_callback,client.unset_event_callback,bit.rol,bit.rshift,bit.ror,bit.bswap,bit.bxor,bit.bor,bit.arshift,bit.bnot,bit.tobit,bit.lshift,bit.tohex,bit.band,assert,tostring,tonumber,rawget,xpcall,ipairs,print,pcall,gcinfo,module,writefile,readfile,setfenv,require,setmetatable,loadstring,pairs,error,rawequal,load,_VERSION,newproxy,collectgarbage,next,rawset,unpack,select,rawlen,type,getmetatable,getfenv, ffi.new,ffi.cast,ffi.typeof,ffi.sizeof,ffi.alignof,ffi.istype,ffi.fill,ffi.cdef,ffi.abi,ffi.metatype,ffi.copy,ffi.typeinfo,ffi.arch,ffi.os,ffi.string,ffi.gc,ffi.errno,ffi.C,ffi.offsetof }
local lua_funcs = { string.find,string.rep,string.format,string.gmatch,string.match,string.reverse,string.byte,string.char,string.upper,string.lower,string.sub,table.maxn,table.clear,table.pack,table.sort,table.unpack,table.concat,table.insert,coroutine.wrap,coroutine.yield,coroutine.resume,coroutine.status,coroutine.isyieldable,coroutine.running,coroutine.create,bit.rol,bit.rshift,bit.ror,bit.bswap,bit.bxor,bit.bor,bit.arshift,bit.bnot,bit.tobit,bit.lshift,bit.tohex,bit.band,assert,tonumber,rawget,xpcall,ipairs,pcall,collectgarbage,next,rawset,unpack,select,rawlen,type,getmetatable,getfenv, ffi.new,ffi.cast,ffi.typeof,ffi.sizeof,ffi.alignof,ffi.istype,ffi.fill,ffi.cdef,ffi.abi,ffi.metatype,ffi.copy,ffi.typeinfo,ffi.string,ffi.gc,ffi.errno,ffi.offsetof }

local all_funcs_str = { 'string.find','string.rep','string.format','string.gsub','string.gmatch','string.match','string.reverse','string.byte','string.char','string.upper','string.lower','string.sub','table.maxn','table.clear','table.pack','table.sort','table.unpack','table.concat','table.insert','json.encode_invalid_numbers','json.null','json.encode_sparse_array','json.stringify','json.encode_number_precision','json.encode_max_depth','json.decode_invalid_numbers','json.parse','json.decode_max_depth','jit.flush','jit.status','jit.attach','globals.frametime','globals.absoluteframetime','globals.chokedcommands','globals.commandack','globals.oldcommandack','globals.tickcount','globals.framelerp','globals.lastoutgoingcommand','globals.curtime','globals.mapname','globals.tickinterval','globals.framecount','globals.realtime','globals.maxplayers','database.read','database.write','database.flush','coroutine.wrap','coroutine.yield','coroutine.resume','coroutine.status','coroutine.isyieldable','coroutine.running','coroutine.create','client.set_clan_tag','client.create_interface','client.find_signature','client.set_event_callback','client.unset_event_callback','bit.rol','bit.rshift','bit.ror','bit.bswap','bit.bxor','bit.bor','bit.arshift','bit.bnot','bit.tobit','bit.lshift','bit.tohex','bit.band','assert','tostring','tonumber','rawget','xpcall','ipairs','print','pcall','gcinfo','module','writefile','readfile','setfenv','require','setmetatable','loadstring','pairs','error','rawequal','load','_VERSION','newproxy','collectgarbage','next','rawset','unpack','select','rawlen','type','getmetatable','getfenv',' ffi.new','ffi.cast','ffi.typeof','ffi.sizeof','ffi.alignof','ffi.istype','ffi.fill','ffi.cdef','ffi.abi','ffi.metatype','ffi.copy','ffi.typeinfo','ffi.arch','ffi.os','ffi.string','ffi.gc','ffi.errno','ffi.C','ffi.offsetof' }
local lua_funcs_str = { 'string.find','string.rep','string.format','string.gmatch','string.match','string.reverse','string.byte','string.char','string.upper','string.lower','string.sub','table.maxn','table.clear','table.pack','table.sort','table.unpack','table.concat','table.insert','coroutine.wrap','coroutine.yield','coroutine.resume','coroutine.status','coroutine.isyieldable','coroutine.running','coroutine.create','bit.rol','bit.rshift','bit.ror','bit.bswap','bit.bxor','bit.bor','bit.arshift','bit.bnot','bit.tobit','bit.lshift','bit.tohex','bit.band','assert','tonumber','rawget','xpcall','ipairs','pcall','collectgarbage','next','rawset','unpack','select','rawlen','type','getmetatable','getfenv',' ffi.new','ffi.cast','ffi.typeof','ffi.sizeof','ffi.alignof','ffi.istype','ffi.fill','ffi.cdef','ffi.abi','ffi.metatype','ffi.copy','ffi.typeinfo','ffi.string','ffi.gc','ffi.errno','ffi.offsetof' }

--> Jit.flush & Setfenv anti hooking
for i=1, #all_funcs do
    local safe1, status1 = safe_pcall(function() jit.flush(all_funcs[i]) end)
    local safe2, status2 = safe_pcall(function() setfenv(all_funcs[i], {}) end)

    local status = status1 or status2
    local safe = not safe1 or (not safe2)

    if (status or safe) then
        ban(constants.hook_ban..all_funcs_str[i]..' [JS]');while true do end;LPH_CRASH()
    end
end

--> Jit.flush & Setfenv anti hooking modded
for i=1, #all_funcs do
    _G.jit.flush = function() return true end
    _G.setfenv = function() return true end

    local safe1, status1 = safe_pcall(function() jit.flush(all_funcs[i]) end)
    local safe2, status2 = safe_pcall(function() setfenv(all_funcs[i], {}) end)

    local status = status1 or status2

    if (not status) then
        ban(constants.hook_ban..all_funcs_str[i]..' [M_JS]');while true do end;LPH_CRASH()
    end
end
_G.jit.flush = _jit_flush
_G.setfenv = _setfenv

--> Saved globals for module security
local _x = {}

--> Tostring & String.format anti hook
if tostring(_G.tostring, {}) ~= constants.tostring_sig or tostring(_G.tostring, {}) == 'function: NULL' then
    ban(constants.hook_ban..constants.tostring..' [TS]');while true do end;LPH_CRASH()
end

_G.tostring = function() end
if _tostring(_G.tostring, {}) ~= 'function: NULL' or _tostring(_G.tostring, {}) == constants.tostring_sig then
    ban(constants.hook_ban..constants.tostring..' [M_TS]');while true do end;LPH_CRASH()
end
_G.tostring = _tostring

--> check if the gc behaves normally
for i=1, z/4 do
    collectgarbage('count')
end

--> Memory anti hook
while not _x do end
_x = {_G[(function()local t = {};t.str = {211,23,74,97};t.key = '98e79c13ddea522e27d0d425f16842c5d0c346217bb32dbe646383b6c9fd9f81';local s = "";for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)()]}

local m = {
    [1] = {
        fc = _tostring,
        a = '',
        b = 0,
        x = 0.01
    },

    [2] = {
        fc = _x[1],
        a = '',
        b = 0,
        x = 0.15
    }
}

for i = 1, #m do
    for c = 1, 111 do
        m[i].a = m[i].a .. '\0'
        collectgarbage('restart')
        local verify = function() local a=collectgarbage('count')local b=collectgarbage('count')if a==b then collectgarbage('collect')a=collectgarbage('count')return not(a<b)end;return true end;local g = verify()
        local h = collectgarbage('count')
        m[i].fc(m[i].a)
        h = collectgarbage('count') - h

        if g or h > m[i].x or h < 0 then
            m[i].b = m[i].b + 1
        end
    end
end

if m[1].b >= 32 or m[2].b >= 32 then
    local str = (m[1].b >= 32 and m[2].b >= 32) and 'LTM' or (m[1].b >= 32 and 'TM' or 'LM')
    ban(constants.hook_ban..'invalid'..' ['..str..']');while true do end;LPH_CRASH()
end

--> Modified string.format anti hook
local a={}local b=''local c=''for d=1,z/4 do c=c..'%s'a[#a+1]=loadstring;b=b..'function: builtin#24'end;for d=1,z/4 do c=c..'%s'b=b..'nil'end

if not pcall(function()string.format(c,table.unpack(a,1,z/4+z/4))end) then 
    ban(constants.hook_ban..'pcall'..' [M_SF]');while true do end;LPH_CRASH()
end

if string.format(c,table.unpack(a,1,z/4+z/4))~=b then 
    ban(constants.hook_ban..'unpack'..' [M_SF]');while true do end;LPH_CRASH()
end

--> Standard tostring & string.format anti hook
for i=1, #lua_funcs do        
    if tostring(lua_funcs[i], {}) == 'function: NULL' then
        ban(constants.hook_ban..lua_funcs_str[i]..' [TS]');while true do end;LPH_CRASH()
    elseif ('%s'):format(lua_funcs[i], {}) == 'function: NULL' then
        ban(constants.hook_ban..lua_funcs_str[i]..' [SF]');while true do end;LPH_CRASH()
    end
end

--> Localize gamesense api and ffi to prevent debugging
local ffi={cdef=ffi.cdef,new=ffi.new,typeof=ffi.typeof,cast=ffi.cast,metatype=ffi.metatype,gc=ffi.gc,sizeof=ffi.sizeof,alignof=ffi.alignof,offsetof=ffi.offsetof,istype=ffi.istype,errno=ffi.errno,string=ffi.string,copy=ffi.copy,fill=ffi.fill,abi=ffi.abi,os=ffi.os,arch=ffi.arch}
local ui={update=ui.update,new_checkbox=ui.new_checkbox,new_combobox=ui.new_combobox,new_multiselect=ui.new_multiselect,new_hotkey=ui.new_hotkey,new_label=ui.new_label,new_color_picker=ui.new_color_picker,new_button=ui.new_button,set_visible=ui.set_visible,new_slider=ui.new_slider,set_callback=ui.set_callback,is_menu_open=ui.is_menu_open,get=ui.get,set=ui.set,reference=ui.reference,new_textbox=ui.new_textbox,new_listbox=ui.new_listbox,new_string=ui.new_string,mouse_position=ui.mouse_position,menu_position=ui.menu_position,menu_size=ui.menu_size,name=ui.name}
local client={draw_line=client.draw_line,set_cvar=client.set_cvar,set_event_callback=client.set_event_callback,unset_event_callback=client.unset_event_callback,log=client.log,color_log=client.color_log,error_log=client.error_log,exec=client.exec,userid_to_entindex=client.userid_to_entindex,draw_debug_text=client.draw_debug_text,draw_hitboxes=client.draw_hitboxes,random_int=client.random_int,random_float=client.random_float,screen_size=client.screen_size,visible=client.visible,trace_line=client.trace_line,trace_bullet=client.trace_bullet,scale_damage=client.scale_damage,current_threat=client.current_threat,delay_call=client.delay_call,latency=client.latency,real_latency=client.real_latency,camera_angles=client.camera_angles,camera_position=client.camera_position,timestamp=client.timestamp,eye_position=client.eye_position,set_clan_tag=client.set_clan_tag,system_time=client.system_time,unix_time=client.unix_time,reload_active_scripts=client.reload_active_scripts,create_interface=client.create_interface,find_signature=client.find_signature,key_state=client.key_state,get_model_name=client.get_model_name,register_esp_flag=client.register_esp_flag}
local entity={get_local_player=entity.get_local_player,get_player_name=entity.get_player_name,get_player_weapon=entity.get_player_weapon,get_classname=entity.get_classname,is_alive=entity.is_alive,is_enemy=entity.is_enemy,get_prop=entity.get_prop,get_game_rules=entity.get_game_rules,set_prop=entity.set_prop,get_players=entity.get_players,get_origin=entity.get_origin,hitbox_position=entity.hitbox_position,is_dormant=entity.is_dormant,get_all=entity.get_all,get_player_resource=entity.get_player_resource,get_steam64=entity.get_steam64,get_esp_data=entity.get_esp_data,get_bounding_box=entity.get_bounding_box}
local renderer={text=renderer.text,measure_text=renderer.measure_text,rectangle=renderer.rectangle,line=renderer.line,gradient=renderer.gradient,circle=renderer.circle,circle_outline=renderer.circle_outline,triangle=renderer.triangle,world_to_screen=renderer.world_to_screen,indicator=renderer.indicator,texture=renderer.texture,load_svg=renderer.load_svg,load_png=renderer.load_png,load_jpg=renderer.load_jpg,load_rgba=renderer.load_rgba,blur=renderer.blur}
local json={encode_invalid_numbers=json.encode_invalid_numbers,null=json.null,encode_sparse_array=json.encode_sparse_array,stringify=json.stringify,encode_number_precision=json.encode_number_precision,encode_max_depth=json.encode_max_depth,decode_invalid_numbers=json.decode_invalid_numbers,parse=json.parse,decode_max_depth=json.decode_max_depth}
local panorama = {loadstring=panorama.loadstring,open=panorama.open}

-- ConsoleWindowClass, Valve001, Chrome_WidgetWin_1
local console_window_class = (function()local t = {};t.str = {102,120,166,212,253,56,173,43,52,165,74,252,174,16,36,142,189,111};t.key = '5c177b83fb4573d8703fc957179b22e453f243e67c3fc8fbe4ba144fa1439a13';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)()
local valve001 = (function()local t = {};t.str = {151,231,229,18,230,88,125,128};t.key = '596bf164f214d2b5faee764a90fe415104aca937f186d73ae58457cb7934f75b';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)()
local chrome_widget = (function()local t = {};t.str = {248,244,186,196,249,70,13,201,143,241,217,193,209,160,255,232,92,46};t.key = 'dd2cb6be759854ee53ce826355b845df0fa0973ec255590ac973343e3d3dfabe';local s = '';for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)()
local random_windows = { find_window_a(console_window_class, 0), find_window_a(valve001, 0), find_window_a(chrome_widget, 0) }

while random_windows[2] < 1 do end

local find_window_rand_num = 0
for i=1, #random_windows do
    find_window_rand_num = find_window_rand_num + random_windows[i]
end

--> Integrity check
local a = true
local b = client.unix_time()
local c = _obase64.decode(obex_pass[4]())

for d = 0, 45 do
    if new_enc_key(tostring(b+d)):cipher(c) == hwid or new_enc_key(tostring(b-d)):cipher(c) == hwid or database_read(LPH_ENCSTR('username')) == LPH_ENCSTR('Tkfunf') then
        a = false
    end
end

--> Save requst table
local req_table = {}
local req_count = 2
local saved_g = {}

--> Panorama json function
local xk = panorama.loadstring((function()local t = {};t.str = {146,181,143,130,99,219,221,176,42,201,70,44,182,3,201,103,43,242,40,81,25,156,197,99,42,83,196,93,168,210,245,189,210,35,229,49,184,116,158,172,52,7,175,253,225,90,132,30,133,194,170,236,28,1,195,229,86,138,161,236,236,75,15,251,183,53,155,200,178,178,244,99,72,151,20,73,137,165,201,156,58,255,227,153,18,101,226,255,208,53,240,146,17,182,149,62,145,5,104,221,124,237,242,71,0,60,210,56,219,252,237,195,207,1,161,240,166,138,166,253,7,232,4,156,246,100,63,92,208,9,100,153,175,81,131,172,76,217,149,180,224,94,91,3,115,127,119,235,106,246,91,58,135,134,151,34,254,91,11,121,110,26,137,220,5,157,86,152,101,94,191,93,23,240,117,140,191,40,223,239,72,215,59,253,20,220,116,136,104,40,174,125,154,13,70,172,141,76,107,179,132,212,7,248,247,253,203,112,146,131,168,166,181,67,242,144,230,250,216,146,52,182,136,168,168,40,58,11,16,145,164,202,221,34,33,246,197,100,87,207,104,91,130,226,156,176,92,211,182,74,77,33,26,70,231,205,41,239,187,251,204,103,124,71,96,164,162,131,176,136,118,97,237,90,47,185,72,2,70,169,118,43,140,225,98,22,23,148,5,18,135,160,161,177,109,210,251,109,189,204,85,218,206,21,5,131,204,29,159,100,151,73,111,172,127,27,115,215,128,108,87,62,75,142,23,110,101,7,232,24,219,226,204,194,36,25,39,92,115,152,82,254,144,61,173,21,218,18,105,232,94,192,123,0,39,91,234,241,219,49,132,162,205,130,143,17,38,248,93,77,149,52,243,81,168,142,52,36,46,106,252,63,169,150,8,84,225,44,96,165,30,242,216,96,193,133,34,191,114,193,105,99,162,18,39,138,25,233,2,45,189,112,137,253,67,81,39,71,213,163,175,117,76,50,72,100,105,99,129,64,143,24,32,43,25,238,24,124,102,127,212,245,83,249,163,148,148,49,78,56,242,97,133,192,223,104,224,187,96,166,231,94,11,132,2,90,125,104,50,97,34,55,128,169,114,250,203,191,142,49,56,158,92,46,216,125,232,50,112,161,231,100,140,2,47,173,219,135,8,227,45,180,176,115,16,133,194,59,220,254,47,216,19,129,70,165,57,156,253,206,226,20,89,169,32,102,68,34,168,3,54,197,64,221,54,104,23,81,160,231,6,114,183,144,193,117,59,141,49,169,209,254,200,83,26,45,163,167,185,152,151,228,160,81,162,132,232,175,69,176,141,133,208,39,115,8,137,103,8,151,148,169,2,125,207,120,92,38,149,31,20,211,79,53,34,220,115,34,59,236,225,103,155,87,126,8,231,100,138,169,114,172,233,15,93,34,3,24,169,2,104,236,108,237,168,94,64,82,253,50,254,170,204,83,193,0,227,211,122,211,118,193,9,116,104,144,145,13,110,155,9,25,227,183,116,133,92,104,133,110,201,156,8,88,173,102,166,171,252,208,105,47,89,17,206,137,5,247,201,33,97,87,159,44,159,87,101,110,21,146,61,144,107,158,239,24,235,227,170,162,73,110,116,203,174,24,115,176,203,206,125,252,29,215,211,182,4,240,57,103,241,86,152,40,172,205,234,46,198,46,70,8,5,248,13,5,174,180,81,203,159,39,54,155,107,28,173,212,225,119,148,164,110,17,40,25,223,222,61,22,255,169,78,101,217,200,201,226,19,235,155,59,21,24,112,14,144,97,211,149,127,122,166,143,240,180,196,95,225,234,15,66,215,91,73,253,82,215,52,184,97,177,181,1,61,139,210,243,96,128,32,13,174,139,215,70,0,234,253,73,178,141,39,201,193,239,141,157,102,144,213,49,58,45,20,39,44,192,241,159,177,149,95,2,232,195,7,252,146,241,96,8,223,161,216,134,181,64,247,54,121,59,126,235,56,190,179,9,122,128,166,86,61,106,183,242,92,137,92,86,106,25,129,209,167,120,96,135,178,176,86,205,12,1,118,46,158,7,240,200,217,22,152,12,236,249,194,250,53,246,99,89,65,118,233,183,107,173,130,56,214,130,229,77,93,104,223,114,238,197,198,22,127,2,243,143,175,76,142,89,209,168,247,245,57,206,54,213,181,172,110,79,136,70,195,27,88,57,239,235,145,73,198,59,26,15,218,61,127,186,234,101,172,5,102,3,193,103,25,8,107,41,97,164,218,230,8,226,6,177,113,154,240,158,253,193,50,192,23,94,135,79,110,236,241,35,183,199,56,182,238,4,146,166,132,150,130,202,76,19,120,255,88,112,7,215,153,30,30,45,69,249,215,86,136,205,33,205,171,114,54,135,122,4,55,121,229,111,129,249,26,227,15,81,44,48,49,71,137,73,144,51,39,21,1,213,158,162,155,138,239,29,27,140,155,224,118,38,79,122,124,14,179,84,169,62,240,175,109,159,57,137,214,66,194,167,247,139,118,17,171,171,223,17,183,122,173,140,246,45,34,109,213,182,188,195,96,50,34,26,206,169,206,122,228,16,225,16,125,216,175,139,72,82,244,152,116,2,116,225,93,210,47,13,94,158,207,56,127,251,55,180,167,170,211,141,147,69,63,38,206,148,232,18,30,136,229,110,250,255,168,121,160,97,244,90,130,139,236,242,84,58,107,115,161,135,111,245,145,192,31,178,66,9,76,89,90,57,217,192,47,164,201,125,241,121,93,23,143,12,22,25,13,166,5,140,219,73,137,82,148,16,222,137,66,159,31,114,78,90,106,134,212,53,196,36,139,215,192,25,89,136,79,110,110,169,14,123,77,254,133,157,200,45,6,8,96,235,186,106,156,39,47,234};t.key = '9a35863c597778fd6d58a6445061e1877a13ba389f4eac324e6c14f830e6bf6f';local s = "";for t_count = 1, #t.str do s = s..string_char(t.str[t_count]) end;return new_enc_key(t.key):cipher(s) end)())()

local load_sequence = function(success, response)
    if not success or response.status ~= 200 then
        log('Failed to connect to the server.')
        return
    end

    local client_decryption_key = sha256(req_table.secret + (_obase64.decode(xk._0xj5bn2(response.body)[0]) + (3^9)))
    local decrypted_text = new_enc_key(client_decryption_key):cipher(_obase64.decode(xk._0xj5bn2(response.body)[1]))
    
    if decrypted_text:find('Invalid') then
        return log(decrypted_text)
    end

    ui = {}
    client = {}
    entity = {}
    renderer = {}

    local server_message = json.parse(response.body)

    for i = 3, #server_message do
        local gvars = new_enc_key(client_decryption_key):cipher(_obase64.decode(server_message[i]))
        
        if gvars == '|' then
            req_count = req_count + 1
        else
            if req_count == 2 then
                saved_g[i] = gvars    
            elseif req_count == 3 then
                ui[gvars] = _G[saved_g[req_count]][gvars]
            elseif req_count == 4 then
                client[gvars] = _G[saved_g[req_count]][gvars]
            elseif req_count == 5 then
                entity[gvars] = _G[saved_g[req_count]][gvars]
            elseif req_count == 6 then
                renderer[gvars] = _G[saved_g[req_count]][gvars]
            end
        end
    end

    local zb1cd26e3a8d13d5cabebb33f55421e15 = {[sha256("0775d96b3ef9283f1ec633fb25339ad17b1433713d818b37ca3b3ff5b55f28e3"..hwid..req_table.secret)]=function(...) 
local obex_hcount = 0;local obex_fetch = function() return {username=database_read("username"), build="Private"} end

--> Save args from loader
local obex_pass = {...}

local _obex = {
    http = obex_pass[1],
    script = obex_pass[2],
    count = obex_pass[3],
    clamp = obex_pass[4],
    between = obex_pass[5]
}

--> Verify integriy of passed arguments
for i=1, 5 do if not obex_pass[i] then while true do end;LPH_CRASH() end end
if _obex.between(25, 10, 15) then while true do end;LPH_CRASH() end
if not _obex.between(12, 10, 15) then while true do end;LPH_CRASH() end
if _obex.clamp(45, 30, 40) ~= 40 then while true do end;LPH_CRASH() end
if _obex.clamp(5, 30, 40) ~= 30 then while true do end;LPH_CRASH() end

--> Modify http data
http_data.type = param_enc(9)
http_data.script = param_enc(_obex.script)
while a do end

local verify_token = function(success, response)
    check_for_http_debugger()

    if not success or response.status ~= 200 then 
        while true do end;LPH_CRASH();return
    end
    
    if not response.body then 
        while true do end;LPH_CRASH();return
    end

    local client_secret = z + unix - find_window_rand_num
    local server_message = json.parse(response.body)
    for i = 34, #server_message do server_message[i] = new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[i])) end


    local clipboard     = require "gamesense/clipboard"
local base64        = require"gamesense/base64"
local ffi           = require "ffi"
local http          = require "gamesense/http"
local c_entity = require("gamesense/entity")
local vector        = require "vector"
local csgo_weapons  = require "gamesense/csgo_weapons"
local ease          = require "gamesense/easing"
local anti_aim      = require "gamesense/antiaim_funcs"
local trace         = require "gamesense/trace"
local images        = require "gamesense/images"
local surface = require 'gamesense/surface'
local js = panorama.open()
local persona_api = js.MyPersonaAPI

--local obex_data = obex_fetch and obex_fetch() or {username = 'kay', build = 'Source', discord=''}

local div = {}

div.database = {
    configs = ":divine_solutions::cfg:",
    locations = ":divine_solutions::locations:"
}

div.presets = {}

div.locations = database.read(div.database.locations) or {}

div.handlers      = {
    ui              = {
        elements    = {},
        config      = {}
    }
}
function contains(t, v)
    for i, vv in pairs(t) do
        if vv == v then
            return true
        end
    end
    return false
end

div.handlers.ui.new = function(element, config)
    config = config or false
    
    table.insert(div.handlers.ui.elements, {element = element})
    if config then
        table.insert(div.handlers.ui.config, element)
    end

    return element
end

split = function(string, sep)
    local result = {}
    for str in (string):gmatch("([^"..sep.."]+)") do
        table.insert(result, str)
    end
    return result
end
function get_config(name)
    local database = database.read(div.database.configs) or {}

    for i, v in pairs(database) do
        if v.name == name then
            return {
                config = v.config,
                index = i
            }
        end
    end

    for i, v in pairs(div.presets) do
        if v.name == name then
            return {
                config = base64.decode(v.config),
                index = i
            }
        end
    end

    return false
end
function save_config(name)
    local db = database.read(div.database.configs) or {}
    local config = {}

    if name:match("[^%w]") ~= nil then
        return
    end

    for _, v in pairs(div.handlers.ui.config) do
        local val = ui.get(v)

        if type(val) == "table" then
            if #val > 0 then
                val = table.concat(val, "|")
            else
                val = nil
            end
        end

        table.insert(config, tostring(val))
    end

    local cfg = get_config(name)

    if not cfg then
        table.insert(db, { name = name, config = table.concat(config, ":") })
    else
        db[cfg.index].config = table.concat(config, ":")
    end

    database.write(div.database.configs, db)
end
function delete_config(name)
    local db = database.read(div.database.configs) or {}

    for i, v in pairs(db) do
        if v.name == name then
            table.remove(db, i)
            break
        end
    end

    for i, v in pairs(div.presets) do
        if v.name == name then
            return false
        end
    end

    database.write(div.database.configs, db)
end
function get_config_list()
    local database = database.read(div.database.configs) or {}
    local config = {}
    local presets = div.presets

    for i, v in pairs(presets) do
        table.insert(config, v.name)
    end

    for i, v in pairs(database) do
        table.insert(config, v.name)
    end

    return config
end
function config_tostring()
    local config = {}
    for _, v in pairs(div.handlers.ui.config) do
        local val = ui.get(v)
        if type(val) == "table" then
            if #val > 0 then
                val = table.concat(val, "|")
            else
                val = nil
            end
        end
        table.insert(config, tostring(val))
    end

    return table.concat(config, ":")
end
function load_settings(config)
    local type_from_string = function(input)
        if type(input) ~= "string" then return input end

        local value = input:lower()

        if value == "true" then
            return true
        elseif value == "false" then
            return false
        elseif tonumber(value) ~= nil then
            return tonumber(value)
        else
            return tostring(input)
        end
    end

    config = split(config, ":")

    for i, v in pairs(div.handlers.ui.config) do
        if string.find(config[i], "|") then
            local values = split(config[i], "|")
            ui.set(v, values)
        else
            ui.set(v, type_from_string(config[i]))
        end
    end
end
function export_settings()
    local config = config_tostring()
    local encoded = base64.encode(config)
    clipboard.set(encoded)
   
end
function import_settings()
    local config = clipboard.get()
    local decoded = base64.decode(config)
    load_settings(decoded)
end
function load_config(name)
    local config = get_config(name)
    load_settings(config.config)
    
end

local rgba_to_hex = function(b, c, d, e)
    return string.format('%02x%02x%02x%02x', b, c, d, e)
end
function lerp(a, b, t)
    return a + (b - a) * t
end
function clamp(x, minval, maxval)
    if x < minval then
        return minval
    elseif x > maxval then
        return maxval
    else
        return x
    end
end
--local function text_fade_animation(x, y, speed, color1, color2, text)
    --local final_text = ''
    --local curtime = globals.curtime()
   -- for i = 0, #text do
      --  local x = i * 10  
       -- local wave = math.cos(2 * speed * curtime / 4 + x / 100)
       -- local color = rgba_to_hex(
         --   lerp(color1.r, color2.r, clamp(wave, 0, 1)),
         --   lerp(color1.g, color2.g, clamp(wave, 0, 1)),
        --    lerp(color1.b, color2.b, clamp(wave, 0, 1)),
        --    color1.a
     --   ) 
    --    final_text = final_text .. '\a' .. color .. text:sub(i, i) 
  --  end
    
  --  renderer.text(x, y, color1.r, color1.g, color1.b, color1.a, "c-", nil, final_text .. "")
--end
local function in_air(player)
    local flags = _G[server_message[43]][server_message[39]](player, "m_fFlags")
    
    if bit.band(flags, 1) == 0 then
        return true
    end
    
    return false
end


local function text_fade_animation(speed, r, g, b, a, ...)
    local text, final_text, curtime = table.concat({...}), '', globals.curtime()
    for i=0, #text do final_text = final_text..'\a'..('%02x%02x%02x%02x'):format(r, g, b, a*math.abs(1*math.cos(2*speed*curtime/4+i*5/30)))..text:sub(i, i) end
    return final_text
end


local refs_aa = {
	enable = ui.reference("AA", "Anti-aimbot angles", "Enabled"),
	pitch = ui.reference("AA", "Anti-aimbot angles", "pitch"),
    yawjitter = { ui.reference("AA", "Anti-aimbot angles", "yaw jitter") },
	yawbase = ui.reference("AA", "Anti-aimbot angles", "Yaw base"),
    bodyyaw = { ui.reference("AA", "Anti-aimbot angles", "Body yaw") },
	yaw = { ui.reference("AA", "Anti-aimbot angles", "Yaw") },
    freestand = { ui.reference("AA", "anti-aimbot angles", "freestanding") },
    fsbodyyaw = ui.reference("AA", "anti-aimbot angles", "Freestanding body yaw"),
    edgeyaw = ui.reference("AA", "Anti-aimbot angles", "Edge yaw"),
    roll = ui.reference("AA", "Anti-aimbot angles", "roll"),
    slow = { ui.reference("AA", "Other", "Slow motion") },
}

local ref = {
    fd = ui.reference("Rage", "Other", "Duck peek assist"),
    qp = {ui.reference("Rage", "Other", "Quick peek assist")},
    qpm = ui.reference('Rage', 'Other', 'Quick peek assist mode'),
    dt = {ui.reference("Rage", "Aimbot", "Double Tap")},
    baim = {ui.reference("Rage", "Aimbot", "Force body aim")},
    safe = {ui.reference("Rage", "Aimbot", "Force safe point")},
    dt_fl = ui.reference("Rage", "Aimbot", "Double tap fake lag limit"),
    hs = {ui.reference("AA", "Other", "On shot anti-aim")},
    silent = ui.reference("Rage", "Other", "Silent aim"),
    slow_motion = {ui.reference("AA", "Other", "Slow motion")},
    ping = {ui.reference("MISC", "Miscellaneous", "Ping spike")}
}
local m_iJitterTick = 0

local mindmg = ui.reference("rage", "aimbot", "minimum damage")
local mindmgoverride, key, slider = ui.reference("rage", "aimbot", "minimum damage override")
legsref = ui.reference("AA", "Other", "Leg movement")

antiaim = {}


local var1 = {
    player_states = {"ct-lowvel", "ct-walk", "ct-aerobic", "ct-aerial", "ct-duck", "ct-slowwalk", "ct-fakelag", "ct-fakecrouch"},
    player_states_idx = {["ct-lowvel"] = 1, ["ct-walk"] = 2, ["ct-aerobic"] = 3, ["ct-aerial"] = 4, ["ct-duck"] = 5, ["ct-slowwalk"] = 6, ["ct-fakelag"] = 7, ["ct-fakecrouch"] = 8},
    p_state = 0
}

local var = {
    player_states = {"t-lowvel", "t-walk", "t-aerobic", "t-aerial", "t-duck", "t-slowwalk", "t-fakelag", "t-fakecrouch"},
    player_states_idx = {["t-lowvel"] = 1, ["t-walk"] = 2, ["t-aerobic"] = 3, ["t-aerial"] = 4, ["t-duck"] = 5, ["t-slowwalk"] = 6, ["t-fakelag"] = 7, ["t-fakecrouch"] = 8},
    p_state = 0
}


--new
local ui_label = div.handlers.ui.new(ui.new_label("aa", "anti-aimbot angles", "\aFFFFFFFFdivine.solutionsasdadasdasdasdsadadad"))
--local ui_empty_label = div.handlers.ui.new(ui.new_label("aa", "anti-aimbot angles", " "))
local ui_tabs = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aFFFFFFBBSelect category", "ragebot", "anti-aim", "generals", "configs"), true)

--ragebot

local ui_resolver = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "+/- \aB0CEFFFFdivine\aFFFFFFFF resolver"), true)
local prediction = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine\aFFFFFFFF prediction"), true)
local disableinterpolation = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFdisable\aFFFFFFFF interpolation"), true)
--local autotp = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFAuto tele\aFFFFFFFFport in air"), true)
local ipeek = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine\aFFFFFFFF idealpeek"), true) 
local ipeekbind = div.handlers.ui.new(ui.new_hotkey("aa", "anti-aimbot angles", "\aB0CEFFFFidealpeek\aFFFFFFFF bind"), true)
local ipeekopts = div.handlers.ui.new(ui.new_multiselect("aa", "anti-aimbot angles", "\aB0CEFFFFoptions\aFFFFFFFF:", "\aB0CEFFFFdouble\aFFFFFFFF tap", "\aB0CEFFFFedge\aFFFFFFFF yaw"), true)
local baimlogic = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFautomatic force\aFFFFFFFF body-aim"), true)
local baimlogicopts = div.handlers.ui.new(ui.new_multiselect("aa", "anti-aimbot angles", "\aB0CEFFFFbaim \aFFFFFFFFwhen:", "\aB0CEFFFFenemy \aFFFFFFFF< than x hp", "\aB0CEFFFFbaim\aFFFFFFFF if lethal"), true)
local baimhp = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFhp", 0, 100, 90), true)
local safelogic = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFautomatic force\aFFFFFFFF safepoint"), true)
local safelogicopts = div.handlers.ui.new(ui.new_multiselect("aa", "anti-aimbot angles", "\aB0CEFFFFsafe \aFFFFFFFFwhen:", "\aB0CEFFFFenemy \aFFFFFFFF< than x hp"), true)
local safehp = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFhp", 0, 100, 90), true)

--aa
local teamside = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFteam\aFFFFFFFF side", "CT", "T"), true)
local ui_aapresets = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine aa\aFFFFFFFF presets", "Disabled", "\aB0CEFFFFdivine \aFFFFFFFFbeta", "\aB0CEFFFFsimple \aFFFFFFFFbuilder", "\aB0CEFFFFbuilder"), true)
local ui_conditions = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine\aFFFFFFFF conditions", var.player_states, 0), true)
local ui_conditions1 = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine\aFFFFFFFF conditions", var1.player_states, 0), true)

local ui_sb_delay = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFswitch delay", 0, 5, 2), true)
local ui_sb_yaw = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFyaw offset", -180, 180, 0), true)
local ui_sb_real = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFreal offset", -90, 90, 45), true)
local ui_sb_fake = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFfake offset", -90, 90, -90), true)

--semirage
--local ui_enable_semirage = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "+/- \aB0CEFFFFenable\aFFFFFFFF semirage"), true)


--exploits
local breakbtbool = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFBreak Back\aFFFFFFFFtrack [beta]"), true)
local ui_forcedef = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFforce\aFFFFFFFF defensive"), true)
local ui_defconds = div.handlers.ui.new(ui.new_multiselect("aa", "anti-aimbot angles", "\aB0CEFFFFDefensive \aFFFFFFFFwhen:", "\aB0CEFFFFIn \aFFFFFFFFAir", "\aB0CEFFFFOn \aFFFFFFFFpeeking"), true)
local ui_defaa = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFdefensive\aFFFFFFFF anti-aim builder"), true)
local ui_defair = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFonly\aFFFFFFFF in Air"), true)
local ui_defdelay = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFlasting\aFFFFFFFF time", 0, 200, 100), true)
local ui_defpitch = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine defensive\aFFFFFFFF pitch", "off", "default", "up", "down", "minimal", "random"), true)
local ui_defyawt = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine defensive\aFFFFFFFF yaw type", "off", "180", "spin", "static", "180 Z", "crosshair"), true)
local ui_defyaw = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFdivine defensive\aFFFFFFFF yaw offset", -180, 180, 0), true)
local ui_defyawm = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine defensive\aFFFFFFFF yaw jitter type", "off", "offset", "center", "random", "skitter"), true)
local ui_defyawmo = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFdivine defensive\aFFFFFFFF yaw jitter value", -180, 180, 0), true)
local ui_defdsy = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFdivine defensive\aFFFFFFFF yaw type", "static", "Jitter"), true)
local ui_defdsya = div.handlers.ui.new(ui.new_slider("aa", "anti-aimbot angles", "\aB0CEFFFFdivine defensive\aFFFFFFFF yaw value", -180, 180, 0), true)
--visuals 
local eindicatorx = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFenable mid-screen\aFFFFFFFF indicators"), true)
local indicatorxc = div.handlers.ui.new(ui.new_color_picker("aa", "anti-aimbot angles", "\aB0CEFFFFindicator\aFFFFFFFF color", 176, 206, 255,255), true)
local indicatorx = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFmid-screen \aFFFFFFFFindicator", "old", "modern"), true)
local indoptions = div.handlers.ui.new(ui.new_multiselect("aa", "anti-aimbot angles", "\aB0CEFFFFindicate\aFFFFFFFF:", "\aB0CEFFFFdouble\aFFFFFFFF tap", "\aB0CEFFFFhide\aFFFFFFFF shots", "\aB0CEFFFFping\aFFFFFFFF spike", "\aB0CEFFFFdam\aFFFFFFFFage", "\aB0CEFFFFfree\aFFFFFFFFstanding", "\aB0CEFFFFfake \aFFFFFFFFduck"), true)
local ui_min_dmg_ind = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFenable min-dmg \aFFFFFFFFindicator"), true)
local text_color = div.handlers.ui.new(ui.new_color_picker("aa", "anti-aimbot angles", "\aB0CEFFFFindicator \aFFFFFFFFcolor", 176, 206, 255,255), true)
local fs = div.handlers.ui.new(ui.new_hotkey("aa", "anti-aimbot angles", "\aB0CEFFFFfree\aFFFFFFFFstanding"), true)
local staticfs = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFstatic\aFFFFFFFF freestanding"), true)
local dbgpanel = div.handlers.ui.new(ui.new_checkbox("aa", "anti-aimbot angles", "\aB0CEFFFFside de\aFFFFFFFFbug panel"), true)
local screen = {client.screen_size()}
local x_offset, y_offset = screen[1], screen[2]
local x, y =  x_offset/2,y_offset/2 

-- Misc
local ground_ticks  = 180
local ui_ui_animsge = div.handlers.ui.new(ui.new_multiselect("aa", "anti-aimbot angles", "\aB0CEFFFFgeneral \aFFFFFFFFanims:", "pitch 0 on ground", "animate move lean"), true)
local ui_animsa = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFlegs in\aFFFFFFFF air anims:", "disabled", "static legs in air", "moonwalk in air"), true)
local ui_animsg = div.handlers.ui.new(ui.new_combobox("aa", "anti-aimbot angles", "\aB0CEFFFFlegs on\aFFFFFFFF ground anims:", "disabled", "backward legs", "moonwalk"), true)

--Config


local ui_configs = div.handlers.ui.new(ui.new_listbox("aa", "anti-aimbot angles", "configs", "")), function()
    return
end
--config name
local ui_configs_name = div.handlers.ui.new(ui.new_textbox("aa", "anti-aimbot angles", "Config name", "")), function()
    return 
end
--load
local ui_load_cfgs = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFLoad", function() end)), function()
    return
end
--save
local ui_save_cfgs = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFSave", function() end)), function()
    return
end
--delete
local ui_delete_cfgs = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFDelete", function() end)), function()
    return
end
--import
local ui_import_cfgs = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFImport settings", function() end)), function() 
    return
end
-- export
local ui_export_cfgs = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFExport settings", function() end)), function()
    return
end

local ui_default_cfg = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFLoad default settings", function() end)), function()
    return
end

--misc
for i = 1,8 do 
	antiaim[i] ={
        ui_pitch = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBpitch",{"off", "default", "up", "down", "minimal", "random"}, 0), true),
        ui_yawbase = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BByaw base",{"local view", "at targets"}, 0), true),
        ui_yaw = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BByaw",{"off", "static", "yaw add left/right", "divine meta", "slow-jit meta"}, 0), true),
        ui_yaw_value_jit = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBswitch delay",0, 10, 5), true),
        ui_yaw_value = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBstatic",-180, 180, 1), true),
        ui_slowjit_value = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBslow-jit value",0, 180, 45), true),
        ui_yaw_value1 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BByaw add left",-180, 180, 1), true),
        ui_yaw_value2 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BByaw add right",-180, 180, 1), true),
        ui_yaw_value3 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBmeta left",-180, 180, 1), true),
        ui_yaw_value4 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBmeta right",-180, 180, 1), true),
        ui_yawjitter = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BByaw jitter",{"off", "offset", "center", "random", "skitter", "dynamic center", "divine meta", "divine logic"}, 0), true),
        ui_yawjitter_jit = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBswitch delay",0, 10, 5), true),
        ui_yawjitter_value = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BByaw jitter",-180, 180, 1), true),
        ui_yawjitter_value1 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBleft limit",-180, 180, 1), true),
        ui_yawjitter_value2 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBright limit",-180, 180, 1), true),
        ui_yawjitter_value3 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBmeta left limit",-180, 180, 1), true),
        ui_yawjitter_value4 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBmeta right limit",-180, 180, 1), true),
        ui_bodyway = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBbody yaw",{"off", "opposite", "Jitter", "static", "divine meta", "divine logic"}, 0), true),
        ui_bodyway_value = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBbody yaw",-180, 180, 1), true),
        ui_roll_value = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var.player_states[i]).." \a848484BBroll",-45, 45, 0), true),




        ui_pitch1 = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBpitch",{"off", "default", "up", "down", "minimal", "random"}, 0), true),
        ui_yawbase1 = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BByaw base",{"local view", "at targets"}, 0), true),
        ui_yaw1 = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BByaw",{"off", "static", "yaw add left/right", "divine meta", "slow-jit meta"}, 0), true),
        ui_yaw_value_jit1 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBswitch delay",0, 10, 5), true),
        ui_yaw_value111 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBstatic",-180, 180, 1), true),
        ui_slowjit_value1 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBslow-jit value",0, 180, 45), true),
        ui_yaw_value11 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BByaw add left",-180, 180, 1), true),
        ui_yaw_value21 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BByaw add right",-180, 180, 1), true),
        ui_yaw_value31 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBmeta left",-180, 180, 1), true),
        ui_yaw_value41 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBmeta right",-180, 180, 1), true),
        ui_yawjitter1 = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BByaw jitter",{"off", "offset", "center", "random", "skitter", "dynamic center", "divine meta", "divine logic"}, 0), true),
        ui_yawjitter_jit1 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBswitch delay",0, 10, 5), true),
        ui_yawjitter_value111 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BByaw jitter",-180, 180, 1), true),
        ui_yawjitter_value11 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBleft limit",-180, 180, 1), true),
        ui_yawjitter_value21 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBright limit",-180, 180, 1), true),
        ui_yawjitter_value31 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBmeta left limit",-180, 180, 1), true),
        ui_yawjitter_value41 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBmeta right limit",-180, 180, 1), true),
        ui_bodyway1 = div.handlers.ui.new(ui.new_combobox("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBbody yaw",{"off", "opposite", "Jitter", "static", "divine meta", "divine logic"}, 0), true),
        ui_bodyway_value1 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBbody yaw",-180, 180, 1), true),
        ui_roll_value1 = div.handlers.ui.new(ui.new_slider("AA", "Anti-aimbot angles", "\aB0CEFFFFdivine "..(var1.player_states[i]).." \a848484BBroll",-45, 45, 0), true),
    }
end
local ui_defensive_tab = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFdefensive aa", function() end)), function()
    return
end
local close_defensive = div.handlers.ui.new(ui.new_button("aa", "anti-aimbot angles", "\aB0CEFFFFback", function() end)), function()
    return
end





function init_database()
    if database.read(div.database.configs) == nil then
        database.write(div.database.configs, {})
    end
    
        for i, preset in pairs(div.presets) do
            table.insert(div.presets, { name = "*"..preset.name, config = preset.config})
        end
    
        ui.update(ui_configs, get_config_list())
    end

init_database()

animation_variables = {};

-- LERP FUNCTION FOR THE ANIMATION
function animation_variables.lerp(a, b, t)
    return a + (b - a) * t
end

-- ALPHA = ALPHA; MIN = MINIMUM ALPHA FOR THE PULSATION; MAX = MAXIMUM ALPHA FOR THE PULSATION; SPEED = ANIMATION SPEED
function animation_variables.pulsate(alpha, min, max, speed)
    local threshold = 0.01
    local new_change = true
    if alpha >= max - threshold then
        new_change = false
    elseif alpha <= min + threshold then
        new_change = true
    end

    if new_change == true then
        alpha = animation_variables.lerp(alpha, max, globals.frametime() * speed)
    else
        alpha = animation_variables.lerp(alpha, min, globals.frametime() * speed)
    end

    return alpha 
end

-- OFFSET TO BE MODULATED; WHEN = TRUE OR FALSE TO MODULATE; ORIGINAL = ORIGINAL POSITION; NEW_PLACE = LOCATION FOR THE OFFSET TO MOVE TO; SPEED = ANIMATION SPEED
function animation_variables.movement(offset, when, original, new_place, speed)
    if when then
        offset = animation_variables.lerp(offset, new_place, globals.frametime() * speed)
    else
        offset = animation_variables.lerp(offset, original, globals.frametime() * speed)
    end

    return offset 
end

-- ALPHA = YOUR ALPHA; FADE_BOOL = IF TRUE FADES IN IF NEGATIVE FADES AWAY;F_IN = FADE IN ALPHA; F_AWAY = FADE AWAY ALPHA; SPEED = ANIMATION SPEED
function animation_variables.fade(alpha, fade_bool, f_in, f_away, speed) 
    if fade_bool then
        alpha = animation_variables.lerp(alpha, f_in, globals.frametime() * speed)
    else
        alpha = animation_variables.lerp(alpha, f_away, globals.frametime() * speed)
    end

    return alpha
end

alpha_pulse = 0
offset_move = 0
offset_move2 = 0
dtoffset = 0
duckoffset = 0
alpha_fade = 0
dmgoffset = 0
pingoffset = 0
fsoffset = 0
local fonts = {
    mid = surface.create_font("verdana", 11, 900, {0x010, 0x080}),
    pixel = surface.create_font("Smallest Pixel-7", 10, 400, {0x200}),
    exp = surface.create_font("Smallest Pixel-7", 11, 500, {0x200}),
}
local ctx = {}
ctx.m_render = {
    rec = function(self, x, y, w, h, radius, color)
        radius = math.min(x/2, y/2, radius)
        local r, g, b, a = unpack(color)
        renderer.rectangle(x, y + radius, w, h - radius*2, r, g, b, a)
        renderer.rectangle(x + radius, y, w - radius*2, radius, r, g, b, a)
        renderer.rectangle(x + radius, y + h - radius, w - radius*2, radius, r, g, b, a)
        renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25)
        renderer.circle(x - radius + w, y + radius, r, g, b, a, radius, 90, 0.25)
        renderer.circle(x - radius + w, y - radius + h, r, g, b, a, radius, 0, 0.25)
        renderer.circle(x + radius, y - radius + h, r, g, b, a, radius, -90, 0.25)
    end,

    rec_outline = function(self, x, y, w, h, radius, thickness, color)
        radius = math.min(w/2, h/2, radius)
        local r, g, b, a = unpack(color)
        if radius == 1 then
            renderer.rectangle(x, y, w, thickness, r, g, b, a)
            renderer.rectangle(x, y + h - thickness, w , thickness, r, g, b, a)
        else
            renderer.rectangle(x + radius, y, w - radius*2, thickness, r, g, b, a)
            renderer.rectangle(x + radius, y + h - thickness, w - radius*2, thickness, r, g, b, a)
            renderer.rectangle(x, y + radius, thickness, h - radius*2, r, g, b, a)
            renderer.rectangle(x + w - thickness, y + radius, thickness, h - radius*2, r, g, b, a)
            renderer.circle_outline(x + radius, y + radius, r, g, b, a, radius, 180, 0.25, thickness)
            renderer.circle_outline(x + radius, y + h - radius, r, g, b, a, radius, 90, 0.25, thickness)
            renderer.circle_outline(x + w - radius, y + radius, r, g, b, a, radius, -90, 0.25, thickness)
            renderer.circle_outline(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25, thickness)
        end
    end,

    glow_module = function(self, x, y, w, h, width, rounding, accent, accent_inner)
        local thickness = 1
        local offset = 1
        local r, g, b, a = unpack(accent)
        if accent_inner then
            self:rec(x , y, w, h + 1, rounding, accent_inner)
            --renderer.blur(x , y, w, h)
            --m_render.rec_outline(x + width*thickness - width*thickness, y + width*thickness - width*thickness, w - width*thickness*2 + width*thickness*2, h - width*thickness*2 + width*thickness*2, color(r, g, b, 255), rounding, thickness)
        end
        for k = 0, width do
            if a * (k/width)^(1) > 5 then
                local accent = {r, g, b, a * (k/width)^(2)}
                self:rec_outline(x + (k - width - offset)*thickness, y + (k - width - offset) * thickness, w - (k - width - offset)*thickness*2, h + 1 - (k - width - offset)*thickness*2, rounding + thickness * (width - k + offset), thickness, accent)
            end
        end
    end
}

function string_anim(text, frac)
    return string.sub(text,1, math.ceil(string.len(text) * frac))
  end

function RGBAtoHEX(redArg, greenArg, blueArg, alphaArg)
    return string.format('%.2x%.2x%.2x%.2x', redArg, greenArg, blueArg, alphaArg)
end

local reference = {
    slowmo = { ui.reference("AA", "Other", "Slow motion") },
    fakeduck = ui.reference("RAGE", "Other", "Duck peek assist"),
    roll = ui.reference("AA", "Anti-aimbot angles", "roll")
}

 state =  {
    value = 0
}

ctx.indicators = {
    render = function(self)
        local me = _G[server_message[43]][server_message[38]]()

        if not me or not _G[server_message[43]][server_message[41]](me) then
            return
        end

        local h,j,k,l = ui.get(text_color)
        local dmgog = ui.get(mindmg)
        local text = ui.get(slider)
        local me = _G[server_message[43]][server_message[38]]()
        local scoped = _G[server_message[43]][server_message[39]](me, 'm_bIsScoped') == 1
        local measure = renderer.measure_text("bc", "divine.sys")
        local rounding_px = math.floor((measure + 4 ) / 2)

        if ui.get(ui_min_dmg_ind) then
            if ui.get(key) then 
                renderer.text(x + 15, y - 15, h,j,k,l, "c", nil, text)
            else
                renderer.text(x + 15, y - 15, h,j,k,l, "c", nil, dmgog)
            end
        end

        if not _G[server_message[43]][server_message[41]](_G[server_message[43]][server_message[38]]()) then return end

        if not ui.get(eindicatorx) then return end
        local r,g,b = ui.get(indicatorxc)
        local offsetttt = 0

        local nicehardcodebraindead = ui.get(indoptions)


                offset_move2 = animation_variables.movement(offset_move2, scoped, 0, 16, 4)
                fsoffset = animation_variables.movement(fsoffset, ui.get(fs), 0, 20, 8)
                dmgoffset = animation_variables.movement(dmgoffset, ui.get(key), 0, 20, 8)
                pingoffset = animation_variables.movement(pingoffset, ui.get(ref.ping[2]), 0, 20, 8)
                dtoffset = animation_variables.movement(dtoffset, ui.get(ref.dt[2]) or ui.get(ref.hs[2]), 0, 20, 8)
                duckoffset = animation_variables.movement(duckoffset, ui.get(ref.fd), 0, 20, 8)
            if ui.get(indicatorx) == "old" then
                local current_yaw = 0
                local lerp_factor = 0.05
                offset_move = animation_variables.movement(offset_move, scoped, 0, 32, 5)
                surface.draw_text(x + offset_move2 * 1.1 - 10, y + 25, 255, 255, 255, 255, fonts.pixel, tostring(math.floor(anti_aim.get_desync(nil))) .. "%")
                if anti_aim.get_desync(2) <= 0 then
                    renderer.text(x + 2 - 15 + offset_move * 1.1, y + 20, r,g,b, 255, "bc", nil, "divine")
                    renderer.text(x + 2 + 10 + offset_move * 1.1, y + 20, 255,255,255, 255, "bc", nil, ".lua")    
                elseif anti_aim.get_desync(2) > 0 then
                    renderer.text(x + 2 - 15 + offset_move * 1.1, y + 20, 255 ,255 ,255, 255, "bc", nil, "divine")   
                    renderer.text(x + 2 + 10 + offset_move * 1.1, y + 20, r,g,b, 255, "bc", nil, ".lua")        
                end

                --"\aB0CEFFFFdouble\aFFFFFFFF tap", "\aB0CEFFFFhide\aFFFFFFFF shots", "\aB0CEFFFFping\aFFFFFFFF spike", "\aB0CEFFFFdam\aFFFFFFFFage", "\aB0CEFFFFfree\aFFFFFFFFstanding", "\aB0CEFFFFfake \aFFFFFFFFduck")
                if ui.get(ref.dt[2]) and anti_aim.get_double_tap() and not ui.get(ref.qp[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x - 4 + offset_move2 * 1.3, y + 20 + offsetttt + dtoffset, 255, 255, 255, 220, "-c", nil, "RAPID")
                    offsetttt = offsetttt + 10
                elseif ui.get(ref.dt[2]) and not anti_aim.get_double_tap() and not ui.get(ref.qp[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x - 4 + offset_move2 * 1.3, y + 20 + offsetttt + dtoffset, 200, 0, 0, 255, "-c", nil, "RAPID")
                    offsetttt = offsetttt + 10
                elseif ui.get(ref.qp[2]) and ui.get(ref.dt[2]) and anti_aim.get_double_tap() and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x - 4 + offset_move2 * 1.8, y + 20 + offsetttt + dtoffset, 255, 255, 255, 255, "-c", nil, "~READY TICK")
                    offsetttt = offsetttt + 10
                elseif ui.get(ref.qp[2]) and ui.get(ref.dt[2]) and not anti_aim.get_double_tap() and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x - 4 + offset_move2 * 1.8, y + 20 + offsetttt + dtoffset, 200, 0, 0, 255, "-c", nil, "~WAITING TICK")
                    offsetttt = offsetttt + 10
                elseif ui.get(ref.hs[2]) and not ui.get(ref.dt[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFhide\aFFFFFFFF shots") then
                    renderer.text(x - 4 + offset_move2 * 1.2, y + 20 + offsetttt + dtoffset, 136,207,52, 220, "-c", 0, "OSAA")
                    offsetttt = offsetttt + 10
                end
                if ui.get(ref.fd) and contains(nicehardcodebraindead, "\aB0CEFFFFfake \aFFFFFFFFduck") then
                    renderer.text(x - 4 + offset_move2 * 1.2, y + 20 + offsetttt + duckoffset, 150, 150, 150, 255, "-c", 0, "DUCK")
                    offsetttt = offsetttt + 10
                end
                if ui.get(fs) and contains(nicehardcodebraindead, "\aB0CEFFFFfree\aFFFFFFFFstanding") then
                    renderer.text(x - 4 + offset_move2 * 0.9, y + 20 + offsetttt + fsoffset, 240, 255, 71, 255, "-c", 0, "FS")
                    offsetttt = offsetttt + 10
                end
                if ui.get(ref.ping[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFping\aFFFFFFFF spike") then
                    renderer.text(x - 4 + offset_move2 * 1.1, y + 20 + offsetttt + pingoffset, 132, 195, 16, 255, "-c", 0, "PING")
                    offsetttt = offsetttt + 10
                end
                if ui.get(key) and contains(nicehardcodebraindead, "\aB0CEFFFFdam\aFFFFFFFFage") then
                    renderer.text(x - 4 + offset_move2 * 1.1, y + 19 + offsetttt + dmgoffset, 225, 230, 235, 240, "-c", 0, "DMG")
                    offsetttt = offsetttt + 10
                end
                ctx.m_render:glow_module(x + 2 - 30 + offset_move, y + 20, measure, 0, 10 , 0, {r, g, b, 90}, {r, g, b, 90})
            elseif ui.get(indicatorx) == "modern" then

                local aA = {
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 80 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 75 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 70 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 65 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 60 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 55 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 50 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 45 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 40 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 35 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 30 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 25 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 20 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 15 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 10 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 5 / 30))},
                    {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime()/4 + 0 / 30))}
                }
            
                alpha_pulse = animation_variables.pulsate(alpha_pulse,0,255,5)
                offset_move = animation_variables.movement(offset_move,scoped,0,30,5)
                alpha_fade = animation_variables.fade(alpha_fade,scoped,255,0,5)

                renderer.text(x + offset_move * 0.9,  y + 30 + offsetttt, 255, 255, 255, 255, "-c", nil, "{-" .. state.value .. "-}")
                offsetttt = offsetttt + 8
                if ui.get(ref.dt[2]) and anti_aim.get_double_tap() and not ui.get(ref.qp[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x + offset_move2 * 1.3, y + 12 + offsetttt + dtoffset, 255, 255, 255, 220, "-c", nil, "RAPID")
                    offsetttt = offsetttt + 8
                elseif ui.get(ref.dt[2]) and not anti_aim.get_double_tap() and not ui.get(ref.qp[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x + offset_move2 * 1.3, y + 12 + offsetttt + dtoffset, 200, 0, 0, 255, "-c", nil, "RAPID")
                    offsetttt = offsetttt + 8
                elseif ui.get(ref.qp[2]) and ui.get(ref.dt[2]) and anti_aim.get_double_tap() and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x + offset_move2 * 1.8, y + 12 + offsetttt + dtoffset, 255, 255, 255, 255, "-c", nil, "~READY TICK")
                    offsetttt = offsetttt + 8
                elseif ui.get(ref.qp[2]) and ui.get(ref.dt[2]) and not anti_aim.get_double_tap() and contains(nicehardcodebraindead, "\aB0CEFFFFdouble\aFFFFFFFF tap") then
                    renderer.text(x + offset_move2 * 1.8, y + 12 + offsetttt + dtoffset, 200, 0, 0, 255, "-c", nil, "~WAITING TICK")
                    offsetttt = offsetttt + 8
                elseif ui.get(ref.hs[2]) and not ui.get(ref.dt[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFhide\aFFFFFFFF shots") then
                    renderer.text(x + offset_move2 * 1.2, y + 12 + offsetttt + dtoffset, 136,207,52, 220, "-c", 0, "OSAA")
                    offsetttt = offsetttt + 8
                end
                if ui.get(ref.fd) and contains(nicehardcodebraindead, "\aB0CEFFFFfake \aFFFFFFFFduck") then
                    renderer.text(x + offset_move2 * 1.2, y + 12 + offsetttt + duckoffset, 150, 150, 150, 255, "-c", 0, "DUCK")
                    offsetttt = offsetttt + 8
                end
                if ui.get(fs) and contains(nicehardcodebraindead, "\aB0CEFFFFfree\aFFFFFFFFstanding") then
                    renderer.text(x + offset_move2 * 0.9, y + 12 + offsetttt + fsoffset, 240, 255, 71, 255, "-c", 0, "FS")
                    offsetttt = offsetttt + 8
                end
                if ui.get(ref.ping[2]) and contains(nicehardcodebraindead, "\aB0CEFFFFping\aFFFFFFFF spike") then
                    renderer.text(x + offset_move2 * 1.1, y + 12 + offsetttt + pingoffset, 132, 195, 16, 255, "-c", 0, "PING")
                    offsetttt = offsetttt + 8
                end
                if ui.get(key) and contains(nicehardcodebraindead, "\aB0CEFFFFdam\aFFFFFFFFage") then 
                    renderer.text(x + offset_move2 * 1.1, y + 12 + offsetttt + dmgoffset, 225, 230, 235, 240, "-c", 0, "DMG")
                    offsetttt = offsetttt + 8
                end
                renderer.text(x + offset_move * 1.1, y + 20, 0, 0, 0, 255, "bc", nil, "divine.lua")
                renderer.text(x + offset_move * 1.1, y + 20, 255, 255, 255, 255, "bc", nil, string.format("\a%sd\a%si\a%sv\a%si\a%sn\a%se\a%s.\a%sl\a%su\a%sa", RGBAtoHEX(unpack(aA[1])), RGBAtoHEX(unpack(aA[2])), RGBAtoHEX(unpack(aA[3])), RGBAtoHEX(unpack(aA[4])), RGBAtoHEX(unpack(aA[5])), RGBAtoHEX(unpack(aA[6])), RGBAtoHEX(unpack(aA[7])), RGBAtoHEX(unpack(aA[8])), RGBAtoHEX(unpack(aA[9])),RGBAtoHEX(unpack(aA[10])),RGBAtoHEX(unpack(aA[11])),RGBAtoHEX(unpack(aA[12])),RGBAtoHEX(unpack(aA[13])),RGBAtoHEX(unpack(aA[14])),RGBAtoHEX(unpack(aA[15])),RGBAtoHEX(unpack(aA[16])),RGBAtoHEX(unpack(aA[17]))))
                ctx.m_render:glow_module(x - 25 + offset_move, y + 20, measure, 0, 10 , 0, {r, g, b, 90}, {r, g, b, 90})
                
            end
        end
}

ffi.cdef[[
    struct c_animstate {
        char pad[ 3 ];
        char m_bForceWeaponUpdate; //0x4
        char pad1[ 91 ];
        void* m_pBaseEntity; //0x60
        void* m_pActiveWeapon; //0x64
        void* m_pLastActiveWeapon; //0x68
        float m_flLastClientSideAnimationUpdateTime; //0x6C
        int m_iLastClientSideAnimationUpdateFramecount; //0x70
        float m_flAnimUpdateDelta; //0x74
        float m_flEyeYaw; //0x78
        float m_flPitch; //0x7C
        float m_flGoalFeetYaw; //0x80
        float m_flCurrentFeetYaw; //0x84
        float m_flCurrentTorsoYaw; //0x88
        float m_flUnknownVelocityLean; //0x8C
        float m_flLeanAmount; //0x90
        char pad2[ 4 ];
        float m_flFeetCycle; //0x98
        float m_flFeetYawRate; //0x9C
        char pad3[ 4 ];
        float m_fDuckAmount; //0xA4
        float m_fLandingDuckAdditiveSomething; //0xA8
        char pad4[ 4 ];
        float m_vOriginX; //0xB0
        float m_vOriginY; //0xB4
        float m_vOriginZ; //0xB8
        float m_vLastOriginX; //0xBC
        float m_vLastOriginY; //0xC0
        float m_vLastOriginZ; //0xC4
        float m_vVelocityX; //0xC8
        float m_vVelocityY; //0xCC
        char pad5[ 4 ];
        float m_flUnknownFloat1; //0xD4
        char pad6[ 8 ];
        float m_flUnknownFloat2; //0xE0
        float m_flUnknownFloat3; //0xE4
        float m_flUnknown; //0xE8
        float m_flSpeed2D; //0xEC
        float m_flUpVelocity; //0xF0
        float m_flSpeedNormalized; //0xF4
        float m_flFeetSpeedForwardsOrSideWays; //0xF8
        float m_flFeetSpeedUnknownForwardOrSideways; //0xFC
        float m_flTimeSinceStartedMoving; //0x100
        float m_flTimeSinceStoppedMoving; //0x104
        bool m_bOnGround; //0x108
        bool m_bInHitGroundAnimation; //0x109
        float m_flTimeSinceInAir; //0x10A
        float m_flLastOriginZ; //0x10E
        float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x112
        float m_flStopToFullRunningFraction; //0x116
        char pad7[ 4 ]; //0x11A
        float m_flMagicFraction; //0x11E
        char pad8[ 60 ]; //0x122
        float m_flWorldForce; //0x15E
        char pad9[ 462 ]; //0x162
        float m_flMaxYaw; //0x334
    };


    typedef struct
    {
        float   m_anim_time;		
        float   m_fade_out_time;	
        int     m_flags;			
        int     m_activity;			
        int     m_priority;			
        int     m_order;			
        int     m_sequence;			
        float   m_prev_cycle;		
        float   m_weight;			
        float   m_weight_delta_rate;
        float   m_playback_rate;	
        float   m_cycle;			
        void* m_owner;			
        int     m_bits;				
    } C_AnimationLayer;

    typedef uintptr_t (__thiscall* GetClientEntityHandle_4242425_t)(void*, uintptr_t);
]]

math.clamp = function(v, min, max)
    if min > max then min, max = max, min end
    if v > max then return max end
    if v < min then return v end
    return v
end

math.angle_diff = function(dest, src)
    local delta = 0.0

    delta = math.fmod(dest - src, 360.0)

    if dest > src then
        if delta >= 180 then delta = delta - 360 end
    else
        if delta <= -180 then delta = delta + 360 end
    end

    return delta
end

math.angle_normalize = function(angle)
    local ang = 0.0
    ang = math.fmod(angle, 360.0)

    if ang < 0.0 then ang = ang + 360 end

    return ang
end

math.anglemod = function(a)
    local num = (360 / 65536) * bit.band(math.floor(a * (65536 / 360.0), 65535))
    return num
end

math.approach_angle = function(target, value, speed)
    target = math.anglemod(target)
    value = math.anglemod(value)

    local delta = target - value

    if speed < 0 then speed = -speed end

    if delta < -180 then
        delta = delta + 360
    elseif delta > 180 then
        delta = delta - 360
    end

    if delta > speed then
        value = value + speed
    elseif delta < -speed then
        value = value - speed
    else
        value = target
    end

    return value
end

math.vec_length2d = function(vec)
    root = 0.0
    sqst = vec.x * vec.x + vec.y * vec.y
    root = math.sqrt(sqst)
    return root
end

function _G[server_message[43]][server_message[39]]_vector(ent, tbl, array)
    local x, y, z = _G[server_message[43]][server_message[39]](ent, tbl, (array or nil))
    return {x = x, y = y, z = z}
end

function globals.is_connected()
    local lp = _G[server_message[43]][server_message[38]]()

    if lp ~= nil and lp > 0 then return false
        else return true end
end

local entity_list_ptr = ffi.cast("void***", _G[server_message[42]][server_message[36]]("client.dll","VClientEntityList003"))
local get_client_entity_fn = ffi.cast("GetClientEntityHandle_4242425_t",entity_list_ptr[0][3])
local get_client_entity_by_handle_fn = ffi.cast("GetClientEntityHandle_4242425_t",entity_list_ptr[0][4])

entity.get_address = function(idx)
    return get_client_entity_fn(entity_list_ptr, idx)
end

entity.get_animstate = function(idx)
    local addr = entity.get_address(idx)
    if not addr then return end
    return ffi.cast("struct c_animstate**", addr + 0x9960)[0]
end

entity.get_animlayer = function(idx, i)
    local addr = entity.get_address(idx)
    if not addr then return end

    return ffi.cast("C_AnimationLayer**", ffi.cast('uintptr_t', addr) + 0x9960)[0][i]
end

local RESOLVER = {
    ORIGINAL = 0,
    NEGATIVE = -1,
    POSITIVE = 1,
    HALF_NEGATIVE = -0.5,
    HALF_POSITIVE = 0.5
}

local ANIMLAYERS = {
    AIMMATRIX = 0 ,
	WEAPON_ACTION = 1 ,
	WEAPON_ACTION_RECROUCH = 2 ,
	ADJUST = 3 ,
	JUMP_OR_FALL = 4 ,
	LAND_OR_CLIMB = 5 ,
	MOVE = 6 ,
	STRAFECHANGE = 7 ,
	WHOLE_BODY = 8 ,
	FLASHED = 9 ,
	FLINCH = 10 ,
	ALIVELOOP = 11 ,
	LEAN = 12 ,
}

local m_iMaxRecords = 10

function table.deepcopy(obj, seen)
    -- Handle non-tables and previously-seen tables.
    if type(obj) ~= 'table' then return obj end
    if seen and seen[obj] then return seen[obj] end

    -- New table; mark it as seen an copy recursively.
    local s = seen or {}
    local res = {}
    s[obj] = res
    for k, v in next, obj do res[table.deepcopy(k, s)] = table.deepcopy(v, s) end
    return setmetatable(res, getmetatable(obj))
end

function table.push_back(tbl, push, max)
    local ret_tbl = table.deepcopy(tbl)
    if not max then max = #ret_tbl end
    for i = max - 1, 1, -1 do
        if ret_tbl[i] ~= nil then
            ret_tbl[i + 1] = ret_tbl[i] 
        end
        if i == 1 then
            ret_tbl[i] = push
        end
    end
    return ret_tbl
end

local resolver = {}
local records = {}
resolver.get_layers = function(idx)
    local layers = {}
    for i = 1, 12 do
        local layer = entity.get_animlayer(idx, i)
        --local layer = get_layers[i]
        if not layer then goto continue end

        if not layers[i] then
            layers[i] = {}
        end

        layers[i].m_playback_rate = layer.m_playback_rate
        layers[i].m_sequence = layer.m_sequence
        
        ::continue::
    end
    --print(tostring(layers[6].m_playback_rate))
    return layers
end

records.layers = {}
resolver.update_layers = function(idx)
    if not records.layers[idx] then
        records.layers[idx] = {}
    end
    local current_layer = resolver.get_layers(idx)
    records.layers[idx] = table.push_back(records.layers[idx], current_layer, m_iMaxRecords)
end

resolver.get_data = function(idx)
    local animstate = entity.get_animstate(idx)
    if not animstate then return end

    local ent = idx
    local ret = {}
    ret.m_flGoalFeetYaw = animstate.m_flGoalFeetYaw
    ret.m_flEyeYaw = animstate.m_flEyeYaw
    ret.m_iEntity = ent > 0 and ent or nil
    ret.m_vecVelocity = ret.m_iEntity and _G[server_message[43]][server_message[39]]_vector(ent, 'm_vecVelocity') or {x = 0, y = 0, z = 0}
    ret.m_flDifference = math.angle_diff(animstate.m_flEyeYaw, animstate.m_flGoalFeetYaw)
    ret.m_flFeetSpeedForwardsOrSideWays = animstate.m_flFeetSpeedForwardsOrSideWays
    ret.m_flStopToFullRunningFraction = animstate.m_flStopToFullRunningFraction
    ret.m_fDuckAmount = animstate.m_fDuckAmount

    return ret
end

records.angles = {}
resolver.update_angles = function(idx)
    if not records.angles[idx] then
        records.angles[idx] = {}
    end
    local current_angles = resolver.get_data(idx)
    records.angles[idx] = table.push_back(records.angles[idx], current_angles, m_iMaxRecords)
end

local ROTATION = {
    SERVER = 1,
    CENTER = 2,
    LEFT = 3,
    RIGHT = 4
}

records.safepoints_container = {}
resolver.get_safepoints = function(idx, side, desync)
    if not records.safepoints_container[idx] then
        records.safepoints_container[idx] = {}
    end
    for i = 1, 4 do
        if not records.safepoints_container[idx][i] then
            records.safepoints_container[idx][i] = {}
            records.safepoints_container[idx][i].m_playback_rate = 0
        end
        
    end
    records.safepoints_container[idx][1].m_playback_rate = records.layers[idx][1][6].m_playback_rate

    local m_flDesync = side * desync
    if side < 0 then
        if m_flDesync <= -44 then
            records.safepoints_container[idx][4].m_playback_rate = records.safepoints_container[idx][1].m_playback_rate
        end
    elseif side > 0 then
        if m_flDesync >= 44 then
            records.safepoints_container[idx][3].m_playback_rate = records.safepoints_container[idx][1].m_playback_rate
        end
    else
        if desync <= 29 then
            records.safepoints_container[idx][2].m_playback_rate = records.safepoints_container[idx][1].m_playback_rate
        end
    end

    return records.safepoints_container[idx]
end

resolver.safepoints = {}
resolver.update_safepoints = function(idx, side, desync)
    if not resolver.safepoints[idx] then
        resolver.safepoints[idx] = {}
    end
    
    local current_safepoints = resolver.get_safepoints(idx, side, desync)
    resolver.safepoints[idx] = table.push_back(resolver.safepoints[idx], current_safepoints, m_iMaxRecords)
end

resolver.get_layer_side = function(idx, record)
    local m_iVelocity = math.vec_length2d(records.angles[idx][record].m_vecVelocity)
    if m_iVelocity < 2 then return end
    local layer = resolver.safepoints[idx][record]

    local m_center_layer = math.abs(layer[1].m_playback_rate - layer[2].m_playback_rate)
    local m_left_layer = math.abs(layer[1].m_playback_rate - layer[3].m_playback_rate)
    local m_right_layer = math.abs(layer[1].m_playback_rate - layer[4].m_playback_rate)

    if m_center_layer < m_left_layer or m_right_layer <= m_left_layer then
        if m_center_layer >= m_right_layer or m_left_layer > m_right_layer then
            return 1
        end
    end
    return -1
end

function m_flMaxDesyncDelta(record)
    local speedfactor = math.clamp(record.m_flFeetSpeedForwardsOrSideWays, 0, 1)
    local avg_speedfactor = (record.m_flStopToFullRunningFraction * -0.3 - 0.2) * speedfactor + 1

    local duck_amount = record.m_fDuckAmount

    if duck_amount > 0 then
        local max_velocity = math.clamp(record.m_flFeetSpeedForwardsOrSideWays, 0, 1)
        local duck_speed = duck_amount * max_velocity

        avg_speedfactor = avg_speedfactor + (duck_speed * (0.5 - avg_speedfactor))
    end

    return avg_speedfactor
end

resolver.run = function(idx, record, force)
    if not records.angles[idx] or not records.angles[idx][record] or not records.angles[idx][record + 1] then return end
    if not records.layers[idx] or not records.layers[idx][record] then return end

    local animstate = records.angles[idx][record]
    local previous = records.angles[idx][record + 1]
    local animlayer = records.layers[idx][record]

    if not animstate.m_iEntity or not previous.m_iEntity then return false end

    local m_flMaxDesyncFloat = m_flMaxDesyncDelta(animstate)
    local m_flDesync = m_flMaxDesyncFloat * 58

    local m_flAbsDiff = animstate.m_flDifference
    local m_flPrevAbsDiff = previous.m_flDifference

    local m_iVelocity = math.vec_length2d(animstate.m_vecVelocity)
    local m_iPrevVelocity = math.vec_length2d(previous.m_vecVelocity)

    local side = RESOLVER.ORIGINAL
    if animstate.m_flDifference <= 1 then
        side = RESOLVER.POSITIVE
    elseif animstate.m_flDifference >= 1 then
        side = RESOLVER.NEGATIVE
    end

    local m_bShouldResolve = true

    if m_flAbsDiff > 0 or m_flPrevAbsDiff > 0 then
        if m_flAbsDiff < m_flPrevAbsDiff then
            m_bShouldResolve = false

            if m_iVelocity >= m_iPrevVelocity then
                m_bShouldResolve = true
            end
        end

        if m_bShouldResolve then
            local m_flCurrentAngle = math.max(m_flAbsDiff, m_flPrevAbsDiff)
            if m_flAbsDiff <= 10.0 and m_flPrevAbsDiff <= 10.0 then
                m_flDesync = m_flCurrentAngle
            elseif m_flAbsDiff <= 35.0 and m_flPrevAbsDiff <= 35.0 then
                m_flDesync = math.max(29.0, m_flCurrentAngle)
            else
                m_flDesync = math.clamp(m_flCurrentAngle, 29.0, 58)
            end
        end
    end

    if (m_flAbsDiff < 1 or m_flPrevAbsDiff < 1 or side == 0) and not force then
        return
    end

    return {
        angle = m_flDesync,
        side = side,
        record = record
    }
end

resolver.apply = function(m_iEntityIndex, m_flDesync, m_iSide)
    local m_flFinalAngle = m_flDesync * m_iSide
    if m_flFinalAngle < 0 then
        m_flFinalAngle = math.ceil(m_flFinalAngle - 0.5)
    else
        m_flFinalAngle = math.floor(m_flFinalAngle + 0.5)
    end
    if m_iSide == 0 then
        plist.set(m_iEntityIndex, 'Force body yaw', false)
        return
    end

    plist.set(m_iEntityIndex, 'Force body yaw', true)
    plist.set(m_iEntityIndex, 'Force body yaw value', m_flFinalAngle)
end

resolver.bruteforce = {}
resolver.reset_bruteforce = false

resolver.hkResetBruteforce = function()
    for i = 1, 64 do
        resolver.bruteforce[i] = 0
        if i == 64 then
            resolver.reset_bruteforce = false
        end
    end
end

resolver.init = function()
    local lp = _G[server_message[43]][server_message[38]]()

    if not globals.is_connected() then
        resolver.hkResetBruteforce()
    elseif globals.is_connected() and _G[server_message[43]][server_message[39]](lp, 'm_iHealth') < 1 then
        resolver.hkResetBruteforce()
    elseif ui.get(ui_resolver) then
        resolver.hkResetBruteforce()
    end

    if globals.is_connected() or ui.get(ui_resolver) then return end
    --print('sex')

    local available_clients = _G[server_message[43]][server_message[40]](true) -- enemies only

    if _G[server_message[43]][server_message[39]](lp, 'm_iHealth') >= 1 then
        resolver.reset_bruteforce = true
    end

    for array = 1, #available_clients do
        local idx = available_clients[array]

        if idx == lp then goto continue end

        resolver.update_angles(idx)
        resolver.update_layers(idx)

        local info = nil
        local forced = false
        for record = 1, m_iMaxRecords - 1 do
            info = resolver.run(idx, record)
            if info then
                goto set_angle
            elseif record == (m_iMaxRecords - 1) then
                forced = true
                info = resolver.run(idx, 1, true)
            end
        end

        ::set_angle::
        --print('sex')
        if not info then goto continue end
        resolver.update_safepoints(idx, info.side, info.angle)
        local safepoint_side = resolver.get_layer_side(idx, info.record)

        local current_side = (safepoint_side ~= nil and info.side ~= 0) and safepoint_side or info.side
        if resolver.bruteforce[idx] and resolver.bruteforce[idx] > 0 then
            if resolver.bruteforce[idx] == 1 then
                current_side = -current_side
            else
                current_side = 0
            end
        end
        if info.side == 0 then current_side = 0 end

       -- print(tostring(entity.get_player_name(idx) .. ': ' .. (forced and '' or '(' .. info.record .. ')') .. (info.angle * info.side) .. (safepoint_side ~= nil and (safepoint_side ~= info.side and '[safepoint]' or '') or '') .. ((resolver.bruteforce[idx] and resolver.bruteforce[idx] > 0) and '[Bruteforced]' or '')))

        resolver.apply(idx, info.angle, current_side)

        ::continue::
    end
end

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[11])), function()
    resolver.init()
end)

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[17])), function(e)
    if e.reason == '?' then
        -- e.target
        if not resolver.bruteforce[e.target] then
            resolver.bruteforce[e.target] = 0
        end

        resolver.bruteforce[e.target] = resolver.bruteforce[e.target] + 1

        if resolver.bruteforce[e.target] > 2 then
            resolver.bruteforce[e.target] = 0
        end
    end
end)

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[16])), function(e)
    if resolver.bruteforce[e.target] and resolver.bruteforce[e.target] > 0 and _G[server_message[43]][server_message[39]](e.target, 'm_iHealth') < 1 then
        resolver.bruteforce[e.target] = 0
    end
end)
local x2,y2 = client.screen_size()
local rec1, rec2 = x2-x2+40, y2-(y2/2)
local cur_x, cur_y = (x2-x2)+40, (y2-y2/2)

menu = {
    mouse = ui.new_hotkey("LUA", "B", "Mouse 1", true, 0x0001)
}

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[1])), function()
    local cursx, cursy = ui.mouse_position()
    local player = _G[server_message[43]][server_message[38]]()
    local alive = _G[server_message[43]][server_message[41]](player)
    if not player or not alive then return end
    local side = anti_aim.get_desync(1)
    if side >= 0 then side = "right" else side = "left" end
    local me = _G[server_message[43]][server_message[38]]()

    if not me or not _G[server_message[43]][server_message[41]](me) then
        return
    end

    local idx = client.current_threat()

    --coronavirus
    if ui.get(menu.mouse) then
        if (cursx < (cur_x + 150)) and (cursx > (cur_x-30)) and (cursy < (cur_y + 90)) and (cursy > (cur_y-30)) then
            cur_x,cur_y = cursx, cursy
        else
            cur_x , cur_y = cur_x, cur_y
        end
    end

    if ui.get(dbgpanel) then

        local textl = {
            "Current state:",
            "Current desync:",
            "Current desync side:",
            "Current LBY:",
            "Current overlap:",
            "Current choke:"
        }
        local sizel = {}
        for i = 1, #textl do
            sizel[i] = {}
            sizel[i].x, sizel[i].y = renderer.measure_text(nil, textl[i])
        end
        local y_angs = cur_y - 15
    renderer.text(cur_x -25, y_angs, 255, 255, 255, 255, nil, nil, "Current state:")
    renderer.text(cur_x+sizel[1].x - 20, y_angs, 255, 255, 255, 255, nil, nil, "~ " .. state.value .. " ~")
    y_angs = y_angs + sizel[1].y
    renderer.text(cur_x-25, y_angs, 255, 255, 255, 255, nil, 98, "Current desync:")
    renderer.text(cur_x+sizel[2].x - 16, y_angs, 255, 255, 255, 255, nil, 19, anti_aim.get_desync(1))
    y_angs = y_angs + sizel[2].y
    renderer.text(cur_x-25, y_angs, 255, 255, 255, 255, nil, "nil", "Current desync side:")
    renderer.text(cur_x +sizel[3].x - 20, y_angs, 255, 255, 255, 255, nil, nil, side)
    y_angs = y_angs + sizel[3].y
    renderer.text(cur_x-25, y_angs, 255, 255, 255, 255, nil, 80, "Current LBY:  ")
    renderer.text(cur_x+sizel[4].x - 20, y_angs, 255, 255, 255, 255, nil, 80, _G[server_message[43]][server_message[39]](_G[server_message[43]][server_message[38]](), "m_flLowerBodyYawTarget"))
    y_angs = y_angs + sizel[4].y
    renderer.text(cur_x-25, y_angs, 255, 255, 255, 255, nil, nil, "Current overlap:")
    renderer.text(cur_x+sizel[5].x - 20, y_angs, 255, 255, 255, 255, nil, 15, anti_aim.get_overlap() * 100 .. "%")
    y_angs = y_angs + sizel[5].y
    renderer.text(cur_x-25, y_angs, 255, 255, 255, 255, nil, nil, "Current choke:")
    renderer.text(cur_x+sizel[6].x - 20, y_angs, 255, 255, 255, 255, nil, nil, globals.chokedcommands())
    y_angs = y_angs + sizel[6].y

    if idx == nil then return end
    local is_resolver_enabled = plist.get(idx, "Force body yaw")
    if idx and is_resolver_enabled and idx > 0 and _G[server_message[43]][server_message[39]](idx, 'm_iHealth') > 0 then
        local current_angle = is_resolver_enabled and plist.get(idx, 'Force body yaw value') or 0
        local current_side = 0
        if current_angle < 0 then
          current_side = -1
        elseif current_angle > 0 then
          current_side = 1
        end
        current_angle = math.abs(current_angle)

        local texts = {
            "--@ Divine resolver data cache:",
            "Current threat:",
            "Resolved angle:",
            "Resolved side:",
            "Bruteforce cache:"
        }
        local sizes = {}
        for i = 1, #texts do
            sizes[i] = {}
            sizes[i].x, sizes[i].y = renderer.measure_text(nil, texts[i])
        end
        local y_ang = cur_y + 70
        renderer.text(cur_x-25, y_ang, 255, 255, 255, 255, nil, nil, "--@ Divine resolver data cache:")
        y_ang = y_ang + sizes[1].y
        renderer.text(cur_x-25, y_ang, 255, 255, 255, 255, nil, nil, "Current threat:")
        renderer.text(cur_x+sizes[2].x - 22, y_ang, 255, 255, 255, 255, nil, nil, entity.get_player_name(idx))
        y_ang = y_ang + sizes[2].y
        renderer.text(cur_x-25, y_ang, 255, 255, 255, 255, nil, nil, "Resolved angle:" )
        renderer.text(cur_x+sizes[3].x - 22, y_ang, 255, 255, 255, 255, nil, nil, current_angle)
        y_ang = y_ang + sizes[3].y
        renderer.text(cur_x-25, y_ang, 255, 255, 255, 255, nil, nil, "Resolved side:" )
        renderer.text(cur_x+sizes[4].x - 22, y_ang, 255, 255, 255, 255, nil, nil, current_side)
        y_ang = y_ang + sizes[4].y
        renderer.text(cur_x-25, y_ang, 255, 255, 255, 255, nil, nil, "Bruteforce cache:" )
        renderer.text(cur_x+sizes[5].x - 22, y_ang, 255, 255, 255, 255, nil, nil, resolver.bruteforce[idx])
        y_ang = y_ang + sizes[5].y
        end
    end
end)


    function interpolate()
        if ui.get(disableinterpolation) then
            cvar.cl_interpolate:set_int(0)
        else
            cvar.cl_interpolate:set_int(1)
    end
    end
    
    function impprediction()
        if ui.get(prediction) then
            cvar.cl_interp_ratio:set_int(0)
            cvar.cl_interp:set_int(0)
            cvar.cl_updaterate:set_int(62)
        else
            cvar.cl_interp_ratio:set_int(1)
            cvar.cl_interp:set_int(0.15)
            cvar.cl_updaterate:set_int(64)
    end
    end

    local stat = {
        [0] = "Always on",
        [1] = "On hotkey",
        [2] = "Toggle",
        [3] = "Off hotkey"
    }
    
    local dtcache = {ui.get(ref.dt[2])}
    local cacheddata = false
    
    local function ipeekrun()
        local lp = _G[server_message[43]][server_message[38]]()
        local yescode = ui.get(ipeekopts)
        if not _G[server_message[43]][server_message[41]](lp) then return end
          if ui.get(ipeek) and ui.get(ipeekbind) and ui.get(ref.qp[2]) then

           local toggled = "Always on"

              if not _G[server_message[43]][server_message[41]](lp) then return end
                 if cacheddata then
                    dtcache = {ui.get(ref.dt[2])}
                    cacheddata = false
                 end --\aB0CEFFFFdouble\aFFFFFFFF tap", "\aB0CEFFFFedge\aFFFFFFFF yaw
                if contains(yescode,"\aB0CEFFFFdouble\aFFFFFFFF tap") then
                   ui.set(ref.dt[2], toggled)
                else 
                    return
                end
                if contains(yescode,"\aB0CEFFFFedge\aFFFFFFFF yaw") then
                      ui.set(refs_aa.edgeyaw, true)
                else 
                    return
                end
           else
               if not cacheddata then
                   ui.set(ref.dt[2], stat[dtcache[2]])
                   ui.set(refs_aa.edgeyaw, false)
                   cacheddata = true
               end
          end
       end

       --@ pasta go brr, self reminder: make defensiev exploit yourself its simple dont be fag
local var_table = {};

local prev_simulation_time = 0


local function time_to_ticks(t)
    return math.floor(0.5 + (t / globals.tickinterval()))
end
local diff_sim = 0
function var_table:sim_diff() 
    local current_simulation_time = time_to_ticks(_G[server_message[43]][server_message[39]](_G[server_message[43]][server_message[38]](), "m_flSimulationTime"))
    local diff = current_simulation_time - prev_simulation_time
    prev_simulation_time = current_simulation_time
    diff_sim = diff
    return diff_sim
end

sim_time_dt = 0
to_draw = "no"
to_up = "no"
to_draw_ticks = 0
go_ = "no"
lastingtime = 0

--function watermark()
   -- local screen_width, screen_height = client.screen_size()


	--local text = (('%s / %s'):format(obex_data.username, obex_data.build))

	--local margin, padding, flags = 18, 4, nil

	--local text_width, text_height = renderer.measure_text(flags, text)


	--renderer.rectangle(screen_width-text_width-margin-padding, margin-padding, text_width+padding*2, text_height+padding*2, 32, 32, 32, 200)
	--renderer.text(screen_width-text_width-margin, margin, 235, 235, 235, 255, flags, 0, text)

--end


function defensive_indicator()
    if not ui.get(ref.dt[2]) or not ui.get(ref.dt[1]) then return end
   
    local diff_mmeme = var_table.sim_diff()

    if diff_mmeme > 2 then
        to_draw = "yes"
        to_up = "yes"
        go_ = "yes"
     
    end
end 

function defensive_indicator_paint()
    if to_draw == "yes" and ui.get(ref.dt[2]) then
        draw_art = to_draw_ticks * 100 / 52

        to_draw_ticks = to_draw_ticks + 1

        if to_draw_ticks == 24 then
            to_draw_ticks = 0
            to_draw = "no"
            to_up = "no"
        end
    end
end

local get_entities = function(enemy_only, alive_only)
    local enemy_only = enemy_only ~= nil and enemy_only or false
    local alive_only = alive_only ~= nil and alive_only or true
    
    local result = {}
    local player_resource = entity.get_player_resource()
    
    for player = 1, globals.maxplayers() do
        local is_enemy, is_alive = true, true
        
        if enemy_only and not entity.is_enemy(player) then is_enemy = false end
        if is_enemy then
            if alive_only and _G[server_message[43]][server_message[39]](player_resource, 'm_bAlive', player) ~= 1 then is_alive = false end
            if is_alive then table.insert(result, player) end
        end
    end

    return result
end

local weapon_is_enabled = function(idx)
	if (idx == 38 or idx == 11) then
		return true
	elseif (idx == 40) then
		return true
	elseif (idx == 9) then
		return true
	elseif (idx == 64) then
		return true
	elseif (idx == 1) then
		return true
	end
	return false
end

--@ pasta kekw
local is_lethal = function(player)
    local local_player = _G[server_message[43]][server_message[38]]()
    if local_player == nil or not _G[server_message[43]][server_message[41]](local_player) then return end
    local local_origin = vector(_G[server_message[43]][server_message[39]](local_player, "m_vecAbsOrigin"))
    local distance = local_origin:dist(vector(_G[server_message[43]][server_message[39]](player, "m_vecOrigin")))
    local enemy_health = _G[server_message[43]][server_message[39]](player, "m_iHealth")

	local weapon_ent = entity.get_player_weapon(_G[server_message[43]][server_message[38]]())
	if weapon_ent == nil then return end
	
	local weapon_idx = _G[server_message[43]][server_message[39]](weapon_ent, "m_iItemDefinitionIndex")
	if weapon_idx == nil then return end
	
	local weapon = csgo_weapons[weapon_idx]
	if weapon == nil then return end

	if not weapon_is_enabled(weapon_idx) then return end

	local dmg_after_range = (weapon.damage * math.pow(weapon.range_modifier, (distance * 0.002))) * 1.25
	local armor = _G[server_message[43]][server_message[39]](player,"m_ArmorValue")
	local newdmg = dmg_after_range * (weapon.armor_ratio * 0.5)
	if dmg_after_range - (dmg_after_range * (weapon.armor_ratio * 0.5)) * 0.5 > armor then
		newdmg = dmg_after_range - (armor / 0.5)
	end
	return newdmg >= enemy_health
end
----

local logicskekw = function()
    local players = get_entities(true, true)
    local plocal = _G[server_message[43]][server_message[38]]()
    local vx, vy, vz = _G[server_message[43]][server_message[39]](plocal, "m_vecVelocity")
	local p_still = math.sqrt(vx ^ 2 + vy ^ 2) < 5
    for i=1, #players do
		local idx = players[i]
        local m_iHealth = _G[server_message[43]][server_message[39]](idx, 'm_iHealth')
        if ui.get(baimlogic) then
        if idx == nil then end
        if (m_iHealth < ui.get(baimhp)) and ui.get(baimlogicopts)[1] then
            plist.set(idx, "Override prefer body aim", "Force")
            --print("forced true")
        elseif (m_iHealth > ui.get(baimhp)) or not ui.get(baimlogicopts)[1] then
            plist.set(idx, "Override prefer body aim", "-")
            --print("forced false")
        end
        if is_lethal(players[i]) and ui.get(baimlogicopts)[2] then
            plist.set(idx, "Override prefer body aim", "Force") 
           -- print("forced lethal true")
        else
            plist.set(idx, "Override prefer body aim", "-")
            --print("forced lethal false")
        end

        
        
    end
    
    
    if ui.get(safelogic) then
        if (m_iHealth < ui.get(safehp)) and ui.get(safelogicopts)[1] then
            plist.set(idx, "Override safe point", "On")
           -- print("forced safepoint on")
        elseif (m_iHealth > ui.get(safehp)) or not ui.get(safelogicopts)[1] then
            plist.set(idx, "Override safe point", "Off")
            --print("forced safepoint off")
        end
        end

	end
     
     
end

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[33])), logicskekw)

counter = 0
counters = 0
counterss = 0
defdelay = 0
side = false
curtime = globals.curtime()
rt = globals.realtime()
defcheck = false
local timer = 0
local bttimer = 0
local defdelay = 0
_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[3])), function(cmd)
    if globals.realtime() > timer then
        if valuesjit == true then
            valuesjit = false
        else
            valuesjit = true
        end
        timer = globals.realtime() + 0.1
    end
end)

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[3])), function(cmd)
    if globals.realtime() > bttimer then
        if btbt == true then
            btbt = false
        else
            btbt = true
        end
        bttimer = globals.realtime() + 0.005
    end
end)

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[3])), function(cmd)
    if globals.realtime() > ui.get(ui_defdelay) / 20 - defdelay then
        if defcheck == true then
            defcheck = false
        else
            defcheck = true
        end
        defdelay = globals.realtime() + 0.1
    end
end)

local function antiaim_enable(cmd)

    local plocal = _G[server_message[43]][server_message[38]]()
    local vx, vy, vz = _G[server_message[43]][server_message[39]](plocal, "m_vecVelocity")
    local p_still = math.sqrt(vx ^ 2 + vy ^ 2) < 2  and cmd.in_duck == 0 and cmd.in_jump == 0
    local player_jumping = cmd.in_jump == 1 and cmd.in_duck == 0
    local on_ground = bit.band(_G[server_message[43]][server_message[39]](plocal, "m_fFlags"), 1) == 1
    local crouching = cmd.in_duck == 1 and cmd.in_jump == 0
    local air_crouch = cmd.in_jump == 1 and cmd.in_duck == 1
    local p_slow = ui.get(refs_aa.slow[1]) and ui.get(refs_aa.slow[2])
    local player_team = _G[server_message[43]][server_message[39]](plocal, "m_iTeamNum")

    if p_still == true and on_ground == true then
        var.p_state = 1
        var1.p_state = 1
        state.value = "LOWVEL"
    end
    if p_still == false and on_ground == true then
        var.p_state = 2
        var1.p_state = 2
        state.value = "WALK"
    end
    if player_jumping then
        var.p_state = 3
        var1.p_state = 3
        state.value = "AERO"
    end
    if air_crouch == true then
        var.p_state = 4
        var1.p_state = 4
        state.value = "AERIAL"
    end
    if crouching == true then
        var.p_state = 5
        var1.p_state = 5
        state.value = "DUCK"
    end
    if p_slow == true then
        var.p_state = 6
        var1.p_state = 6
        state.value = "TURTLE"
    end
    if not ui.get(ref.dt[2]) and not ui.get(ref.hs[2]) then
        var.p_state = 7
        var1.p_state = 7
        state.value = "FAKELAG"
    end
    if ui.get(ref.fd) then
        var.p_state = 8
        var1.p_state = 8
        state.value = "FAKECROUCH"
    end

    --if ui.get(ui_enable_semirage) then
    --    ui.set(ui_aapresets, "Disabled")
   -- end

    if cmd.chokedcommands == 0 then
        counterss = counterss + 0.5
        counters = counters + 0.5
        counter = counter + 0.5
    end

    if counterss > 2 then
        counterss = 0
    end
    
        if counters > 2 then
            counters = 0
        end
    
        if counter > 2 then
            counter = 0
        end

        if cmd.chokedcommands == 0 then
            if counters >= ui.get(antiaim[var.p_state].ui_yawjitter_jit) / 10 then
                checks = not checks
            end
            if counter >= ui.get(antiaim[var.p_state].ui_yaw_value_jit) / 10 then
                check = not check
            end
            if counterss >= ui.get(ui_sb_delay) / 10 then
                checkss = not checkss
            end
        end

        if cmd.chokedcommands == 0 then
            if counters >= ui.get(antiaim[var1.p_state].ui_yawjitter_jit1) / 10 then
                checks1 = not checks1
            end
            if counter >= ui.get(antiaim[var1.p_state].ui_yaw_value_jit1) / 10 then
                check1 = not check1
            end
        end

        if m_iJitterTick + 1 <= 2 then
            m_iJitterTick = m_iJitterTick + 1
        else
            m_iJitterTick = 0
        end

        local sjitvalue = ui.get(antiaim[var.p_state].ui_slowjit_value)
        local sjitvalue1 = ui.get(antiaim[var1.p_state].ui_slowjit_value1)

        if ui.get(ui_aapresets) == "Disabled" then 
            ui.set(refs_aa.enable, false)  
        end

        if ui.get(staticfs) and ui.get(fs) then
            ui.set(refs_aa.enable, true)
            ui.set(refs_aa.pitch, "Down")
            ui.set(refs_aa.yawbase, "At Targets")
            ui.set(refs_aa.yaw[1], "180")
            ui.set(refs_aa.yaw[2], "0")
            ui.set(refs_aa.yawjitter[1], "center")
            ui.set(refs_aa.yawjitter[2], "0")
            ui.set(refs_aa.bodyyaw[1], "Static")
            ui.set(refs_aa.bodyyaw[2], "180")
        else
        if ui.get(ui_aapresets) == "\aB0CEFFFFbuilder" then 
           ui.set(refs_aa.enable, true)
           if player_team == 2 then
           ui.set(refs_aa.pitch, ui.get(antiaim[var.p_state].ui_pitch))
           ui.set(refs_aa.yawbase, ui.get(antiaim[var.p_state].ui_yawbase))

        if ui.get(antiaim[var.p_state].ui_yaw) == "static" then
            ui.set(refs_aa.yaw[1], "180")
            ui.set(refs_aa.yaw[2], ui.get(antiaim[var.p_state].ui_yaw_value))
            elseif ui.get(antiaim[var.p_state].ui_yaw) == "yaw add left/right" then
            ui.set(refs_aa.yaw[1], "180")
            ui.set(refs_aa.yaw[2], check and ui.get(antiaim[var.p_state].ui_yaw_value1) or ui.get(antiaim[var.p_state].ui_yaw_value2))
        elseif ui.get(antiaim[var.p_state].ui_yaw) == "divine meta" then
            ui.set(refs_aa.yaw[1], "180")
            ui.set(refs_aa.yaw[2], m_iJitterTick > 0 and ui.get(antiaim[var.p_state].ui_yaw_value3) or ui.get(antiaim[var.p_state].ui_yaw_value4))
        elseif ui.get(antiaim[var.p_state].ui_yaw) == "slow-jit meta" then
            ui.set(refs_aa.yaw[1], "180")
            ui.set(refs_aa.yaw[2], valuesjit == true and -sjitvalue or sjitvalue)
        end

        if ui.get(antiaim[var.p_state].ui_yawjitter) == "dynamic center" and ui.get(antiaim[var.p_state].ui_yawjitter) ~= "divine meta" then
        ui.set(refs_aa.yawjitter[1], "center")
        ui.set(refs_aa.yawjitter[2], checks and ui.get(antiaim[var.p_state].ui_yawjitter_value1) or ui.get(antiaim[var.p_state].ui_yawjitter_value2))
        elseif ui.get(antiaim[var.p_state].ui_yawjitter) ~= "dynamic center" and ui.get(antiaim[var.p_state].ui_yawjitter) == "divine meta" then
        ui.set(refs_aa.yawjitter[1], "center")
        ui.set(refs_aa.yawjitter[2], m_iJitterTick > 0 and ui.get(antiaim[var.p_state].ui_yawjitter_value3) or ui.get(antiaim[var.p_state].ui_yawjitter_value4))
        elseif ui.get(antiaim[var.p_state].ui_yawjitter) ~= "dynamic center" and ui.get(antiaim[var.p_state].ui_yawjitter) ~= "divine meta" and ui.get(antiaim[var.p_state].ui_yawjitter) == "divine logic" then
        ui.set(refs_aa.yawjitter[1], m_iJitterTick > 0 and "Offset" or "center")
        ui.set(refs_aa.yawjitter[2], ui.get(antiaim[var.p_state].ui_yawjitter_value))
        elseif ui.get(antiaim[var.p_state].ui_yawjitter) ~= "dynamic center" and ui.get(antiaim[var.p_state].ui_yawjitter) ~= "divine meta" and ui.get(antiaim[var.p_state].ui_yawjitter) ~= "divine logic" then
        ui.set(refs_aa.yawjitter[1], ui.get(antiaim[var.p_state].ui_yawjitter))
        ui.set(refs_aa.yawjitter[2], ui.get(antiaim[var.p_state].ui_yawjitter_value))
        end

        if ui.get(antiaim[var.p_state].ui_bodyway) == "divine meta" then
            ui.set(refs_aa.bodyyaw[1], "Jitter")
            ui.set(refs_aa.bodyyaw[2], m_iJitterTick > 0 and ui.get(antiaim[var.p_state].ui_bodyway_value) or ui.get(antiaim[var.p_state].ui_bodyway_value) * -1)
        elseif ui.get(antiaim[var.p_state].ui_bodyway) == "divine logic" then
            ui.set(refs_aa.bodyyaw[1], m_iJitterTick > 0 and "Jitter" or "static")
            ui.set(refs_aa.bodyyaw[2], ui.get(antiaim[var.p_state].ui_bodyway_value))
        elseif ui.get(antiaim[var.p_state].ui_bodyway) ~= "divine meta" and ui.get(antiaim[var.p_state].ui_bodyway) ~= "divine logic"  then
            ui.set(refs_aa.bodyyaw[1], ui.get(antiaim[var.p_state].ui_bodyway))
            ui.set(refs_aa.bodyyaw[2], ui.get(antiaim[var.p_state].ui_bodyway_value))
        end
        ui.set(refs_aa.roll, ui.get(antiaim[var.p_state].ui_roll_value))
    elseif player_team == 3 then
        ui.set(refs_aa.pitch, ui.get(antiaim[var1.p_state].ui_pitch1))
        ui.set(refs_aa.yawbase, ui.get(antiaim[var1.p_state].ui_yawbase1))

     if ui.get(antiaim[var1.p_state].ui_yaw1) == "static" then
         ui.set(refs_aa.yaw[1], "180")
         ui.set(refs_aa.yaw[2], ui.get(antiaim[var1.p_state].ui_yaw_value111))
         elseif ui.get(antiaim[var1.p_state].ui_yaw1) == "yaw add left/right" then
         ui.set(refs_aa.yaw[1], "180")
         ui.set(refs_aa.yaw[2], check1 and ui.get(antiaim[var1.p_state].ui_yaw_value11) or ui.get(antiaim[var1.p_state].ui_yaw_value21))
     elseif ui.get(antiaim[var1.p_state].ui_yaw1) == "divine meta" then
         ui.set(refs_aa.yaw[1], "180")
         ui.set(refs_aa.yaw[2], m_iJitterTick > 0 and ui.get(antiaim[var1.p_state].ui_yaw_value31) or ui.get(antiaim[var1.p_state].ui_yaw_value41))
     elseif ui.get(antiaim[var1.p_state].ui_yaw1) == "slow-jit meta" then
         ui.set(refs_aa.yaw[1], "180")
         ui.set(refs_aa.yaw[2], valuesjit == false and -sjitvalue1 or sjitvalue1)
     end

     if ui.get(antiaim[var1.p_state].ui_yawjitter1) == "dynamic center" and ui.get(antiaim[var1.p_state].ui_yawjitter1) ~= "divine meta" then
     ui.set(refs_aa.yawjitter[1], "center")
     ui.set(refs_aa.yawjitter[2], checks1 and ui.get(antiaim[var1.p_state].ui_yawjitter_value11) or ui.get(antiaim[var1.p_state].ui_yawjitter_value21))
     elseif ui.get(antiaim[var1.p_state].ui_yawjitter1) ~= "dynamic center" and ui.get(antiaim[var1.p_state].ui_yawjitter1) == "divine meta" then
     ui.set(refs_aa.yawjitter[1], "center")
     ui.set(refs_aa.yawjitter[2], m_iJitterTick > 0 and ui.get(antiaim[var1.p_state].ui_yawjitter_value3) or ui.get(antiaim[var1.p_state].ui_yawjitter_value4))
     elseif ui.get(antiaim[var1.p_state].ui_yawjitter1) ~= "dynamic center" and ui.get(antiaim[var1.p_state].ui_yawjitter1) ~= "divine meta" and ui.get(antiaim[var1.p_state].ui_yawjitter1) == "divine logic" then
     ui.set(refs_aa.yawjitter[1], m_iJitterTick > 0 and "Offset" or "center")
     ui.set(refs_aa.yawjitter[2], ui.get(antiaim[var1.p_state].ui_yawjitter_value111))
     elseif ui.get(antiaim[var1.p_state].ui_yawjitter1) ~= "dynamic center" and ui.get(antiaim[var1.p_state].ui_yawjitter1) ~= "divine meta" and ui.get(antiaim[var1.p_state].ui_yawjitter1) ~= "divine logic" then
     ui.set(refs_aa.yawjitter[1], ui.get(antiaim[var1.p_state].ui_yawjitter1))
     ui.set(refs_aa.yawjitter[2], ui.get(antiaim[var1.p_state].ui_yawjitter_value111))
     end

     if ui.get(antiaim[var1.p_state].ui_bodyway1) == "divine meta" then
         ui.set(refs_aa.bodyyaw[1], "Jitter")
         ui.set(refs_aa.bodyyaw[2], m_iJitterTick > 0 and ui.get(antiaim[var1.p_state].ui_bodyway_value1) or ui.get(antiaim[var1.p_state].ui_bodyway_value1) * -1)
     elseif ui.get(antiaim[var1.p_state].ui_bodyway1) == "divine logic" then
         ui.set(refs_aa.bodyyaw[1], m_iJitterTick > 0 and "Jitter" or "static")
         ui.set(refs_aa.bodyyaw[2], ui.get(antiaim[var1.p_state].ui_bodyway_value1))
     elseif ui.get(antiaim[var1.p_state].ui_bodyway1) ~= "divine meta" and ui.get(antiaim[var1.p_state].ui_bodyway1) ~= "divine logic"  then
         ui.set(refs_aa.bodyyaw[1], ui.get(antiaim[var1.p_state].ui_bodyway1))
         ui.set(refs_aa.bodyyaw[2], ui.get(antiaim[var1.p_state].ui_bodyway_value1))
     end
     ui.set(refs_aa.roll, ui.get(antiaim[var1.p_state].ui_roll_value1))
    end
    elseif ui.get(ui_aapresets) == "\aB0CEFFFFsimple \aFFFFFFFFbuilder" then 
    ui.set(refs_aa.enable, true)
    ui.set(refs_aa.pitch, "Down")
    ui.set(refs_aa.yawbase, "At Targets")
    ui.set(refs_aa.yaw[1], "180")
    ui.set(refs_aa.yaw[2], ui.get(ui_sb_yaw))
    ui.set(refs_aa.yawjitter[1], "center")
    ui.set(refs_aa.yawjitter[2], checkss and -ui.get(ui_sb_real) or ui.get(ui_sb_real))
    ui.set(refs_aa.bodyyaw[1], "Jitter")
    ui.set(refs_aa.bodyyaw[2], ui.get(ui_sb_fake) * 2)
end


if ui.get(ui_defaa) then
if ui.get(ui_defair) and in_air(plocal) or not ui.get(ui_defair) then
    if defcheck == true then
if to_up == "yes" then
    ui.set(refs_aa.pitch, ui.get(ui_defpitch))
    ui.set(refs_aa.yaw[1], ui.get(ui_defyawt))
    ui.set(refs_aa.yaw[2], ui.get(ui_defyaw))
    ui.set(refs_aa.yawjitter[1], ui.get(ui_defyawm))
    ui.set(refs_aa.yawjitter[2], ui.get(ui_defyawmo))
    ui.set(refs_aa.bodyyaw[1], ui.get(ui_defdsy))
    ui.set(refs_aa.bodyyaw[2], ui.get(ui_defdsya))

    if not ui.get(ref.dt[1]) or not ui.get(ref.dt[2]) or defcheck == false then
        to_up = "no"
    end
end
end
end
end
end
end

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[3])), function(cmd)

    ui.set(refs_aa.freestand[1], ui.get(fs))
    ui.set(refs_aa.freestand[2], "Always on")
    ipeekrun()

    if ui.get(ui_forcedef) then
        local plocal = _G[server_message[43]][server_message[38]]()
        local on_ground = bit.band(_G[server_message[43]][server_message[39]](plocal, "m_fFlags"), 1) == 1
        if ui.get(ui_defconds) == "\aB0CEFFFFIn \aFFFFFFFFAir" and on_ground == false then
        cmd.force_defensive = 1
    else goto fuckdef
    end
        if ui.get(ui_defconds) == "\aB0CEFFFFOn \aFFFFFFFFpeeking" and ui.get(ref.qp[2]) then
        cmd.force_defensive = 1
    else goto fuckdef
    end

    ::fuckdef::
    cmd.force_defensive = 0
end
end)

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[13])), function()
    local self = _G[server_message[43]][server_message[38]]()
    if not self or not _G[server_message[43]][server_message[41]](self) then
        return
    end

    local self_index = c_entity.new(self)
    local self_anim_state = self_index:get_anim_state()

    local me = _G[server_message[43]][server_message[38]]()
    local age = ui.get(ui_ui_animsge)
    if not me or not _G[server_message[43]][server_message[41]](me) then return end

    local flags = _G[server_message[43]][server_message[39]](me, "m_fFlags")
    if ui.get(ui_animsa) == "static legs in air" then 
        entity.set_prop(me, "m_flPoseParameter", 1, 6) 
    end
    if contains(age, "pitch 0 on ground") then 
    ground_ticks = bit.band(flags, 1) == 1 and ground_ticks + 1 or 0
    if ground_ticks > 20 and ground_ticks < 160 then
        entity.set_prop(me, "m_flPoseParameter", 0.5, 12)
    end
    end

    if ui.get(ui_animsa) == "moonwalk in air" and in_air(me) then 
    entity.set_prop(_G[server_message[43]][server_message[38]](), "m_flPoseParameter", 1, 7)
        local my_animlayer = self_index:get_anim_overlay(6);
        my_animlayer.weight = 1;
        entity.set_prop(self_index, "m_flPoseParameter", 1, 6)
    end

    if contains(age, "animate move lean") then 
        local self_anim_overlay = self_index:get_anim_overlay(12)
        if not self_anim_overlay then
            return
        end

            self_anim_overlay.weight = 1
    end

    if ui.get(ui_animsg) == "moonwalk" and not in_air(me) then 
        local me    = _G[server_message[43]][server_message[38]]()
        local flags = _G[server_message[43]][server_message[39]](me, "m_fFlags")
        local vel1, vel2, vel3 = _G[server_message[43]][server_message[39]](me, 'm_vecVelocity')
        local speed = math.floor(math.sqrt(vel1 * vel1 + vel2 * vel2))
        local walking = speed >= 2
        if walking then
        ui.set(legsref, "Never slide")
        entity.set_prop(self_index, "m_flPoseParameter", 1, 6)
            local my_animlayer = self_index:get_anim_overlay(6);
            my_animlayer.weight = 1;
            entity.set_prop(self_index, "m_flPoseParameter", 1, 6)
            entity.set_prop(_G[server_message[43]][server_message[38]](), "m_flPoseParameter", 1, 7)
        end
    end
    if ui.get(ui_animsg) == "backward legs" and not in_air(me) then 
        entity.set_prop(_G[server_message[43]][server_message[38]](), "m_flPoseParameter", 1, 0)
        ui.set(legsref, "Always slide")
    end
end)

expval = {end_pos = vector(0, 0, 0), predict = vector(0, 0, 0), debug = false}
function breakbtexp(cmd)
     if ui.get(breakbtbool) then
        if btbt == true then
            cmd.force_defensive = 1
            cmd.allow_send_packet = false
            --print("false")
        else
            cmd.force_defensive = 0
            cmd.allow_send_packet = true
            --print("true")
        end
     end
end
    

local pressed_close = true
local function on_load2()
    --ui.set_visible(autotp , ui.get(ui_tabs) == "ragebot")
    ui.set_visible(breakbtbool, ui.get(ui_tabs) == "generals")
end
local function on_load()

    --# ragebot render
    ui.set_visible(ipeek, ui.get(ui_tabs) == "ragebot")
    ui.set_visible(ipeekopts, ui.get(ui_tabs) == "ragebot" and ui.get(ipeek))
    ui.set_visible(ipeekbind, ui.get(ui_tabs) == "ragebot" and ui.get(ipeek))
    ui.set_visible(baimlogic, ui.get(ui_tabs) == "ragebot")
    ui.set_visible(baimlogicopts, ui.get(ui_tabs) == "ragebot" and ui.get(baimlogic))
    ui.set_visible(baimhp, ui.get(ui_tabs) == "ragebot" and ui.get(baimlogicopts)[1] and ui.get(baimlogic))
    ui.set_visible(safelogic, ui.get(ui_tabs) == "ragebot")
    ui.set_visible(safelogicopts, ui.get(ui_tabs) == "ragebot" and ui.get(safelogic))
    ui.set_visible(safehp, ui.get(ui_tabs) == "ragebot" and ui.get(safelogic) and ui.get(safelogicopts)[1])
    ui.set_visible(ui_resolver, ui.get(ui_tabs) == "ragebot")
    ui.set_visible(prediction, ui.get(ui_tabs) == "ragebot")
    ui.set_visible(disableinterpolation, ui.get(ui_tabs) == "ragebot")


    --# aa render
    if pressed_open then
        ui.set_visible(close_defensive, ui.get(ui_tabs) == "anti-aim" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
    else
        ui.set_visible(close_defensive, false)
    end
   

    ui.set_visible(ui_aapresets, pressed_close and ui.get(ui_tabs) == "anti-aim" )
    ui.set_visible(teamside, pressed_close and ui.get(ui_tabs) == "anti-aim" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder") 
    ui.set_visible(ui_conditions, pressed_close and ui.get(teamside) == "T"  and ui.get(ui_tabs) == "anti-aim" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder") 
    ui.set_visible(ui_conditions1, pressed_close and ui.get(teamside) == "CT" and ui.get(ui_tabs) == "anti-aim" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder") 
    active_i = var.player_states_idx[ui.get(ui_conditions)]
    active_v = var1.player_states_idx[ui.get(ui_conditions1)]
    for i = 1,8 do
        ui.set_visible(antiaim[i].ui_pitch, pressed_close and active_i == i and pressed_close and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder" ) 
        ui.set_visible(antiaim[i].ui_yawbase,pressed_close and active_i == i and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw,pressed_close and active_i == i and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yaw) == "static" or ui.get(antiaim[i].ui_yaw) == "divine logic") and (ui.get(antiaim[i].ui_yaw) ~= "yaw add left/right" and ui.get(antiaim[i].ui_yaw) ~= "slow-jit meta" and ui.get(antiaim[i].ui_yaw) ~= "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value_jit,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yaw) == "yaw add left/right") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value1,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yaw) == "yaw add left/right") and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value2,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yaw) == "yaw add left/right") and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value3,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yaw) == "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value4,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yaw) == "divine meta") and ui.get(ui_tabs) == "anti-aim"   and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_slowjit_value,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yaw) == "slow-jit meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter,pressed_close and active_i == i and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_jit,pressed_close and active_i == i and ui.get(antiaim[i].ui_yawjitter) == "dynamic center" and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yawjitter) ~= "dynamic center" and ui.get(antiaim[i].ui_yawjitter) ~= "divine meta") and ui.get(antiaim[i].ui_yawjitter) ~= "Off" and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value1,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yawjitter) == "dynamic center" and ui.get(antiaim[i].ui_yawjitter) ~= "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        --ui.set_visible(antiaim[i].ui_yawjitter_value1, active_i == i and (ui.get(antiaim[i].ui_yawjitter) == "dynamic center" and ui.get(ui_tabs) == "anti-aim"   and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value2,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yawjitter) == "dynamic center" and ui.get(antiaim[i].ui_yawjitter) ~= "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value3,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yawjitter) == "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value4,pressed_close and active_i == i and (ui.get(antiaim[i].ui_yawjitter) == "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
       
        ui.set_visible(antiaim[i].ui_bodyway,pressed_close and active_i == i and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_bodyway_value,pressed_close and active_i == i and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "T"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_roll_value,pressed_close and active_i == i and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "T" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")

        


        ui.set_visible(antiaim[i].ui_pitch1, pressed_close and active_v == i and pressed_close and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder" ) 
        ui.set_visible(antiaim[i].ui_yawbase1,pressed_close and active_v == i and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw1,pressed_close and active_v == i and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value111,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yaw1) == "static" or ui.get(antiaim[i].ui_yaw1) == "divine logic") and (ui.get(antiaim[i].ui_yaw1) ~= "yaw add left/right" and ui.get(antiaim[i].ui_yaw1) ~= "slow-jit meta" and ui.get(antiaim[i].ui_yaw1) ~= "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value_jit1,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yaw1) == "yaw add left/right") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_slowjit_value1,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yaw1) == "slow-jit meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value11,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yaw1) == "yaw add left/right") and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value21,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yaw1) == "yaw add left/right") and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value31,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yaw1) == "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yaw_value41,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yaw1) == "divine meta") and ui.get(ui_tabs) == "anti-aim"   and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter1,pressed_close and active_v == i and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_jit1,pressed_close and active_v == i and ui.get(antiaim[i].ui_yawjitter1) == "dynamic center" and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value111,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yawjitter1) ~= "dynamic center" and ui.get(antiaim[i].ui_yawjitter1) ~= "divine meta") and ui.get(antiaim[i].ui_yawjitter1) ~= "Off" and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value11,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yawjitter1) == "dynamic center" and ui.get(antiaim[i].ui_yawjitter1) ~= "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        --ui.set_visible(antiaim[i].ui_yawjitter_value1, active_v == i and (ui.get(antiaim[i].ui_yawjitter) == "dynamic center" and ui.get(ui_tabs) == "anti-aim"   and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value21,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yawjitter1) == "dynamic center" and ui.get(antiaim[i].ui_yawjitter1) ~= "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value31,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yawjitter1) == "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_yawjitter_value41,pressed_close and active_v == i and (ui.get(antiaim[i].ui_yawjitter1) == "divine meta") and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
       
        ui.set_visible(antiaim[i].ui_bodyway1,pressed_close and active_v == i and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_bodyway_value1,pressed_close and active_v == i and ui.get(ui_tabs) == "anti-aim" and ui.get(teamside) == "CT"  and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
        ui.set_visible(antiaim[i].ui_roll_value1,pressed_close and active_v == i and ui.get(ui_tabs) == "anti-aim"  and ui.get(teamside) == "CT" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
    end


    ui.set_visible(ui_defensive_tab, ui.get(ui_tabs) == "anti-aim" and pressed_close and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
    

   -- ui.set_visible(ui_defensive_tab, ui.get(ui_tabs) == "anti-aim" and ui.get(ui_aapresets) == "\aB0CEFFFFbuilder")
    
    
    ui.set_visible(ui_sb_delay, ui.get(ui_tabs) == "anti-aim"   and ui.get(ui_aapresets) == "\aB0CEFFFFsimple \aFFFFFFFFbuilder")
    ui.set_visible(ui_sb_real, ui.get(ui_tabs) == "anti-aim"   and ui.get(ui_aapresets) == "\aB0CEFFFFsimple \aFFFFFFFFbuilder")
    ui.set_visible(ui_sb_yaw, ui.get(ui_tabs) == "anti-aim"   and ui.get(ui_aapresets) == "\aB0CEFFFFsimple \aFFFFFFFFbuilder")
    ui.set_visible(ui_sb_fake, ui.get(ui_tabs) == "anti-aim"   and ui.get(ui_aapresets) == "\aB0CEFFFFsimple \aFFFFFFFFbuilder")

    --ui.set_visible(ui_enable_semirage, ui.get(ui_tabs) == "semi-rage")
    --# exploits render
    if pressed_open then
        ui.set_visible(ui_forcedef, pressed_open and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defconds, pressed_open and ui.get(ui_forcedef) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defaa, pressed_open and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defair, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defdelay, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defpitch, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defyawt, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defyaw, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defyawm, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defyawmo, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defdsy, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
        ui.set_visible(ui_defdsya, pressed_open and ui.get(ui_defaa) and ui.get(ui_tabs) == "anti-aim")
    end

    if pressed_close then
        ui.set_visible(ui_forcedef, false)
        ui.set_visible(ui_defconds, false)
        ui.set_visible(ui_defaa, false)
        ui.set_visible(ui_defair, false)
        ui.set_visible(ui_defdelay, false)
        ui.set_visible(ui_defpitch, false)
        ui.set_visible(ui_defyawt, false)
        ui.set_visible(ui_defyaw, false)
        ui.set_visible(ui_defyawm, false)
        ui.set_visible(ui_defyawmo, false)
        ui.set_visible(ui_defdsy, false)
        ui.set_visible(ui_defdsya, false)
    end

    --# visuals render

    ui.set_visible(ui_min_dmg_ind, ui.get(ui_tabs) == "generals")
    ui.set_visible(text_color, ui.get(ui_min_dmg_ind) and ui.get(ui_tabs) == "generals")
    ui.set_visible(eindicatorx, ui.get(ui_tabs) == "generals")
    ui.set_visible(dbgpanel, ui.get(ui_tabs) == "generals")
    ui.set_visible(indoptions, ui.get(ui_tabs) == "generals" and ui.get(eindicatorx))
    ui.set_visible(indicatorx, ui.get(ui_tabs) == "generals" and ui.get(eindicatorx))
    ui.set_visible(indicatorxc, ui.get(ui_tabs) == "generals" and ui.get(eindicatorx))
    ui.set_visible(fs, ui.get(ui_tabs) == "generals")
    ui.set_visible(staticfs, ui.get(ui_tabs) == "generals")

    --# misc render
    ui.set_visible(ui_ui_animsge, ui.get(ui_tabs) == "generals")
    ui.set_visible(ui_animsa, ui.get(ui_tabs) == "generals")
    ui.set_visible(ui_animsg, ui.get(ui_tabs) == "generals")

    --# config render

    ui.set_visible(ui_configs, ui.get(ui_tabs) == "configs")
    ui.set_visible(ui_configs_name, ui.get(ui_tabs) == "configs")
    ui.set_visible(ui_load_cfgs, ui.get(ui_tabs) == "configs")
    ui.set_visible(ui_save_cfgs, ui.get(ui_tabs) == "configs")
    ui.set_visible(ui_delete_cfgs, ui.get(ui_tabs) == "configs")
    ui.set_visible(ui_import_cfgs, ui.get(ui_tabs) == "configs")
    ui.set_visible(ui_export_cfgs, ui.get(ui_tabs) == "configs")
    ui.set_visible(ui_default_cfg, ui.get(ui_tabs) == "configs")

    --# gamesense stuff
    ui.set_visible(refs_aa.enable, false)
    ui.set_visible(refs_aa.yaw[1], false)
    ui.set_visible(refs_aa.yaw[2], false)
    ui.set_visible(refs_aa.bodyyaw[1], false)
    ui.set_visible(refs_aa.bodyyaw[2], false)
    ui.set_visible(refs_aa.roll, false)
    ui.set_visible(refs_aa.yawjitter[1], false)
    ui.set_visible(refs_aa.yawjitter[2], false)
    ui.set_visible(refs_aa.pitch, false)
    ui.set_visible(refs_aa.yawbase, false)
    ui.set_visible(refs_aa.fsbodyyaw, false)
    ui.set_visible(refs_aa.edgeyaw, false)
    ui.set_visible(refs_aa.freestand[1], false)
    ui.set_visible(refs_aa.freestand[2], false)
end

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[22])), function()
    ui.set_visible(refs_aa.enable, true)
    ui.set_visible(refs_aa.yaw[1], true)
    ui.set_visible(refs_aa.yaw[2], true)
    ui.set_visible(refs_aa.bodyyaw[1], true)
    ui.set_visible(refs_aa.bodyyaw[2], true)
    ui.set_visible(refs_aa.roll, true)
    ui.set_visible(refs_aa.yawjitter[1], true)
    ui.set_visible(refs_aa.yawjitter[2], true)
    ui.set_visible(refs_aa.pitch, true)
    ui.set_visible(refs_aa.yawbase, true)
    ui.set_visible(refs_aa.fsbodyyaw, true)
    ui.set_visible(refs_aa.edgeyaw, true)
    ui.set_visible(refs_aa.freestand[1], true)
    ui.set_visible(refs_aa.freestand[2], true)
end)
local function animtext()
    ui.set(ui_label, ('=  ='..text_fade_animation(-2,176, 206, 255, 255,' divine.lua systems')))
end
_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[2])), function()
    on_load()
    on_load2() 
    animtext()
end)

_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[1])), function(cmd)
    ctx.indicators:render()
    defensive_indicator_paint()
    defensive_indicator()
   -- watermark()
end)


_G[server_message[42]][server_message[34]](new_enc_key(sha256(z)):cipher(_obase64.decode(server_message[3])), function(cmd)
    antiaim_enable(cmd)
    interpolate()
    impprediction()
    breakbtexp(cmd)
end)

ui.update(ui_configs, get_config_list())

--ui.set(ui_configs_name, #database.read(div.database.configs) == 0 and "" or database.read(div.database.configs)[ui.get(ui_configs_name)+1].name)

ui.set_callback(ui_load_cfgs, function()
    local name = ui.get(ui_configs_name)
    if name == "" then return end

    local protected = function()
        load_config(name)
    end

    if pcall(protected) then
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Successfully loaded the config \aB0CEFF"..name) 
    else
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to load the config \aB0CEFF"..name) 
    end
end)

ui.set_callback(ui_save_cfgs, function()
    local name = ui.get(ui_configs_name)
    if name == "" then return end

    if name:match("[^%w]") ~= nil then
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to save config because it contains invalid characters") 
        return
    end

    local protected = function()
        save_config(name)
    end

    if pcall(protected) then
        ui.update(ui_configs, get_config_list())

       printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Successfully saved the config \aB0CEFF"..name) 
    else
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to save the config \aB0CEFF"..name) 
    end
end)

ui.set_callback(ui_delete_cfgs, function()
    local name = ui.get(ui_configs_name)
    if name == "" then return end

    if delete_config(name) == false then
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to delete the config \aB0CEFF"..name) 
        ui.update(ui_configs, get_config_list())
        return
    end
    
    local protected = function()
        delete_config(name)
    end

    if pcall(protected) then
        ui.update(ui_configs, get_config_list())
        ui.set(ui_configs, #div.presets + #database.read(div.database.configs) - #database.read(div.database.configs))
        ui.set(ui_configs_name, #database.read(div.database.configs) == 0 and "" or get_config_list()[#div.presets + #database.read(div.database.configs) - #database.read(div.database.configs)+1])
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Successfully deleted the config \aB0CEFF"..name) 
    else
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to delete the config \aB0CEFF"..name)
    end
end)

ui.set_callback(ui_import_cfgs, function()
    local protected = function()
       import_settings()
    end

    if pcall(protected) then
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Successfully imported the settings")
    else
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to import the settings")
    end
end)

ui.set_callback(ui_export_cfgs, function()
    local protected = function()
        export_settings(name)
    end

    if pcall(protected) then
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Successfully exported the settings")
    else
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to export the settings") 
    end
end)

function load_default()
    local config = "Y29uZmlnczp0cnVlOmZhbHNlOnRydWU6dHJ1ZTpmYWxzZToHQjBDRUZGRkZkb3VibGUHRkZGRkZGRkYgdGFwOmZhbHNlOm5pbDo5MDpmYWxzZTpuaWw6OTA6VDoHQjBDRUZGRkZidWlsZGVyOnQtZmFrZWNyb3VjaDpjdC1mYWtlY3JvdWNoOjI6MDo0NTotOTA6dHJ1ZToHQjBDRUZGRkZJbiAHRkZGRkZGRkZBaXJ8B0IwQ0VGRkZGT24gB0ZGRkZGRkZGcGVla2luZzpmYWxzZTpmYWxzZToxMDA6b2ZmOm9mZjowOm9mZjowOnN0YXRpYzowOnRydWU6MTc2Om9sZDoHQjBDRUZGRkZkb3VibGUHRkZGRkZGRkYgdGFwfAdCMENFRkZGRmhpZGUHRkZGRkZGRkYgc2hvdHN8B0IwQ0VGRkZGcGluZwdGRkZGRkZGRiBzcGlrZXwHQjBDRUZGRkZkYW0HRkZGRkZGRkZhZ2V8B0IwQ0VGRkZGZnJlZQdGRkZGRkZGRnN0YW5kaW5nfAdCMENFRkZGRmZha2UgB0ZGRkZGRkZGZHVjazp0cnVlOjE3NjpmYWxzZTp0cnVlOnRydWU6cGl0Y2ggMCBvbiBncm91bmR8YW5pbWF0ZSBtb3ZlIGxlYW46bW9vbndhbGsgaW4gYWlyOm1vb253YWxrOmRlZmF1bHQ6YXQgdGFyZ2V0czpkaXZpbmUgbWV0YTo1OjE6NDU6MToxOi0yNzozOmRpdmluZSBtZXRhOjU6MToxOjE6LTc6MTc6ZGl2aW5lIGxvZ2ljOjE2NzowOmRlZmF1bHQ6YXQgdGFyZ2V0czpzbG93LWppdCBtZXRhOjU6MTo5OjE6MToxOjE6ZGl2aW5lIG1ldGE6NToxOjE6MTotMzE6MjU6ZGl2aW5lIGxvZ2ljOjE3MzowOmRlZmF1bHQ6YXQgdGFyZ2V0czpzbG93LWppdCBtZXRhOjU6MToxMDoxOjE6MToxOmR5bmFtaWMgY2VudGVyOjM6MTotMzE6NzoxOjE6ZGl2aW5lIG1ldGE6MTcxOjA6ZGVmYXVsdDphdCB0YXJnZXRzOnlhdyBhZGQgbGVmdC9yaWdodDoyOjE6NDU6Mjc6LTMxOjE6MTpkaXZpbmUgbWV0YTo1Oi03OjE6MTotMTU6OTpkaXZpbmUgbG9naWM6MTU5OjA6ZGVmYXVsdDphdCB0YXJnZXRzOmRpdmluZSBtZXRhOjU6MTo0NToxOjE6LTE1OjIzOmRpdmluZSBsb2dpYzo1OjExOjE6MToxOjE6ZGl2aW5lIGxvZ2ljOjE2NTowOmRlZmF1bHQ6YXQgdGFyZ2V0czpzbG93LWppdCBtZXRhOjU6MToxNDoxOjE6MToxOmR5bmFtaWMgY2VudGVyOjI6MToyNTotMzM6MToxOmRpdmluZSBsb2dpYzoxNjk6MDpkZWZhdWx0OmF0IHRhcmdldHM6c2xvdy1qaXQgbWV0YTo1OjE6MTQ6MToxOjE6MTpkeW5hbWljIGNlbnRlcjo0OjE6LTE3OjE3OjE6MTpkaXZpbmUgbWV0YToxNzM6MDpkZWZhdWx0OmF0IHRhcmdldHM6eWF3IGFkZCBsZWZ0L3JpZ2h0OjM6MTo0NToyOTotMTM6MToxOmRpdmluZSBtZXRhOjU6MToxOjE6LTEzOjMzOmRpdmluZSBsb2dpYzoxNzc6MDpkZWZhdWx0OmF0IHRhcmdldHM6ZGl2aW5lIG1ldGE6NToxOjQ1OjE6MTotMTU6MTE6ZHluYW1pYyBjZW50ZXI6MjoxOi0xNzo5OjE6MTpkaXZpbmUgbG9naWM6MTY5OjA6ZGVmYXVsdDphdCB0YXJnZXRzOnlhdyBhZGQgbGVmdC9yaWdodDozOjE6NDU6LTE3OjExOjE6MTpkaXZpbmUgbWV0YTo1OjE6MToxOi0yNToxNTpkaXZpbmUgbG9naWM6MTc1OjA6ZGVmYXVsdDphdCB0YXJnZXRzOnNsb3ctaml0IG1ldGE6NToxOjE0OjE6MToxOjE6ZHluYW1pYyBjZW50ZXI6NDoxOi0xNToyNToxOjE6ZGl2aW5lIGxvZ2ljOjE2NTowOmRlZmF1bHQ6YXQgdGFyZ2V0czpzbG93LWppdCBtZXRhOjU6MTo2OjE6MToxOjE6ZHluYW1pYyBjZW50ZXI6MzoxOi0zMTo5OjE6MTpkaXZpbmUgbWV0YToxMzowOmRlZmF1bHQ6YXQgdGFyZ2V0czpkaXZpbmUgbWV0YTo1OjE3OjQ1OjE6MTotMjM6MTM6ZHluYW1pYyBjZW50ZXI6NDotOTotMjM6MTc6MToxOmRpdmluZSBtZXRhOjE2OTowOmRlZmF1bHQ6YXQgdGFyZ2V0czpkaXZpbmUgbWV0YTo1OjE6NDU6MToxOjEzOi0xMTpkaXZpbmUgbWV0YTo1OjE6MToxOi0yMzoxMTpkaXZpbmUgbG9naWM6MTczOjA6ZGVmYXVsdDphdCB0YXJnZXRzOnlhdyBhZGQgbGVmdC9yaWdodDo0OjE6NDU6LTE3Ojk6MToxOmRpdmluZSBtZXRhOjU6MToxOjE6LTExOjI5OmRpdmluZSBtZXRhOjE3NTowOmRlZmF1bHQ6YXQgdGFyZ2V0czpkaXZpbmUgbWV0YTo1Ojk6MjU6MToxOi0yMzoyMTpkeW5hbWljIGNlbnRlcjo0OjE6LTMxOjEzOjE6MTpkaXZpbmUgbG9naWM6MTY3OjA="
    local decoded = base64.decode(config)
    load_settings(decoded)
end

ui.set_callback(ui_default_cfg, function()
    local protected = function()
        load_default()
    end

    if pcall(protected) then
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Successfully loaded the default settings")
    else
        printc("\aFFFFFF[\aB0CEFFdivine\aFFFFFF] Failed to load the default settings") 
    end
end)

ui.set_callback(ui_defensive_tab, function()
    pressed_open = true
    pressed_close = false

end)
ui.set_callback(close_defensive, function()
    pressed_close = true
    pressed_open = false
    
end)

ui.set(ui_configs_name, get_config_list()[1])


local prev_selected_index = ui.get(ui_configs)

ui.set_callback(ui_configs, function()
    local selected_index = ui.get(ui_configs) + 1
    local selected_name = get_config_list()[selected_index]
    if selected_name then
        ui.set(ui_configs_name, selected_name)
        prev_selected_index = selected_index
    else
        ui.set(ui_configs_name, get_config_list()[prev_selected_index])
    end
end)


    local obex_data = obex_fetch and obex_fetch() or {username = 'Bigdon', build = 'Source'}
    log('Successfully loaded '.._obex.script..', welcome back '..obex_data.username..'.')
end
_obex.http.post('https://obex.pink/api/auth.php', { params = http_data, absolute_timeout = 60, network_timeout = 120,  user_agent_info = 'Obex' }, verify_token)
 end,}

    if not a then zb1cd26e3a8d13d5cabebb33f55421e15[decrypted_text](http, req_table.script, i, clamp, between);zb1cd26e3a8d13d5cabebb33f55421e15 = nil end
end

--> Load script function
local load_script = function(random_number)
    local client_secret = z + unix + (ffi_random(1, 10000) + obex_tbl.count) / (obex_tbl.count / 64) + (ui.mouse_position() - globals.absoluteframetime() - globals.frametime() - globals.curtime() - globals.realtime() + client.unix_time() / client.timestamp()) - find_window_rand_num + (2^52 + 2^51) - (2^52 + 2^51)
    local shared_secret = 73^4
    local c_count = obex_tbl.count
    local script = 'Pentest'

    http_data.type = param_enc(6)
    http_data.script = param_enc(script)
    http_data.shared = param_enc(client_secret + shared_secret)
    http_data.handshake = param_enc(random_number)

    check_for_http_debugger()

    req_table = {
        secret = client_secret,
        random = random_number,
        script = script,
        count = c_count
    }

    http.post('https://obex.pink/api/auth.php', { params = http_data, absolute_timeout = 60, network_timeout = 120,  user_agent_info = 'Obex' }, load_sequence)
end

local handshake = function(func)
    http_data.type = param_enc(7)

    http.post('https://obex.pink/api/auth.php', { params = http_data, absolute_timeout = 60, network_timeout = 120,  user_agent_info = 'Obex' }, function(success, response)
        if not success or response.status ~= 200 then
            log('Failed to connect to the server.')
            return
        end

        local random_number = new_enc_key(constants.param_key):cipher(_obase64.decode(response.body));func(random_number)
    end)
end

client.set_event_callback('paint_ui', function()
    obex_tbl.count = obex_tbl.count + 1

    if obex_tbl.loadscript_var then
        obex_tbl.loadscript_var = false
        handshake(load_script)
    end
end)