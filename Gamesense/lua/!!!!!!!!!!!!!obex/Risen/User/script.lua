-- only retards change this links
print('https://discord.gg/b37eKFbkPE <- scriptleaks new server')
-- https://discord.gg/b37eKFbkPE <- scriptleaks new server
LPH_JIT = function(...) return ... end
LPH_JIT_MAX = function(...) return ... end
LPH_NO_VIRTUALIZE = function(...) return ... end

local bit={rol=bit.rol,rshift=bit.rshift,ror=bit.ror,bswap=bit.bswap,bxor=bit.bxor,bor=bit.bor,arshift=bit.arshift,bnot=bit.bnot,tobit=bit.tobit,lshift=bit.lshift,tohex=bit.tohex,band=bit.band}local client={world_to_screen=client.world_to_screen,current_threat=client.current_threat,draw_circle_outline=client.draw_circle_outline,userid_to_entindex=client.userid_to_entindex,draw_gradient=client.draw_gradient,set_event_callback=client.set_event_callback,screen_size=client.screen_size,trace_bullet=client.trace_bullet,unix_time=client.unix_time,color_log=client.color_log,reload_active_scripts=client.reload_active_scripts,scale_damage=client.scale_damage,get_cvar=client.get_cvar,key_state=client.key_state,create_interface=client.create_interface,random_int=client.random_int,latency=client.latency,set_clan_tag=client.set_clan_tag,find_signature=client.find_signature,log=client.log,fire_event=client.fire_event,delay_call=client.delay_call,timestamp=client.timestamp,draw_indicator=client.draw_indicator,draw_circle=client.draw_circle,draw_line=client.draw_line,draw_rectangle=client.draw_rectangle,trace_line=client.trace_line,draw_text=client.draw_text,request_full_update=client.request_full_update,register_esp_flag=client.register_esp_flag,get_model_name=client.get_model_name,camera_position=client.camera_position,error_log=client.error_log,visible=client.visible,exec=client.exec,random_float=client.random_float,set_cvar=client.set_cvar,draw_debug_text=client.draw_debug_text,draw_hitboxes=client.draw_hitboxes,eye_position=client.eye_position,update_player_list=client.update_player_list,camera_angles=client.camera_angles,real_latency=client.real_latency,unset_event_callback=client.unset_event_callback,system_time=client.system_time}local config={load=config.load,import=config.import,export=config.export}local database={read=database.read,write=database.write,flush=database.flush}local entity={get_local_player=entity.get_local_player,is_enemy=entity.is_enemy,get_bounding_box=entity.get_bounding_box,get_all=entity.get_all,set_prop=entity.set_prop,get_player_weapon=entity.get_player_weapon,get_steam64=entity.get_steam64,hitbox_position=entity.hitbox_position,get_player_resource=entity.get_player_resource,get_esp_data=entity.get_esp_data,is_dormant=entity.is_dormant,get_player_name=entity.get_player_name,get_game_rules=entity.get_game_rules,get_classname=entity.get_classname,get_origin=entity.get_origin,get_prop=entity.get_prop,new_prop=entity.new_prop,get_players=entity.get_players,is_alive=entity.is_alive}local globals={frametime=globals.frametime,absoluteframetime=globals.absoluteframetime,chokedcommands=globals.chokedcommands,commandack=globals.commandack,oldcommandack=globals.oldcommandack,tickcount=globals.tickcount,framelerp=globals.framelerp,lastoutgoingcommand=globals.lastoutgoingcommand,curtime=globals.curtime,mapname=globals.mapname,tickinterval=globals.tickinterval,framecount=globals.framecount,realtime=globals.realtime,maxplayers=globals.maxplayers}local json={encode_invalid_numbers=json.encode_invalid_numbers,null=json.null,encode_sparse_array=json.encode_sparse_array,stringify=json.stringify,encode_number_precision=json.encode_number_precision,encode_max_depth=json.encode_max_depth,decode_invalid_numbers=json.decode_invalid_numbers,parse=json.parse,decode_max_depth=json.decode_max_depth}local panorama={loadstring=panorama.loadstring,open=panorama.open}local plist={get=plist.get,set=plist.set}local renderer={blur=renderer.blur,load_svg=renderer.load_svg,world_to_screen=renderer.world_to_screen,circle_outline=renderer.circle_outline,rectangle=renderer.rectangle,gradient=renderer.gradient,circle=renderer.circle,text=renderer.text,line=renderer.line,load_jpg=renderer.load_jpg,load_png=renderer.load_png,triangle=renderer.triangle,measure_text=renderer.measure_text,load_rgba=renderer.load_rgba,indicator=renderer.indicator,texture=renderer.texture}local ui={new_slider=ui.new_slider,new_combobox=ui.new_combobox,reference=ui.reference,set_visible=ui.set_visible,new_textbox=ui.new_textbox,new_color_picker=ui.new_color_picker,new_button=ui.new_button,mouse_position=ui.mouse_position,new_listbox=ui.new_listbox,new_label=ui.new_label,is_menu_open=ui.is_menu_open,new_hotkey=ui.new_hotkey,set=ui.set,update=ui.update,menu_size=ui.menu_size,name=ui.name,menu_position=ui.menu_position,set_callback=ui.set_callback,new_multiselect=ui.new_multiselect,new_checkbox=ui.new_checkbox,new_string=ui.new_string,get=ui.get}local math={ceil=math.ceil,tan=math.tan,log10=math.log10,randomseed=math.randomseed,cos=math.cos,sinh=math.sinh,random=math.random,huge=math.huge,pi=math.pi,max=math.max,atan2=math.atan2,ldexp=math.ldexp,floor=math.floor,sqrt=math.sqrt,deg=math.deg,atan=math.atan,fmod=math.fmod,acos=math.acos,pow=math.pow,abs=math.abs,min=math.min,sin=math.sin,frexp=math.frexp,log=math.log,tanh=math.tanh,exp=math.exp,modf=math.modf,cosh=math.cosh,asin=math.asin,rad=math.rad}local table={maxn=table.maxn,clear=table.clear,move=table.move,pack=table.pack,foreach=table.foreach,sort=table.sort,remove=table.remove,foreachi=table.foreachi,unpack=table.unpack,getn=table.getn,concat=table.concat,insert=table.insert}local string={find=string.find,rep=string.rep,format=string.format,len=string.len,gsub=string.gsub,gmatch=string.gmatch,match=string.match,reverse=string.reverse,byte=string.byte,char=string.char,upper=string.upper,lower=string.lower,sub=string.sub}

local script_db = {
    lua_name = 'risen',
    last_update = '28.01',
    menu_dir = { 'AA', 'Anti-aimbot angles' },
    obex_builds = {
        ['User'] = 'live',
        ['Beta'] = 'beta',
        ['Debug'] = 'debug',
        ['Private'] = 'nightly'
    },
    lua_versions = {
        live = 'live',
        beta = 'beta',
        debug = 'debug',
        nightly = 'nightly'
    },
    handlers = {}
}

script_db.handlers.console_message = function(color, message)
    client.color_log(255, 255, 255, '[\0')
    client.color_log(color[1], color[2], color[3], script_db.lua_name .. '\0')
    client.color_log(255, 255, 255, '] \0')

    for i = 1, #message do
        local text = message[i]

        local color_value = { 255, 255, 255 }

        if text[2] then
            color_value = color
        end

        client.color_log(color_value[1], color_value[2], color_value[3], (text[1] .. '\0'))
    end

    client.color_log(color[1], color[2], color[3], ' ')
end

do
    local librarys = {
        { req_name = 'gamesense/easing', link = 'https://gamesense.pub/forums/viewtopic.php?id=22920' },
        { req_name = 'gamesense/images', link = 'https://gamesense.pub/forums/viewtopic.php?id=22917' },
        { req_name = 'gamesense/antiaim_funcs', link = 'https://gamesense.pub/forums/viewtopic.php?id=29665' },
        { req_name = 'gamesense/http', link = 'https://gamesense.pub/forums/viewtopic.php?id=19253' },
        { req_name = 'gamesense/clipboard', link = 'https://gamesense.pub/forums/viewtopic.php?id=28678' },
        { req_name = 'gamesense/inspect', link = 'https://gamesense.pub/forums/viewtopic.php?id=16776' },
        { req_name = 'gamesense/surface', link = 'https://gamesense.pub/forums/viewtopic.php?id=18793' },
        { req_name = 'gamesense/csgo_weapons', link = 'https://gamesense.pub/forums/viewtopic.php?id=18807' },
        { req_name = 'gamesense/trace', link = 'https://gamesense.pub/forums/viewtopic.php?id=32949' }
    }

    local not_subscribed = 0

    for i, key in pairs(librarys) do
        local status, error = pcall(require, key.req_name)

        if not status then
            script_db.handlers.console_message({ 138, 95, 237 }, {
                { 'Missing library: ' },
                { key.req_name, true },
                { ', make sure you are subscribed to it [link: ' },
                { key.link, true },
                { ']' }
            })

            not_subscribed = not_subscribed + 1
        end
    end

    if not_subscribed ~= 0 then
        error(('[%s] Missing librarys'):format(script_db.lua_name:upper()), 2)
    end
end

local vector = require('vector')
local easing = require('gamesense/easing')
local images = require('gamesense/images')
local anti_aim_f = require('gamesense/antiaim_funcs')
local http = require('gamesense/http')
local clipboard = require('gamesense/clipboard')
local inspect = require('gamesense/inspect')
local surface = require('gamesense/surface')
local csgo_weapons = require('gamesense/csgo_weapons')
local trace_lib = require('gamesense/trace')
local clipping = (function() local a=require'ffi'local b=client.create_interface("vguimatsurface.dll","VGUI_Surface031")local c=a.cast("uintptr_t**",b)local d=a.cast("void(__thiscall*)(void*, int&, int&, int&, int&)",c[0][146])local e=a.cast("void(__thiscall*)(void*, int, int, int, int)",c[0][147])local f=a.cast('char*',b)local g=a.cast('bool*',f+0x280)local h=function()local i,j,k,l=a.new("int[1]"),a.new("int[1]"),a.new("int[1]"),a.new("int[1]")g[0]=true;d(c,i,j,k,l)g[0]=false;return{x=i[0],y=j[0],xw=k[0],yh=l[0]}end;local m=function(i,j,k,l)g[0]=true;e(c,i,j,i+k+1,j+l+1)g[0]=false end;local n={}n.GetClipRect=h;n.SetClipRect=m;return n end)()

local smoothy = {
    to_pairs = {
        vector = { 'x', 'y', 'z' },
        imcolor =  { 'r', 'g', 'b', 'a' }
    },

    get_type = LPH_NO_VIRTUALIZE(function(self, value)
        local val_type = type(value)

        if val_type == 'cdata' and value.x and value.y and value.z then
            return 'vector'
        end

        if val_type == 'userdata' and value.__type then
            return string.lower(value.__type.name)
        end

        return val_type
    end),

    copy_tables = LPH_NO_VIRTUALIZE(function(self, destination, keysTable, valuesTable)
        valuesTable = valuesTable or keysTable
        local mt = getmetatable(keysTable)

        if mt and getmetatable(destination) == nil then
            setmetatable(destination, mt)
        end

        for k, v in pairs(keysTable) do
            if type(v) == 'table' then
                destination[k] = self:copy_tables({}, v, valuesTable[k])
            else
                local value = valuesTable[k]

                if type(value) == 'boolean' then
                    value = value and 1 or 0
                end

                destination[k] = value
            end
        end

        return destination
    end),

    resolve = LPH_NO_VIRTUALIZE(function(self, easing_fn, previous, new, clock, duration)
        if type(new) == 'boolean' then new = new and 1 or 0 end
        if type(previous) == 'boolean' then previous = previous and 1 or 0 end

        local previous = easing_fn(clock, previous, new - previous, duration)

        if type(new) == 'number' then
            if math.abs(new - previous) <= .001 then
                previous = new
            end

            if previous % 1 < .0001 then
                previous = math.floor(previous)
            elseif previous % 1 > .9999 then
                previous = math.ceil(previous)
            end
        end

        return previous
    end),

    perform_easing = LPH_NO_VIRTUALIZE(function(self, ntype, easing_fn, previous, new, clock, duration)
        if self.to_pairs[ntype] then
            for _, key in ipairs(self.to_pairs[ntype]) do
                previous[key] = self:perform_easing(
                    type(v), easing_fn,
                    previous[key], new[key],
                    clock, duration
                )
            end

            return previous
        end

        if ntype == 'table' then
            for k, v in pairs(new) do
                previous[k] = previous[k] or v
                previous[k] = self:perform_easing(
                    type(v), easing_fn,
                    previous[k], v,
                    clock, duration
                )
            end

            return previous
        end

        return self:resolve(easing_fn, previous, new, clock, duration)
    end),

    new = LPH_NO_VIRTUALIZE(function(this, default, easing_fn)
        if type(default) == 'boolean' then
            default = default and 1 or 0
        end

        local mt = { }
        local mt_data = {
            value = default or 0,
            easing = easing_fn or function(t, b, c, d)
                return c * t / d + b
            end
        }

        function mt.update(self, duration, value, easing)
            if type(value) == 'boolean' then
                value = value and 1 or 0
            end

            local clock = globals.frametime()
            local duration = duration or .15
            local value_type = this:get_type(value)
            local target_type = this:get_type(self.value)

            assert(value_type == target_type, string.format('type mismatch. expected %s (received %s)', target_type, value_type))

            if self.value == value then
                return value
            end

            if clock <= 0 or clock >= duration then
                if target_type == 'imcolor' or target_type == 'vector' then
                    self.value = value:clone()
                elseif target_type == 'table' then
                    this:copy_tables(self.value, value)
                else
                    self.value = value
                end
            else
                local easing = easing or self.easing

                self.value = this:perform_easing(
                    target_type, easing,
                    self.value, value,
                    clock, duration
                )
            end

            return self.value
        end

        return setmetatable(mt, {
            __metatable = false,
            __call = mt.update,
            __index = mt_data
        })
    end),

    new_interp = LPH_NO_VIRTUALIZE(function(this, initial_value)
        return setmetatable({
            previous = initial_value or 0
        }, {
            __call = function(self, new_value, mul)
                local mul = mul or 1
                local tickinterval = globals.tickinterval() * mul
                local difference = math.abs(new_value - self.previous)

                if difference > 0 then
                    local time = math.min(tickinterval, globals.frametime()) / tickinterval
                    self.previous = self.previous + time * (new_value - self.previous)
                else
                    self.previous = new_value
                end

                self.previous = (self.previous % 1 < .0001) and 0 or self.previous

                return self.previous
            end
        })
    end)
}

script_db.get_info = function(self)
    local info = obex_fetch and obex_fetch() or { username = 'shade', build = 'source', discord = '' }

    self.username = info.username:lower()
    -- self.id = info.discord
    self.discord_id = info.discord
    self.version = self.lua_versions[self.obex_builds[info.build]]
    self.version_to_download = self.version
    self.source = info.build == 'source'
end
script_db:get_info()

script_db.database_key = '[:]' .. script_db.lua_name:upper() .. '[:]123'
-- script_db.database_key = 'tyjtjtjtjtjtjtjfychujbjil'

script_db.database = database.read(script_db.database_key) or {}

script_db.database.configs = script_db.database.configs or {}
script_db.database.antiaim = script_db.database.antiaim or {}
script_db.database.antiaim.antibruteforce = script_db.database.antiaim.antibruteforce or {}
script_db.database.antiaim.dynamic = script_db.database.antiaim.dynamic or {}

script_db.hidden_config = false

script_db.links = {
    notifier = {
        logo = 'https://cdn.discordapp.com/attachments/884455063232348210/1067530497837760632/ierthteyjks.png',
        import = 'https://cdn.discordapp.com/attachments/884455063232348210/1067555080196325426/imdtyjtuyfkfyukage.png',
        export = 'https://cdn.discordapp.com/attachments/884455063232348210/1067555066921353317/tyjtyjage.png',
        delete = ''
    },
    watermark = {
        logo = 'https://cdn.discordapp.com/attachments/884455063232348210/1067533501278204044/ierthteyjks.png'
    },
    popups = {
        logo = 'https://cdn.discordapp.com/attachments/884455063232348210/1067533501278204044/ierthteyjks.png'
    }
}

local notifier = {
    data = {
        queue = {},
        active = {}
    },
    types = {},
    time = {
        long = 6,
        medium = 4,
        short = 3
    },
    max = 5
}

if script_db.source then
    script_db.username = 'admin'
    script_db.version = 'nightly'
    script_db.version_to_download = script_db.lua_versions.debug

    client.delay_call(.5, function()
        notifier.on_load()
    end)
else
    client.exec('clear')

    client.delay_call(.5, function()
        notifier.on_load()
    end)
end

notifier.on_load = function()
    local color_ref = script_db.get_accent_color()

    script_db.handlers.console_message(color_ref, {
        { 'Welcome ' },
        { script_db.username, true },
        { ' [build: ' },
        { script_db.version, true },
        { ']' },
    })

    notifier.add({
        time = 7,
        text = {
            { 'Welcome ' },
            { script_db.username, true },
            { ' [build: ' },
            { script_db.version, true },
            { ']' }
        }
    })

    notifier.add({
        time = 7,
        text = {
            { 'Succesfully loaded the ' },
            { 'lua', true }
        }
    })
end

script_db.handlers.handle_error = function(error, icon)
    error = error or { { '' } }
    icon = icon or 'logo'

    notifier.add({
        color = { r = 255, g = 0, b = 0, a = 255 },
        time = notifier.time.long,
        text = error,
        icon = icon
    })

    script_db.handlers.console_message({ 255, 0, 0 }, error)
end

local antiaim = {}

local experimental_data = function()
    return json.parse([[{
        "terrorist": {
            "exploit": {
                "stand": {
                    "left": {
                        "yaw": 8,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 62,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 8,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 62,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "move": {
                    "left": {
                        "yaw": 9,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 74,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 9,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 74,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "crouch": {
                    "left": {
                        "yaw": -7,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 43,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    },
                    "right": {
                        "yaw": 26,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 43,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    }
                },
                "slowwalk": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 18,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "air crouch": {
                    "left": {
                        "yaw": -10,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 40,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 40,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "air": {
                    "left": {
                        "yaw": -25,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 14,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 25,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 14,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                }
            },
            "fakelag": {
                "stand": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 23,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 28,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 23,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                },
                "move": {
                    "left": {
                        "yaw": -35,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 9,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 39,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 9,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                },
                "crouch": {
                    "left": {
                        "yaw": 4,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 61,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    },
                    "right": {
                        "yaw": 16,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 61,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    }
                },
                "slowwalk": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 18,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "air crouch": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 29,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 28,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 29,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                },
                "air": {
                    "left": {
                        "yaw": -15,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 32,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 17,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 32,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                }
            }
        },
        "counter terrorist": {
            "exploit": {
                "stand": {
                    "left": {
                        "yaw": 8,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 62,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 8,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 62,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "move": {
                    "left": {
                        "yaw": 9,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 74,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 9,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 74,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "crouch": {
                    "left": {
                        "yaw": -7,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 43,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    },
                    "right": {
                        "yaw": 26,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 43,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    }
                },
                "slowwalk": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 18,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "air crouch": {
                    "left": {
                        "yaw": -10,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 40,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 40,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "air": {
                    "left": {
                        "yaw": -25,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 14,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 25,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 14,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                }
            },
            "fakelag": {
                "stand": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 23,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 28,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 23,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                },
                "move": {
                    "left": {
                        "yaw": -35,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 9,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 39,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 9,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                },
                "crouch": {
                    "left": {
                        "yaw": 11,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 58,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    },
                    "right": {
                        "yaw": 17,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 58,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 56
                    }
                },
                "slowwalk": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    },
                    "right": {
                        "yaw": 18,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 42,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 59
                    }
                },
                "air crouch": {
                    "left": {
                        "yaw": -14,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 29,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 28,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 29,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                },
                "air": {
                    "left": {
                        "yaw": -15,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 32,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    },
                    "right": {
                        "yaw": 17,
                        "yaw_jitter": "Center",
                        "yaw_jitter_value": 32,
                        "body_yaw": "Jitter",
                        "body_yaw_value": 0,
                        "freestanding_body_yaw": false,
                        "fake_limit": 60
                    }
                }
            }
        }
    }]])
end

local FN = {}

function math.clamp(value, min, max)
    return math.min(max, math.max(min, value))
end

function table.contains(table, value)
    if table == nil then
        return false
    end

    if type(table) == 'number' then
        table = ui.get(table)
    end

    for i = 0, #table do
        if table[i] == value then
            return true, i
        end
    end

    return false
end

FN.lerp = LPH_NO_VIRTUALIZE(function(a, b, percentage)
    return a + (b - a) * percentage
end)

FN.colored_text = LPH_NO_VIRTUALIZE(function(text, color)
    return ('\a%02x%02x%02x%02x%s'):format(color[1], color[2], color[3], color[4], text)
end)

FN.colored_single_text = function(color1, text, color2)
    return ('\a%02x%02x%02x%02x%s\a%02x%02x%02x%02x'):format(color1[1], color1[2], color1[3], color1[4], text, color2[1], color2[2], color2[3], color2[4])
end

FN.gradient_text_anim = LPH_NO_VIRTUALIZE(function(text, color1, color2, speed, delay, invert)
    local r1, g1, b1, a1 = unpack(color1)
    local r2, g2, b2, a2 = unpack(color2)

    speed = speed or 1
    delay = delay or 0
    delay = delay + 3

    local return_text = {}

    local text_lenght = string.len(text)

    local curtime = globals.curtime()
    local highlight_fraction = invert and -(curtime * speed) % delay - 2 or (curtime * speed) % delay - 2

    for i = 1, text_lenght do
        local character = string.sub(text, i, i)
        local character_fraction = (i - 1) / (text_lenght - 1)

        local highlight_delta = character_fraction - highlight_fraction

        if highlight_delta > 1 then
            highlight_delta = 1 * 2 - highlight_delta
        end

        local r, g, b, a = r1, g1, b1, a1

        local r_fraction = r2 - r
        local g_fraction = g2 - g
        local b_fraction = b2 - b
        local a_fraction = a2 - a

        if highlight_delta >= 0 and highlight_delta <= 1 then
            r = r + r_fraction * highlight_delta
            g = g + g_fraction * highlight_delta
            b = b + b_fraction * highlight_delta
            a = a + a_fraction * highlight_delta
        end

        return_text[i] = string.format('\a%02x%02x%02x%02x%s', r, g, b, a, character)
    end

    return table.concat(return_text), highlight_fraction
end)

FN.color_swap = LPH_NO_VIRTUALIZE(function(color1, color2, weight)
    weight = math.clamp(weight, 0, 1)

    return {
        FN.lerp(color1[1], color2[1], weight), 
        FN.lerp(color1[2], color2[2], weight), 
        FN.lerp(color1[3], color2[3], weight), 
        FN.lerp(color1[4], color2[4], weight)
    }
end)

FN.gradient_text = LPH_NO_VIRTUALIZE(function(text, color1, color2, fraction, gradient)
    fraction = math.clamp(fraction, 0, 1)

    if fraction == 0 then
        return FN.colored_text(text, color2)
    elseif fraction == 1 then
        return FN.colored_text(text, color1)
    end

    local text_length = string.len(text)

    local return_text = {}

    for i = 1, text_length do
        local start = gradient and ((1 - fraction) - (text_length - i) / (text_length - 1)) + (1 - fraction) or i - fraction * text_length
        local weight = math.clamp(start, 0, 1)
        local color = FN.color_swap(color1, color2, weight)

        return_text[i] = FN.colored_text(string.sub(text, i, i), color)
    end

    return table.concat(return_text)
end)

FN.can_shoot = function(ent)
    ent = ent or entity.get_local_player()
    local wpn = entity.get_player_weapon(ent)
    local NextPrimaryAttack = entity.get_prop(wpn, 'm_flNextPrimaryAttack')
    return NextPrimaryAttack ~= nil and globals.curtime() >= NextPrimaryAttack
end

FN.set_movement = function(cmd, destination)
    local plocal = entity.get_local_player()
    local move_yaw = vector(vector(entity.get_origin(plocal)):to(destination):angles()).y

    cmd.in_forward = 1
    cmd.in_back = 0
    cmd.in_moveleft = 0
    cmd.in_moveright = 0
    cmd.in_speed = 0
    cmd.forwardmove = 800
    cmd.sidemove = 0
    cmd.move_yaw = move_yaw
end

FN.extrapolate_position = function(player, pos, ticks, inverted)
    local velocity = vector(entity.get_prop(player, 'm_vecVelocity'))

    local tickinterval = globals.tickinterval()

    for i = 0, ticks do
        pos.x = pos.x + (inverted and -(velocity.x * tickinterval) or (velocity.x * tickinterval))
        pos.y = pos.y + (inverted and -(velocity.y * tickinterval) or (velocity.y * tickinterval))
        pos.z = pos.z + (inverted and -(velocity.z * tickinterval) or (velocity.z * tickinterval))
    end

    return pos
end

FN.check_weapons = function(classname_table)
    local plocal = entity.get_local_player()
    if not plocal then return false end
    local weapon_id = entity.get_player_weapon(plocal)
    if not weapon_id then return false end
    local weapon_name = entity.get_classname(weapon_id)
    for i, value in pairs(classname_table) do
        if weapon_name == value then return true end
    end
    return false
end

FN.ClosestPointOnRay = function(target, rayStart, rayEnd)
    local to = target - rayStart
    local dir = rayEnd - rayStart
    local length = dir:length()
    dir = dir:normalized()

    local rangeAlong = dir:dot(to)

    if rangeAlong < .0 then
        return rayStart
    end

    if rangeAlong > length then
        return rayEnd
    end

    return rayStart + dir * vector(rangeAlong, rangeAlong, rangeAlong)
end

FN.extend_vector = function(pos, length, angle) 
    local rad = angle * math.pi / 180
    return vector(pos.x + (math.cos(rad) * length), pos.y + (math.sin(rad) * length), pos.z)
end

FN.get_players = function(include_enemies, include_teammates, include_localplayer, include_dormant, include_invisible)
    local result = {}
    local player_resource = entity.get_player_resource()
    local maxplayers = globals.maxplayers()

    for player = 1, maxplayers do
        if entity.get_prop(player_resource, 'm_bConnected', player) ~= 1 then
            goto skip
        end

        if entity.get_prop(player_resource, 'm_bAlive', player) ~= 1 then
            goto skip
        end

        if not include_localplayer and player == entity.get_local_player() then
            goto skip
        end

        if include_teammates then
            if not include_enemies and entity.is_enemy(player) then
                goto skip
            end
        elseif not entity.is_enemy(player) then
            goto skip
        end

        if not include_dormant and entity.is_dormant(player) then
            goto skip
        end

        if not include_invisible and select(5, entity.get_bounding_box(player)) <= 0 then
            goto skip
        end

        table.insert(result, player)

        ::skip::
    end

    return result
end

FN.get_nearest_player = function(players)
    local lp_eyepos = vector(client.eye_position())
    local lp_camera_angles = vector(client.camera_angles())

    local calc = function(xdelta, ydelta)
        if xdelta == 0 and ydelta == 0 then
            return 0
        end

        return math.deg(math.atan2(ydelta, xdelta))
    end

    local bestenemy = nil
    local fov = 180

    for i = 1, #players do
        local player = players[i]

        local player_origin = vector(entity.get_origin(player))

        local cur_fov = math.abs(
            anti_aim_f.normalize_angle(
                calc(lp_eyepos.x - player_origin.x, lp_eyepos.y - player_origin.y) - lp_camera_angles.y + 180
            )
        )

        if cur_fov < fov then
            fov = cur_fov
            bestenemy = player
        end
    end

    return bestenemy
end

FN.gram_create = function(value, count)
    local gram = { }
    for i = 1, count do
        gram[i] = value
    end
    return gram
end

FN.gram_update = LPH_NO_VIRTUALIZE(function(tab, value, forced)
    local new_tab = tab
    if forced or new_tab[#new_tab] ~= value then
        table.insert(new_tab, value)
        table.remove(new_tab, 1)
    end
    tab = new_tab
end)

local UI = {
    list = {},
    values = {
        amount = 0
    }
}

UI.new = function(args, ...)
    assert(args.type, 'Type is nil')
    assert(args.name, 'Name is nil')
    assert(type(args.index) == 'string', 'Invalid type of index')

    UI.list[args.index] = {}

    args.location = args.location or script_db.menu_dir

    UI.values.amount = UI.values.amount + 1

    local label_mode = false

    local tab, container = args.location[1], args.location[2]

    local name = args.name

    if not label_mode and args.name == '' then
        name = '\n' .. name
    end

    local element_name = label_mode and ('\n%s%d'):format(script_db.lua_name, UI.values.amount) or name

    local funcs = {
        ['checkbox'] = function(name, element_name)
            local item, label
            item = ui.new_checkbox(tab, container, element_name)
            if label_mode and name ~= '' then
                label = ui.new_label(tab, container, name)
            end
            return item, label
        end,
        ['combobox'] = function(name, element_name, args)
            local item, label
            if label_mode and name ~= '' then
                label = ui.new_label(tab, container, name)
            end
            item = ui.new_combobox(tab, container, element_name, args)
            return item, label
        end,
        ['multiselect'] = function(name, element_name, args)
            local item, label
            if label_mode and name ~= '' then
                label = ui.new_label(tab, container, name)
            end
            item = ui.new_multiselect(tab, container, element_name, args)
            return item, label 
        end,
        ['hotkey'] = function(name, element_name, inline, default_key)
            local item, label
            if inline or not label_mode then
                item = ui.new_hotkey(tab, container, element_name, inline, default_key or 0)
            else
                label = ui.new_label(tab, container, name)
                item = ui.new_hotkey(tab, container, element_name, true, default_key or 0)
            end
            return item, label 
        end,
        ['slider'] = function(name, element_name, min, max, init_value, show_tooltip, unit, scale, tooltips)
            show_tooltip = show_tooltip or true
            scale = scale or 1
            local item, label
            if label_mode and name ~= '' then
                label = ui.new_label(tab, container, name)
            end
            item = ui.new_slider(tab, container, element_name, min, max, init_value, show_tooltip, unit, scale, tooltips)
            return item, label  
        end,
        ['color_picker'] = function(name, element_name, accent, inline)
            local r, g, b, a = unpack(accent)
            local item, label
            if inline or not label_mode then
                item = ui.new_color_picker(tab, container, element_name, r, g, b, a)
            else
                label = ui.new_label(tab, container, name)
                item = ui.new_color_picker(tab, container, element_name, r, g, b, a)
            end
            return item, label
        end
    }

    UI.list[args.index].name = args.name

    UI.list[args.index].element, UI.list[args.index].label = funcs[args.type](name, element_name, ...)

    UI.list[args.index].flags = args.flags or ''

    UI.list[args.index].visible_state = function()
        if not args.conditions then
            return true
        end

        for k, v in pairs(args.conditions) do
            if not v() then
                return false
            end
        end

        return true
    end

    ui.set_callback(UI.list[args.index].element, UI.visibility_handle)

    UI.visibility_handle()
end

UI.get = function(index)
    return UI.list[index] and ui.get(UI.list[index].element)
end

UI.get_element = function(index)
    return UI.list[index] and UI.list[index].element
end

UI.contains = function(index, value)
    index = UI.get(index)

    if type(index) ~= 'table' then
        return false
    end

    for i = 1, #index do
        if index[i] == value then
            return true
        end
    end

    return false
end

UI.visibility_handle = function()   
    for k, v in pairs(UI.list) do
        local visible = v.visible_state()

        ui.set_visible(v.element, visible)

        if v.label then
            ui.set_visible(v.label, visible)
        end
    end
end

script_db.configs = {}

http.get('https://pastebin.com/raw/pB7wU9j4', function(s, r)
    if s and r.status == 200 then
        script_db.configs.default = r.body
    end
end)

local configs = {
    code = 'l29W5AU6JX1CEVIjmNFZM4xv+twdQsHLBrYG3S7h/zkPpbyoaneKqcDR)Tigf0u8'
}

configs.encode = function(data)
    return ((data:gsub('.', function(x) 
        local r, b = '', x:byte()
        for i = 8, 1, -1 do r = r .. (b % 2 ^ i - b % 2 ^ (i - 1) > 0 and '1' or '0') end
        return r;
    end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c = 0
        for i = 1, 6 do c = c + (x:sub(i, i) == '1' and 2 ^ (6 - i) or 0) end
        return configs.code:sub(c + 1, c + 1)
    end) .. ({ '', '==', '=' })[ #data % 3 + 1 ])
end

configs.decode = function(data)
    data = string.gsub(data, '[^' .. configs.code .. '=]', '')
    return (data:gsub( '.', function(x)
        if (x == '=') then return '' end
        local r, f = '', (configs.code:find(x) - 1)
        for i = 6, 1, -1 do r = r .. (f % 2 ^ i - f % 2 ^ (i - 1) > 0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c = 0
        for i = 1, 8 do c = c + (x:sub(i, i) == '1' and 2 ^ (8 - i) or 0) end
        return string.char(c)
    end))
end

script_db.hidden_name = configs.encode(':hidden_config:')

configs.export = function(to_clipboard, return_settings, hidden, find)
    local new_table = {}

    new_table.settings = {}

    if find and find ~= '' and type(find) == 'string' then
        for k, v in pairs(UI.list) do
            if k:find(find) ~= nil then
                if v.flags == 'c' then
                    new_table.settings[k] = { ui.get(UI.list[k].element) }
                elseif v.flags == '-' then
                    goto skip
                else
                    new_table.settings[k] = ui.get(UI.list[k].element)
                end
    
                ::skip::
            end
        end
    else
        new_table[script_db.hidden_name] = hidden

        for k, v in pairs(UI.list) do
            if v.flags == 'c' then
                new_table.settings[k] = { ui.get(UI.list[k].element) }
            elseif v.flags == '-' then
                goto skip
            else
                new_table.settings[k] = ui.get(UI.list[k].element)
            end

            ::skip::
        end
    end

    local settings_final = configs.encode(json.stringify(new_table))

    if to_clipboard then
        clipboard.set(settings_final)
    end

    if return_settings then
        return settings_final
    end
end

configs.import = function(config, find)
    local data = json.parse(configs.decode(config))

    if find and find ~= '' and type(find) == 'string' then
        for k, v in pairs(UI.list) do
            if k:find(find) ~= nil then
                for item, value in pairs(data.settings) do
                    local data_strings = {}

                    for str in string.gmatch(item, '([^:]+)') do
                        data_strings[#data_strings + 1] = string.gsub(str, '\n', '')
                    end

                    local list_strings = {}

                    for str in string.gmatch(k, '([^:]+)') do
                        list_strings[#list_strings + 1] = string.gsub(str, '\n', '')
                    end

                    if list_strings[#list_strings] == data_strings[#data_strings] then
                        ui.set(UI.get_element(k), value)
                    end
                end
            end
        end
    else
        for item, value in pairs(data.settings) do
            if UI.list[item].flags == 'c' then
                ui.set(UI.get_element(item), value[1], value[2], value[3], value[4])
            else
                ui.set(UI.get_element(item), value)
            end
        end

        script_db.hidden_config = data[script_db.hidden_name]
    end
end

configs.handle = {}

configs.handle.export = function(to_clipboard, return_settings, hidden, find, text, error_text)
    if script_db.hidden_config and not hidden then
        script_db.handlers.handle_error({
            { 'You can\'t export ' },
            { 'hidden', true },
            { ' settings as not ' },
            { 'hidden', true }
        })
        return
    end
    
    local status, returned_value = pcall(configs.export, to_clipboard, return_settings, hidden, find)

    text = text or { { '' } }
    error_text = error_text or { { '' } }
    
    if status then
        notifier.add({
            time = notifier.time.long,
            text = text,
            icon = 'export'
        })

        script_db.handlers.console_message(script_db.get_accent_color(), text)

        if return_settings then
            return returned_value
        end
    else
        script_db.handlers.handle_error(error_text, 'export')
    end
end

configs.handle.import = function(config, find, text, error_text)
    local status, error = pcall(configs.import, config, find)

    text = text or { { '' } }
    error_text = error_text or { { '' } }

    if status then
        notifier.add({
            time = notifier.time.long,
            text = text,
            icon = 'import'
        })

        script_db.handlers.console_message(script_db.get_accent_color(), text)
    else
        script_db.handlers.handle_error(error_text, 'import')
    end
end

local menu = {}

menu.configs = {
    handle = {},
    last_loaded_config = 0
}

menu.configs.handle.create_config = function(name)
    if name == '' then
        script_db.handlers.handle_error({
            { 'You can\'t create ' },
            { 'unnamed', true },
            { ' config' }
        })
        return
    end

    local check_config_names = function()
        local amount = 0

        for key, value in pairs(menu.configs.list) do
            if value:find(name) then
                amount = amount + 1
            end
        end

        return amount
    end

    local amount = check_config_names()

    if amount > 0 then
        name = name .. ('(%d)'):format(amount)
    end

    local protected = function()
        table.insert(menu.configs.list, name)
        ui.update(menu.configs.menu.config_list, menu.configs.list)
    
        script_db.database.configs[#menu.configs.list] = nil--script_db.configs.blank_config
    end

    local status, error = pcall(protected)

    local message = {
        text = {
            { 'Succesfully ' },
            { 'created', true },
            { ' config [' },
            { name, true },
            { ']' }
        },
        error_text = {
            { 'Error while ' },
            { 'creating', true },
            { ' config [' },
            { name, true },
            { ']' }
        }
    }

    if status then
        notifier.add({
            time = notifier.time.long,
            text = message.text
        })

        script_db.handlers.console_message(script_db.get_accent_color(), message.text)
    else
        script_db.handlers.handle_error(message.error_text)
    end
end

menu.configs.handle.save_config = function(item)
    item = item + 1

    if not menu.configs.list[item] then
        script_db.handlers.handle_error({
            { 'You didn\'t ' },
            { 'select', true },
            { ' any config' }
        })
        return
    end

    if item == 1 then
        script_db.handlers.handle_error({
            { 'You can\'t ' },
            { 'override', true },
            { ' default config' }
        })
        return
    end

    local name = menu.configs.list[item]

    local protected = function()
        script_db.database.configs[item] = configs.export(false, true, script_db.hidden_config)
    end

    local status, error = pcall(protected)

    local message = {
        text = {
            { 'Succesfully ' },
            { 'saved', true },
            { ' config [' },
            { name, true },
            { ']' }
        },
        error_text = {
            { 'Error while ' },
            { 'saving', true },
            { ' config [' },
            { name, true },
            { ']' }
        }
    }

    if status then
        notifier.add({
            time = notifier.time.long,
            text = message.text
        })

        script_db.handlers.console_message(script_db.get_accent_color(), message.text)
    else
        script_db.handlers.handle_error(message.error_text)
    end
end

menu.configs.handle.load_config = function(item, last_used)
    item = item + 1

    if not menu.configs.list[item] then
        script_db.handlers.handle_error({
            { 'You didn\'t ' },
            { 'select', true },
            { ' any config' }
        })
        return
    end

    local config = script_db.database.configs[item]

    local name = menu.configs.list[item]

    if name:find('default config') ~= nil then
        name = 'default config'
    end

    if item == 1 then
        menu.configs.last_loaded_config = 0

        if last_used then
            local message = {
                text = {
                    { 'Succesfully ' },
                    { 'loaded', true },
                    { ' your ' },
                    { 'last used', true },
                    { ' config [' },
                    { name, true },
                    { ']' }
                },
                error_text = {
                    { 'Error while ' },
                    { 'loading', true },
                    { ' your ' },
                    { 'last used', true },
                    { ' config [' },
                    { name, true },
                    { ']' }
                }
            }

            configs.handle.import(script_db.configs.default, nil, message.text, message.error_text)
            return
        end

        local message = {
            text = {
                { 'Succesfully ' },
                { 'loaded', true },
                { ' default settings' }
            },
            error_text = {
                { 'Error while ' },
                { 'loading', true },
                { ' default settings' }
            }
        }

        configs.handle.import(script_db.configs.default, nil, message.text, message.error_text)
        return
    end

    if config == nil or config == '' then
        script_db.handlers.handle_error({
            { 'This config [' },
            { name, true },
            { '] is ' },
            { 'blank', true }
        })
        return
    end

    local protected = function()
        configs.import(config)

        if last_used then
            ui.set(menu.configs.menu.config_list, item - 1)
        end
    end

    local status, error = pcall(protected)

    local message = {
        text = {
            { 'Succesfully ' },
            { 'loaded', true },
            { ' config [' },
            { name, true },
            { ']' }
        },
        error_text = {
            { 'Error while ' },
            { 'loading', true },
            { ' config [' },
            { name, true },
            { ']' }
        }
    }

    if last_used then
        message = {
            text = {
                { 'Succesfully ' },
                { 'loaded', true },
                { ' your ' },
                { 'last used', true },
                { ' config [' },
                { name, true },
                { ']' }
            },
            error_text = {
                { 'Error while ' },
                { 'loading', true },
                { ' your ' },
                { 'last used', true },
                { ' config [' },
                { name, true },
                { ']' }
            }
        }
    end

    if status then
        menu.configs.last_loaded_config = item - 1

        notifier.add({
            time = notifier.time.long,
            text = message.text
        })

        script_db.handlers.console_message(script_db.get_accent_color(), message.text)
    else
        script_db.handlers.handle_error(message.error_text)
    end
end

menu.configs.handle.delete_config = function(item)
    item = item + 1

    if not menu.configs.list[item] then
        script_db.handlers.handle_error({
            { 'You didn\'t ' },
            { 'select', true },
            { ' any config' }
        })
        return
    end
    
    if item == 1 then
        script_db.handlers.handle_error({
            { 'You can\'t ' },
            { 'delete', true },
            { ' default config' }
        })
        return
    end

    local name = menu.configs.list[item]

    local protected = function()
        script_db.database.configs[item] = nil
        table.remove(menu.configs.list, item)
        ui.update(menu.configs.menu.config_list, menu.configs.list)
    end

    local status, error = pcall(protected)

    local message = {
        text = {
            { 'Succesfully ' },
            { 'deleted', true },
            { ' config [' },
            { name, true },
            { ']' }
        },
        error_text = {
            { 'Error while ' },
            { 'deleting', true },
            { ' config [' },
            { name, true },
            { ']' }
        }
    }

    if status then
        notifier.add({
            time = notifier.time.long,
            text = message.text
        })

        script_db.handlers.console_message(script_db.get_accent_color(), message.text)
    else
        script_db.handlers.handle_error(message.error_text)
    end
end

local ref = {
    enabled = ui.reference('AA', 'Anti-aimbot angles', 'Enabled'),
    pitch = ui.reference('AA', 'Anti-aimbot angles', 'Pitch'),
    yaw_base = ui.reference('AA', 'Anti-aimbot angles', 'Yaw base'),
    yaw = { ui.reference('AA', 'Anti-aimbot angles', 'Yaw') },
    yaw_jitter = {ui.reference('AA', 'Anti-aimbot angles', 'Yaw jitter') },
    body_yaw = { ui.reference('AA', 'Anti-aimbot angles', 'Body yaw') },
    freestanding_body_yaw = ui.reference('AA', 'Anti-aimbot angles', 'Freestanding body yaw'),
    edge_yaw = ui.reference('AA', 'Anti-aimbot angles', 'Edge yaw'),
    roll = ui.reference('AA', 'Anti-aimbot angles', 'Roll'),
    freestanding = { ui.reference('AA', 'Anti-aimbot angles', 'Freestanding') },
    slowwalk = { ui.reference('AA', 'Other', 'Slow motion') },
    leg_movement = ui.reference('AA', 'Other', 'Leg movement'),
    doubletap = { ui.reference('RAGE', 'Aimbot', 'Double tap') },
    fakeduck = ui.reference('RAGE', 'Other', 'Duck peek assist'),
    safepoint = ui.reference('RAGE', 'Aimbot', 'Force safe point'),
	forcebaim = ui.reference('RAGE', 'Aimbot', 'Force body aim'),
    quickpeek = { ui.reference('RAGE', 'Other', 'Quick peek assist') },
	onshotaa = { ui.reference('AA', 'Other', 'On shot anti-aim') },
	fakelag = { ui.reference('AA', 'Fake lag', 'Enabled') },
    fakelag_limit = ui.reference('AA', 'Fake lag', 'Limit'),
	ping_spike = { ui.reference('MISC', 'Miscellaneous', 'Ping spike') },
    third_person_alive = { ui.reference('VISUALS', 'Effects', 'Force third person (alive)') },
    dpi_scale = ui.reference('MISC', 'Settings', 'DPI scale'),
    feature_indicators = ui.reference('VISUALS', 'Other ESP', 'Feature indicators'),
    doubletap_mode = select(2, ui.reference('RAGE', 'Aimbot', 'Double tap')),
    target_hitbox = ui.reference('RAGE', 'Aimbot', 'Target hitbox'),
    minimum_damage = ui.reference('RAGE', 'Aimbot', 'Minimum damage'),
    auto_scope = ui.reference('RAGE', 'Aimbot', 'Automatic scope'),
    quickpeek_assist_mode = { ui.reference('RAGE', 'Other', 'Quick peek assist mode') },
    quickpeek_assist_distance = ui.reference('RAGE', 'Other', 'Quick peek assist distance'),
    antiaim_references = {
        main = {
            select(2, ui.reference('AA', 'Anti-aimbot angles', 'Yaw')),
            select(1, ui.reference('AA', 'Anti-aimbot angles', 'Yaw jitter')),
            select(2, ui.reference('AA', 'Anti-aimbot angles', 'Yaw jitter')),
            select(1, ui.reference('AA', 'Anti-aimbot angles', 'Body yaw')),
            select(2, ui.reference('AA', 'Anti-aimbot angles', 'Body yaw')),
            ui.reference('AA', 'Anti-aimbot angles', 'Freestanding body yaw')
        },
        other = {
            enabled = ui.reference('AA', 'Anti-aimbot angles', 'Enabled'),
            pitch_mode = select(1, ui.reference('AA', 'Anti-aimbot angles', 'Pitch')),
            pitch_value = select(2, ui.reference('AA', 'Anti-aimbot angles', 'Pitch')),
            yaw_base = ui.reference('AA', 'Anti-aimbot angles', 'Yaw base'),
            yaw = select(1, ui.reference('AA', 'Anti-aimbot angles', 'Yaw')),
            edge_yaw = ui.reference('AA', 'Anti-aimbot angles', 'Edge yaw'),
            roll = ui.reference('AA', 'Anti-aimbot angles', 'Roll'),
            freestanding_mode = select(1, ui.reference('AA', 'Anti-aimbot angles', 'Freestanding')),
            freestanding_key = select(2, ui.reference('AA', 'Anti-aimbot angles', 'Freestanding'))
        }
    }
}

local var = {
    p_state = {
        'stand',
        'exploit',
        'terrorist',
        'left',
        'normal',
        1
    },
    teams = { 'terrorist', 'counter terrorist' },
    states = { 'exploit', 'fakelag' },
    conditions = { 'stand', 'move', 'crouch', 'slowwalk', 'air crouch', 'air', 'legit aa' },
    builder_conditions = { 'stand', 'move', 'crouch', 'slowwalk', 'air crouch', 'air' },
    body_sides = { 'left', 'right' },
    conditions_to_int = {
        ['stand'] = 1,
        ['move'] = 2,
        ['crouch'] = 3,
        ['slowwalk'] = 4,
        ['air crouch'] = 5,
        ['air'] = 6,
        ['legit aa'] = 7
    },
    antibruteforce = {
        max_phases = 5
    },
    hitgroup_names = { [0] = 'generic', 'head', 'chest', 'stomach', 'left arm', 'right arm', 'left leg', 'right leg', 'neck', '?', 'gear' },
    condition_names = {
        normal = 'normal',
        manual = {
            normal = {
                left = 'manual left',
                right = 'manual right',
                forward = 'manual forward'
            },
            roll = {
                left = 'manual left roll',
                right = 'manual right roll',
                forward = 'manual forward roll'
            }
        },
        warmup = 'warmup',
        freezetime = 'freezetime',
        antibackstab = 'antibackstab'
    }
}

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'tab_selector',
    name = '',
    flags = '-'
}, { 'aa', 'additions', 'visuals', 'misc', 'configs' })

UI.new({ location = script_db.menu_dir, type = 'color_picker',
    index = 'accent_color',
    name = '',
    flags = 'c'
}, { 162, 186, 215, 255 }, true)

script_db.get_accent_color = function()
    return { ui.get(UI.get_element('accent_color')) }
end

menu.configs.list = { '\aA9A95FFFdefault config' }

menu.configs.vars = {
    protect_save = false,
    protect_delete = false
}

menu.configs.menu = {
    config_list = ui.new_listbox(script_db.menu_dir[1], script_db.menu_dir[2], 'configs', menu.configs.list),
    config_name = ui.new_textbox(script_db.menu_dir[1], script_db.menu_dir[2], 'name'),
    create_config = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'create', function()
        local name = ui.get(menu.configs.menu.config_name)
    
        menu.configs.handle.create_config(name)
    end),
    save_config = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'save', function()
        local item = ui.get(menu.configs.menu.config_list)
    
        menu.configs.handle.save_config(item)
    end),
    load_config = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'load', function()
        local item = ui.get(menu.configs.menu.config_list)
    
        menu.configs.handle.load_config(item)
    end),
    delete_config = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'delete', function()
        local item = ui.get(menu.configs.menu.config_list)
    
        menu.configs.handle.delete_config(item)
    end),
    export_button = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'export settings', function()
        configs.handle.export(
            true, false, false, nil,
            {
                { 'Succesfully ' },
                { 'exported', true },
                { ' settings to clipboard' }
            },
            {
                { 'Error while ' },
                { 'exporting', true },
                { ' settings' }
            }
        )
    end),
    import_button = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'import settings', function()
        configs.handle.import(
            clipboard.get(), nil,
            {
                { 'Succesfully ' },
                { 'imported', true },
                { ' settings from clipboard' }
            },
            {
                { 'Error while ' },
                { 'importing', true },
                { ' settings' }
            }
        )
    end),
    export_hidden_button = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'export settings as hidden', function()
        configs.handle.export(
            true, false, true, nil,
            {
                { 'Succesfully ' },
                { 'exported', true },
                { ' settings as ' },
                { 'hidden', true },
                { ' to clipboard' }
            },
            {
                { 'Error while ' },
                { 'exporting', true },
                { ' settings as ' },
                { 'hidden', true }
            }
        )
    end)
}

menu.hidden_cfg_warning = {
    label1 = ui.new_label(script_db.menu_dir[1], script_db.menu_dir[2], '\aff3d3dff! This config is hidden !'),
    label2 = ui.new_label(script_db.menu_dir[1], script_db.menu_dir[2], '(if you want to unhide anti-aim tab'),
    label3 = ui.new_label(script_db.menu_dir[1], script_db.menu_dir[2], 'load different config)')
}

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:antiaim_preset',
    name = '[aa] - anti-aim preset:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return not script_db.hidden_config end
    }
}, { 'experimental', 'dynamic', 'configurator' })

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'aa:dynamic:antibruteforce:events',
    name = '[aa] - dynamic events:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'dynamic' end,
        function() return not script_db.hidden_config end
    }
}, { 'miss', 'hit' })

UI.new({ location = script_db.menu_dir, type = 'slider',
    index = 'aa:dynamic:xway_chance',
    name = '[aa] - xway chance:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'dynamic' end,
        function() return not script_db.hidden_config end
    }
}, 0, 100, 50, true, '%', 1, { [0] = 'Off', [100] = 'Always on' })

menu.antibruteforce = {
    visible = false
}

menu.antibruteforce.buttons = {
    antibruteforce = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'go to antibruteforce tab', function()
        menu.antibruteforce.visible = true

        UI.visibility_handle()
    end),
    antiaim = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'go to antiaim tab', function()
        menu.antibruteforce.visible = false

        UI.visibility_handle()
    end)
}

UI.new({ location = script_db.menu_dir, type = 'checkbox',
    index = 'aa:antibruteforce:enable',
    name = '[aa] - enable anti-bruteforce',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
})

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:antibruteforce:type',
    name = '[bf] - type:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
}, { 'simple', 'condition based' })

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'aa:antibruteforce:events',
    name = '[bf] - events:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
}, { 'miss', 'hit', 'headshot' })

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'aa:antibruteforce:reset_events',
    name = '[bf] - reset events:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
}, { 'round start', 'shooter death', 'time' })

UI.new({ location = script_db.menu_dir, type = 'slider',
    index = 'aa:antibruteforce:reset_events:time',
    name = '[reset] - time:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return UI.contains('aa:antibruteforce:reset_events', 'time') end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
}, 2, 10, 4, true, 's')

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:antibruteforce:simple:mode',
    name = '[bf] - mode:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return UI.get('aa:antibruteforce:type') == 'simple' end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
}, { 'jitter', 'static' })

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:antibruteforce:simple:jitter:mode',
    name = '[jitter] - mode:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return UI.get('aa:antibruteforce:type') == 'simple' end,
        function() return UI.get('aa:antibruteforce:simple:mode') == 'jitter' end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
}, { 'automatic', 'phases' })

UI.new({ location = script_db.menu_dir, type = 'slider',
    index = 'aa:antibruteforce:simple:jitter:phases:amount',
    name = '[phases] - amount:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return UI.get('aa:antibruteforce:type') == 'simple' end,
        function() return UI.get('aa:antibruteforce:simple:mode') == 'jitter' end,
        function() return UI.get('aa:antibruteforce:simple:jitter:mode') == 'phases' end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
}, 1, var.antibruteforce.max_phases, 1)

for i = 1, var.antibruteforce.max_phases do
    local base_condition = function()   
        return UI.get('tab_selector') == 'aa'
        and UI.get('aa:antibruteforce:enable')
        and UI.get('aa:antibruteforce:type') == 'simple'
        and UI.get('aa:antibruteforce:simple:mode') == 'jitter'
        and UI.get('aa:antibruteforce:simple:jitter:mode') == 'phases'
        and UI.get('aa:antibruteforce:simple:jitter:phases:amount') >= i
        and not script_db.hidden_config
        and menu.antibruteforce.visible
    end

    UI.new({ location = script_db.menu_dir, type = 'slider',
        index = ('aa:dynamic:antibruteforce:simple:jitter:phases:%d:yaw_jitter'):format(i),
        name = ('[phase: %d] - yaw jitter:'):format(i),
        flags = '',
        conditions = {
            base_condition
        }
    }, -180, 180, 0)
end

UI.new({ location = script_db.menu_dir, type = 'checkbox',
    index = 'aa:antibruteforce:simple:static:detect_side',
    name = '[static] - detect side',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antibruteforce:enable') end,
        function() return UI.get('aa:antibruteforce:type') == 'simple' end,
        function() return UI.get('aa:antibruteforce:simple:mode') == 'static' end,
        function() return not script_db.hidden_config end,
        function() return menu.antibruteforce.visible end
    }
})


UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'aa:builder:builder_options',
    name = '[aa] - configurator options:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'configurator' end,
        function() return not script_db.hidden_config end,
        function() return not menu.antibruteforce.visible end
    }
}, { 'team based', 'state based', 'body side based' })

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:builder:team_selector',
    name = '[aa] - team:',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'configurator' end,
        function() return UI.contains('aa:builder:builder_options', 'team based') end,
        function() return not script_db.hidden_config end,
        function() return not menu.antibruteforce.visible end
    }
}, var.teams)

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:builder:state_selector',
    name = '[aa] - state:',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'configurator' end,
        function() return UI.contains('aa:builder:builder_options', 'state based') end,
        function() return not script_db.hidden_config end,
        function() return not menu.antibruteforce.visible end
    }
}, var.states)

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:builder:condition_selector',
    name = '[aa] - condition:',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'configurator' end,
        function() return not script_db.hidden_config end,
        function() return not menu.antibruteforce.visible end
    }
}, var.builder_conditions)

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'aa:builder:body_side_selector',
    name = '[aa] - body side:',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'configurator' end,
        function() return UI.contains('aa:builder:builder_options', 'body side based') end,
        function() return not script_db.hidden_config end,
        function() return not menu.antibruteforce.visible end
    }
}, var.body_sides)

UI.new({ location = script_db.menu_dir, type = 'checkbox',
    index = 'aa:builder:preview_selected_state',
    name = '[aa] - preview selected state',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'aa' end,
        function() return UI.get('aa:antiaim_preset') == 'configurator' end,
        function() return not script_db.hidden_config end,
        function() return not menu.antibruteforce.visible end
    }
})

menu.builder = {
    configuring_label = ui.new_label(script_db.menu_dir[1], script_db.menu_dir[2], 'configuring: ')
}

menu.builder.handle = {
    configuring_label = function()
        local text = 'configuring: '

        if UI.get('aa:builder:preview_selected_state') then
            text = 'previewing: '
        end

        local curr_state = {}

        local team_names = {
            ['terrorist'] = 'TT',
            ['counter terrorist'] = 'CT'
        }
        
        if UI.contains('aa:builder:builder_options', 'team based') then
            curr_state[#curr_state + 1] = team_names[UI.get('aa:builder:team_selector')]
        end
    
        if UI.contains('aa:builder:builder_options', 'state based') then
            curr_state[#curr_state + 1] = UI.get('aa:builder:state_selector')
        end

        curr_state[#curr_state + 1] = UI.get('aa:builder:condition_selector')

        if UI.contains('aa:builder:builder_options', 'body side based') then
            curr_state[#curr_state + 1] = UI.get('aa:builder:body_side_selector')
        end

        ui.set(menu.builder.configuring_label, text .. table.concat(curr_state, ':'))
    end
}

for i, team in pairs(var.teams) do
    for j, state in pairs(var.states) do
        for k, condition in pairs(var.builder_conditions) do
            for l, side in pairs(var.body_sides) do
                local team_index = team

                local handle_name = function(name)
                    local short_names = {
                        team = {
                            [var.teams[1]] = 'T',
                            [var.teams[2]] = 'CT'
                        },
                        state = {
                            [var.states[1]] = 'EX',
                            [var.states[2]] = 'FL'
                        },
                        side = {
                            [var.body_sides[1]] = 'L',
                            [var.body_sides[2]] = 'R'
                        }
                    }

                    return ('%s\n%s%s%s%s'):format(name, short_names.team[team], short_names.state[state], condition, short_names.side[side])
                end

                local handle_index = function(index)
                    return ('aa:builder:states:%s:%s:%s:%s:%s'):format(team_index, state, condition, side, index)
                end

                local base_condition = function()
                    local show_team = team == 'terrorist'

                    if UI.contains('aa:builder:builder_options', 'team based') then
                        show_team = UI.get('aa:builder:team_selector') == team
                    end

                    local show_state = state == 'exploit'

                    if UI.contains('aa:builder:builder_options', 'state based') then
                        show_state = UI.get('aa:builder:state_selector') == state
                    end

                    local show_body_side = side == 'left'

                    if UI.contains('aa:builder:builder_options', 'body side based') then
                        show_body_side = UI.get('aa:builder:body_side_selector') == side
                    end
                    
                    return UI.get('tab_selector') == 'aa'
                    and UI.get('aa:antiaim_preset') == 'configurator'
                    and show_team
                    and show_state
                    and show_body_side
                    and UI.get('aa:builder:condition_selector') == condition
                    and not script_db.hidden_config
                    and not menu.antibruteforce.visible
                end

                UI.new({ location = script_db.menu_dir, type = 'slider',
                    index = handle_index('yaw_value'),
                    name = handle_name('yaw:'),
                    flags = '',
                    conditions = {
                        base_condition
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'combobox',
                    index = handle_index('yaw_jitter'),
                    name = handle_name('yaw jitter:'),
                    flags = '',
                    conditions = {
                        base_condition
                    }
                }, { 'Off', 'Offset', 'Center', 'Random', '3-way', '5-way' })

                UI.new({ location = script_db.menu_dir, type = 'combobox',
                    index = handle_index('yaw_jitter:xway:mode'),
                    name = handle_name('xway mode:'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local yaw_jitter = UI.get(handle_index('yaw_jitter'))

                            return yaw_jitter == '3-way' or yaw_jitter == '5-way'
                        end
                    }
                }, { 'simple', 'manual' })

                UI.new({ location = script_db.menu_dir, type = 'slider',
                    index = handle_index('yaw_jitter_value'),
                    name = handle_name('yaw jitter value:'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local yaw_jitter = UI.get(handle_index('yaw_jitter'))

                            if yaw_jitter == '3-way' or yaw_jitter == '5-way' then
                                return UI.get(handle_index('yaw_jitter:xway:mode')) == 'simple'
                            end

                            return yaw_jitter ~= 'Off'
                        end
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'slider',
                    index = handle_index('xway:manual:value:1'),
                    name = handle_name('\n1'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local yaw_jitter = UI.get(handle_index('yaw_jitter'))
                            local xway_mode = UI.get(handle_index('yaw_jitter:xway:mode'))

                            return (yaw_jitter == '3-way' and xway_mode == 'manual') or (yaw_jitter == '5-way' and xway_mode == 'manual')
                        end
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'slider',
                index = handle_index('xway:manual:value:2'),
                name = handle_name('\n2'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local yaw_jitter = UI.get(handle_index('yaw_jitter'))
                            local xway_mode = UI.get(handle_index('yaw_jitter:xway:mode'))

                            return (yaw_jitter == '3-way' and xway_mode == 'manual') or (yaw_jitter == '5-way' and xway_mode == 'manual')
                        end
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'slider',
                index = handle_index('xway:manual:value:3'),
                name = handle_name('\n3'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local yaw_jitter = UI.get(handle_index('yaw_jitter'))
                            local xway_mode = UI.get(handle_index('yaw_jitter:xway:mode'))

                            return (yaw_jitter == '3-way' and xway_mode == 'manual') or (yaw_jitter == '5-way' and xway_mode == 'manual')
                        end
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'slider',
                index = handle_index('xway:manual:value:4'),
                name = handle_name('\n4'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local yaw_jitter = UI.get(handle_index('yaw_jitter'))
                            local xway_mode = UI.get(handle_index('yaw_jitter:xway:mode'))

                            return yaw_jitter == '5-way' and xway_mode == 'manual'
                        end
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'slider',
                index = handle_index('xway:manual:value:5'),
                name = handle_name('\n5'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local yaw_jitter = UI.get(handle_index('yaw_jitter'))
                            local xway_mode = UI.get(handle_index('yaw_jitter:xway:mode'))

                            return yaw_jitter == '5-way' and xway_mode == 'manual'
                        end
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'combobox',
                    index = handle_index('body_yaw'),
                    name = handle_name('body yaw:'),
                    flags = '',
                    conditions = {
                        base_condition
                    }
                }, { 'Off', 'Opposite', 'Jitter', 'Static' })

                UI.new({ location = script_db.menu_dir, type = 'slider',
                    index = handle_index('body_yaw_value'),
                    name = handle_name('body yaw value:'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function()
                            local body_yaw = UI.get(handle_index('body_yaw'))

                            return body_yaw ~= 'Off' and body_yaw ~= 'Opposite'
                        end
                    }
                }, -180, 180, 0)

                UI.new({ location = script_db.menu_dir, type = 'slider',
                    index = handle_index('fake_limit'),
                    name = handle_name('fake limit:'),
                    flags = '',
                    conditions = {
                        base_condition,
                        function() return UI.get(handle_index('body_yaw')) ~= 'Off' end
                    }
                }, 0, 60, 60)
            end
        end
    end
end

menu.builder.export_current_state = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'export current state', function()
    local team = var.teams[1]
    local state = var.states[1]
    local body_side = var.body_sides[1]
    local condition = UI.get('aa:builder:condition_selector')

    local curr_state = {}
    
    if UI.contains('aa:builder:builder_options', 'team based') then
        team = UI.get('aa:builder:team_selector')

        curr_state[#curr_state + 1] = UI.get('aa:builder:team_selector')
    end

    if UI.contains('aa:builder:builder_options', 'state based') then
        state = UI.get('aa:builder:state_selector')

        curr_state[#curr_state + 1] = UI.get('aa:builder:state_selector')
    end

    curr_state[#curr_state + 1] = UI.get('aa:builder:condition_selector')

    if UI.contains('aa:builder:builder_options', 'body side based') then
        body_side = UI.get('aa:builder:body_side_selector')

        curr_state[#curr_state + 1] = UI.get('aa:builder:body_side_selector')
    end

    configs.handle.export(
        true, false, false, (':builder:states:%s:%s:%s:%s:'):format(team, state, condition, body_side),
        {
            { 'Succesfully ' },
            { 'exported', true },
            { ' current state settings to clipboard [' },
            { table.concat(curr_state, ' - '), true },
            { ']' }
        },
        {
            { 'Error while ' },
            { 'exporting', true },
            { ' current state settings' }
        }
    )
end)

menu.builder.import_current_state = ui.new_button(script_db.menu_dir[1], script_db.menu_dir[2], 'import to current state', function()
    local team = var.teams[1]
    local state = var.states[1]
    local body_side = var.body_sides[1]
    local condition = UI.get('aa:builder:condition_selector')

    local curr_state = {}
    
    if UI.contains('aa:builder:builder_options', 'team based') then
        team = UI.get('aa:builder:team_selector')

        curr_state[#curr_state + 1] = UI.get('aa:builder:team_selector')
    end

    if UI.contains('aa:builder:builder_options', 'state based') then
        state = UI.get('aa:builder:state_selector')

        curr_state[#curr_state + 1] = UI.get('aa:builder:state_selector')
    end

    curr_state[#curr_state + 1] = UI.get('aa:builder:condition_selector')

    if UI.contains('aa:builder:builder_options', 'body side based') then
        body_side = UI.get('aa:builder:body_side_selector')

        curr_state[#curr_state + 1] = UI.get('aa:builder:body_side_selector')
    end

    configs.handle.import(
        clipboard.get(), (':builder:states:%s:%s:%s:%s:'):format(team, state, condition, body_side),
        {
            { 'Succesfully ' },
            { 'imported', true },
            { ' state settings to [' },
            { table.concat(curr_state, ' - '), true },
            { ']' }
        },
        {
            { 'Error while ' },
            { 'importing', true },
            { ' state settings' }
        }
    )
end)


UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'additions:bind_selector',
    name = '[binds] - selector:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end
    }
}, { 'legit anti-aim', 'freestand', 'manual anti-aim', 'breaker', 'force defensive', 'cross assistant' })

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:legitaa:key',
    name = '[~] - legit anti-aim',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'legit anti-aim') end
    }
}, false, 0x45)

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:freestand:key',
    name = '[~] - freestand',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'freestand') end
    }
}, false)

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:manual:key:left',
    name = '[~] - manual left',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'manual anti-aim') end
    }
}, false)

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:manual:key:right',
    name = '[~] - manual right',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'manual anti-aim') end
    }
}, false)

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:manual:key:forward',
    name = '[~] - manual forward',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'manual anti-aim') end
    }
}, false)

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:breaker:key',
    name = '[~] - breaker',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'breaker') end
    }
}, false)

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:force_defensive:key',
    name = '[~] - force defensive',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'force defensive') end
    }
}, false)

UI.new({ location = script_db.menu_dir, type = 'hotkey',
    index = 'additions:binds:cross_assistant:key',
    name = '[~] - cross assistant',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'cross assistant') end
    }
}, false)

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'additions:binds:freestand:disablers',
    name = '[FREESTAND] - disablers:',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'freestand') end
    }
}, { 'slowwalk', 'in air', 'crouch', 'move' })

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'additions:binds:force_defensive:conditions',
    name = '[DEFENSIVE] - conditions:',
    flags = '-',
    conditions = {
        function() return UI.get('tab_selector') == 'additions' end,
        function() return UI.contains('additions:bind_selector', 'force defensive') end
    }
}, { 'stand', 'move', 'in air', 'quickpeeking' })


UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'visuals:notifier:prefix',
    name = '[vis] - notifier prefix:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end
    }
}, { 'text', 'logo' })

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'visuals:notifier:style',
    name = '[vis] - notifier style:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end
    }
}, { 'glow', 'gradient' })

ui.set(UI.get_element('visuals:notifier:style'), 'glow')

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'visuals:popups:elements',
    name = '[vis] - popup elements:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end
    }
}, { 'defensive choking', 'slowdown warning' })

UI.new({ location = script_db.menu_dir, type = 'checkbox',
    index = 'visuals:watermark',
    name = '[vis] - watermark:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end
    }
})

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'visuals:indicators:style',
    name = '[vis] - center style:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end
    }
}, { '-', 'modern' })

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'visuals:indicators:font_style',
    name = '[center] - font style:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end,
        function() return UI.get('visuals:indicators:style') == 'modern' end
    }
}, { 'small', 'normal', 'bold' })

UI.new({ location = script_db.menu_dir, type = 'slider',
    index = 'visuals:indicators:height',
    name = '[center] - height:',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end,
        function() return UI.get('visuals:indicators:style') ~= '-' end
    }
}, -100, 100, 25, true, 'px')

UI.new({ location = script_db.menu_dir, type = 'checkbox',
    index = 'visuals:indicators:manual_arrows',
    name = '[vis] - manual arrows',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end
    }
})

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'visuals:indicators:adjustments',
    name = '[vis] - adjustments',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'visuals' end
    }
}, { 'move indicators on scope', 'move indicators on nade', 'move arrows on scope' })


UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'misc:aimbot_log',
    name = '[misc] - aimbot logs',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'misc' end
    }
}, { 'notify', 'console' })

UI.new({ location = script_db.menu_dir, type = 'multiselect',
    index = 'misc:animation_breakers',
    name = '[misc] - animations',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'misc' end
    }
}, { 'legs on ground', 'legs in air', 'pitch zero on land' })

UI.new({ location = script_db.menu_dir, type = 'combobox',
    index = 'misc:leg_breaker',
    name = '[misc] - leg breaker',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'misc' end,
        function() return UI.contains('misc:animation_breakers', 'legs on ground') end
    }
}, { 'jitter', 'moonwalk' })

UI.new({ location = script_db.menu_dir, type = 'checkbox',
    index = 'misc:clantag',
    name = '[misc] - clantag',
    flags = '',
    conditions = {
        function() return UI.get('tab_selector') == 'misc' end
    }
})

menu.other = {
    disable_dt_indicator = ui.new_checkbox('AA', 'Other', 'disable dt indicator')
}

menu.handle = {}

menu.handle.visibility = function()
    local tab = UI.get('tab_selector')

    for i, item in pairs(menu.builder) do
        if type(item) ~= 'table' then
            ui.set_visible(
                item,
                tab == 'aa'
                and UI.get('aa:antiaim_preset') == 'configurator'
                and not script_db.hidden_config
                and not menu.antibruteforce.visible
            )
        end
    end

    for i, item in pairs(menu.configs.menu) do
        ui.set_visible(item, tab == 'configs')
    end

    for i, item in pairs(menu.hidden_cfg_warning) do
        ui.set_visible(item, script_db.hidden_config and tab == 'aa')
    end

    ui.set_visible(
        menu.antibruteforce.buttons.antibruteforce,
        tab == 'aa'
        and not script_db.hidden_config
        and not menu.antibruteforce.visible
        and UI.get('aa:antiaim_preset') ~= 'dynamic'
    )
    ui.set_visible(
        menu.antibruteforce.buttons.antiaim,
        tab == 'aa'
        and not script_db.hidden_config
        and menu.antibruteforce.visible
        and UI.get('aa:antiaim_preset') ~= 'dynamic'
    )

    if UI.get('aa:antiaim_preset') == 'dynamic' then
        menu.antibruteforce.visible = false
    end
end

menu.handle.skeet_menu = function(show)
    for i, item in pairs(ref.antiaim_references.main) do
        ui.set_visible(item, show)
    end

    for key, item in pairs(ref.antiaim_references.other) do
        ui.set_visible(item, show)
    end
end

menu.handle.reset_antiaim = function()
    local values = { 0, 'Off', 0, 'Off', 0, false, 0 }

    for i, item in pairs(ref.antiaim_references.main) do
        ui.set(item, values[i])
    end

    ui.set(ref.antiaim_references.other.pitch_mode, 'Off')
    ui.set(ref.antiaim_references.other.yaw_base, 'Local view')
    ui.set(ref.antiaim_references.other.yaw, 'Off')
    ui.set(ref.antiaim_references.other.roll, 0)
end

local doubletap_state = {
    active = false,
    charged = false,
    defensive = {
        charged = false,
        choking = false,
        choke_ticks = 0,
        choke_until = 0,
        values = {
            last_sim_time = 0
        }
    },
    fix = {
        indicators = {}
    },
    funcs = {}
}

doubletap_state.funcs.on_indicator = function(indicator)
    doubletap_state.fix.indicators[#doubletap_state.fix.indicators + 1] = indicator
end

doubletap_state.funcs.on_setup_command = function()
    local plocal = entity.get_local_player()
    local tickcount = globals.tickcount()
    local sim_time = toticks(entity.get_prop(plocal, 'm_flSimulationTime'))
    local sim_diff = sim_time - doubletap_state.defensive.values.last_sim_time

    if sim_diff < 0 then
        doubletap_state.defensive.choke_until = tickcount + math.abs(sim_diff) - toticks(client.latency())
        doubletap_state.defensive.choke_ticks = doubletap_state.defensive.choke_until - tickcount
    end

    if doubletap_state.defensive.choke_until > (tickcount + 32) then
        doubletap_state.defensive.choke_until = 0
    end

    doubletap_state.defensive.values.last_sim_time = sim_time
    doubletap_state.defensive.choking = doubletap_state.defensive.choke_until > tickcount

    local defensive_charged = anti_aim_f.get_double_tap()

    doubletap_state.defensive.charged = defensive_charged and ui.get(ref.doubletap_mode) == 'Defensive'
end

doubletap_state.funcs.on_paint_ui = function()
    if not table.contains(ref.feature_indicators, 'Double tap') then
        local to_set = function()
            local new_table = { 'Double tap' }

            local indicators = ui.get(ref.feature_indicators)

            for i = 1, #indicators do
                new_table[i + 1] = indicators[i]
            end

            return new_table
        end

        ui.set(ref.feature_indicators, to_set())
    end

    doubletap_state.active = false
    doubletap_state.charged = false

    local h = select(2, client.screen_size())

    local starting = h - 350

    for index, indicator in pairs(doubletap_state.fix.indicators) do index = index - 1 -- this is how you fix lua tables lol       
        if indicator.text == 'DT' then
            doubletap_state.active = true

            if indicator.g == 255 then
                doubletap_state.charged = true
            end

            if ui.get(menu.other.disable_dt_indicator) then
                goto skip
            end
        end

        local width, height = renderer.measure_text('d+', indicator.text)
        local offset = index * (height + 8)

        local gradient_width = math.floor(width / 2)

        local y = starting - offset

        renderer.gradient(10, y, gradient_width, height + 4, 0, 0, 0, 0, 0, 0, 0, 50, true)
        renderer.gradient(10 + gradient_width, y, gradient_width, height + 4, 0, 0, 0, 50, 0, 0, 0, 0, true)
        renderer.text(20, y + 2, indicator.r, indicator.g, indicator.b, indicator.a, 'd+', 0, indicator.text)

        ::skip::
    end

    doubletap_state.fix.indicators = {}
end

local antibruteforce = {
    queue = {
        hit = {},
        missed = {}
    },
    data = {},
    all_stored_shots = {
        all = 0,
        hit = 0,
        overall_hits = 0,
        missed = 0,
        headshots = 0
    },
    cache = {
        backtrack = FN.gram_create(
            {
                origin = vector(),
                eyepos = vector(),
                headpos = vector(),
                final_pos = vector()
            },
            32
        ),
        last_backtrack_ticks = 0
    },
    vars = {
        time = 0,
        nonweapons = {
            'knife',
            'hegrenade',
            'inferno',
            'flashbang',
            'decoy',
            'smokegrenade',
            'taser'
        }
    },
    values = {
        simple = {},
        conditional = {}
    }
}

antibruteforce.handle_shots = function(self)
    local enemies = FN.get_players(true, false, false, true, false)

    for i, player in pairs(enemies) do
        local enemy = player

        local steamid = entity.get_steam64(enemy)

        local idx = tostring(steamid)

        if self.queue.hit[enemy] ~= nil then
            self.queue.missed[enemy] = nil
            
            if self.data[idx] == nil then
                self.data[idx] = {
                    shots = {
                        hit = {},
                        missed = {}
                    },
                    stored_shots = {
                        all = 0,
                        hit = 0,
                        overall_hits = 0,
                        missed = 0,
                        headshots = 0,
                        states = {}
                    },
                    last = {}
                }

                for i, team in pairs(var.teams) do
                    self.data[idx].stored_shots.states[team] = {}
                    for j, state in pairs(var.states) do
                        self.data[idx].stored_shots.states[team][state] = {}
                        for k, condition in pairs(var.conditions) do
                            self.data[idx].stored_shots.states[team][state][condition] = {
                                all = 0,
                                hit = 0,
                                overall_hits = 0,
                                missed = 0,
                                headshots = 0
                            }
                        end
                    end
                end
            end

            local data = self.queue.hit[enemy]

            if self.data[idx].shots.hit[#self.data[idx].shots.hit] ~= nil then
                if self.data[idx].shots.hit[#self.data[idx].shots.hit].time == data.time then
                    self.queue.hit[enemy] = nil
                    return
                end
            end

            table.insert(self.data[idx].shots.hit, data)

            self.data[idx].stored_shots.all = self.data[idx].stored_shots.all + 1
            self.data[idx].stored_shots.hit = self.data[idx].stored_shots.hit + (data.hitbox == 'head' and 0 or 1)
            self.data[idx].stored_shots.overall_hits = self.data[idx].stored_shots.overall_hits + 1
            self.data[idx].stored_shots.headshots = self.data[idx].stored_shots.headshots + (data.hitbox == 'head' and 1 or 0)

            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].all =
            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].all + 1

            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].hit =
            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].hit + (data.hitbox == 'head' and 0 or 1)

            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].overall_hits =
            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].overall_hits + 1

            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].headshots =
            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].headshots + (data.hitbox == 'head' and 1 or 0)

            self.data[idx].last = {
                body_yaw_side = data.body_yaw_side,
                shot_side = data.shot_side,
                time = data.time
            }

            self.all_stored_shots.all = self.all_stored_shots.all + 1
            self.all_stored_shots.hit = self.all_stored_shots.hit + (data.hitbox == 'head' and 0 or 1)
            self.all_stored_shots.overall_hits = self.all_stored_shots.overall_hits + 1
            self.all_stored_shots.headshots = self.all_stored_shots.headshots + (data.hitbox == 'head' and 1 or 0)

            self.handle_values(data.hitbox == 'head' and 'headshot' or 'hit', enemy, idx, data)

            self.queue.hit[enemy] = nil
        end

        if self.queue.missed[enemy] ~= nil then
            if self.data[idx] == nil then
                self.data[idx] = {
                    shots = {
                        hit = {},
                        missed = {}
                    },
                    stored_shots = {
                        all = 0,
                        hit = 0,
                        overall_hits = 0,
                        missed = 0,
                        headshots = 0,
                        states = {}
                    },
                    last = {}
                }

                for i, team in pairs(var.teams) do
                    self.data[idx].stored_shots.states[team] = {}
                    for j, state in pairs(var.states) do
                        self.data[idx].stored_shots.states[team][state] = {}
                        for k, condition in pairs(var.conditions) do
                            self.data[idx].stored_shots.states[team][state][condition] = {
                                all = 0,
                                hit = 0,
                                overall_hits = 0,
                                missed = 0,
                                headshots = 0
                            }
                        end
                    end
                end
            end

            local data = self.queue.missed[enemy]

            if self.data[idx].shots.missed[#self.data[idx].shots.missed] ~= nil then
                if self.data[idx].shots.missed[#self.data[idx].shots.missed].time == data.time then
                    self.queue.missed[enemy] = nil
                    return
                end
            end

            table.insert(self.data[idx].shots.missed, data)

            self.data[idx].stored_shots.all = self.data[idx].stored_shots.all + 1
            self.data[idx].stored_shots.missed = self.data[idx].stored_shots.missed + 1

            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].all =
            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].all + 1

            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].missed =
            self.data[idx].stored_shots.states[data.p_state[3]][data.p_state[2]][data.p_state[1]].missed + 1


            self.data[idx].last = {
                body_yaw_side = data.body_yaw_side,
                shot_side = data.shot_side,
                time = data.time
            }

            self.all_stored_shots.all = self.all_stored_shots.all + 1
            self.all_stored_shots.missed = self.all_stored_shots.missed + 1

            self.handle_values('miss', enemy, idx, data)

            self.queue.missed[enemy] = nil
        end
    end
end

-- local last_data = nil
-- local last_backtrack = nil

-- client.set_event_callback('paint', function()
--     if not last_data then return end

--     for key, data in pairs(last_data) do
--         local onscreen_pos = vector(renderer.world_to_screen(data[2].x, data[2].y, data[2].z))

--         renderer.text(onscreen_pos.x, onscreen_pos.y + 20, 255, 255, 255, 255, 'c', nil, data[1])

--         renderer.circle(onscreen_pos.x, onscreen_pos.y, 255, 255, 255, 255, 2, 0, 1)
--     end

--     if not last_backtrack then return end

--     for i = 1, #last_backtrack do
--         local curr_backtrack = last_backtrack[i]

--         -- for key, data in pairs(curr_backtrack) do
--             local onscreen_pos = vector(renderer.world_to_screen(curr_backtrack.final_pos.x, curr_backtrack.final_pos.y, curr_backtrack.final_pos.z))

--             renderer.text(onscreen_pos.x, onscreen_pos.y + 20, 255, 255, 255, 255, 'c', nil, 'bt\n' .. (i - 1))
--             renderer.circle(onscreen_pos.x, onscreen_pos.y, 255, 255, 255, 255, 2, 0, 1)
--         -- end
--     end
-- end)

antibruteforce.store_backtrack = function()
    local plocal = entity.get_local_player()
    local lp_origin = vector(entity.get_origin(plocal))

    FN.gram_update(
        antibruteforce.cache.backtrack,
        {
            origin = lp_origin,
            eyepos = vector(client.eye_position()),
            head_pos = vector(entity.hitbox_position(plocal, 0)),
            final_pos = lp_origin + vector(entity.get_prop(plocal, 'm_vecViewOffset')) - vector(0, 0, 11)
        }
    )
end

antibruteforce.bullet_impact = function(e)
    if e == nil then return end

    local plocal = entity.get_local_player()
    local shooter = client.userid_to_entindex(e.userid)

    if not entity.is_enemy(shooter)
    or not entity.is_alive(shooter)
    or entity.is_dormant(shooter)
    or not entity.is_alive(plocal)
    or plist.get(shooter, 'Add to whitelist') then
        return
    end

    if var.p_state[5] ~= var.condition_names.normal then
        return
    end

    local shooter_origin = vector(entity.get_origin(shooter))
    local shooter_viewoffset = vector(entity.get_prop(shooter, 'm_vecViewOffset'))
    local shooter_eyepos = shooter_origin + shooter_viewoffset

    local lp_origin = vector(entity.get_origin(plocal))
    local lp_viewoffset = vector(entity.get_prop(plocal, 'm_vecViewOffset'))
    local lp_eyepos = vector(client.eye_position())
    local lp_head_pos = vector(entity.hitbox_position(plocal, 0))
    local lp_stomach_pos = vector(entity.hitbox_position(plocal, 3))

    -- local duck_amount = entity.get_prop(plocal, 'm_flDuckAmount')
    -- local lp_final_pos = lp_origin + lp_viewoffset - vector(0, 0, 11) --vector(entity.get_origin(plocal)) + vector(0, 0, 57 - 13.5 * duck_amount)

    local angle_to_shooter = vector(lp_origin:to(shooter_origin):angles()).y

    local shooter_ping = entity.get_prop(entity.get_player_resource(), string.format('%03d', plocal))
    local shooter_ping_ticks = toticks(shooter_ping or 0) / 1000
    local max_backtrack_ticks = math.floor(math.max(16, math.min(32, shooter_ping_ticks * 2 + 1)))

    local backtrack_positions do
        local cache = {}
        local positions = {}

        for i = #antibruteforce.cache.backtrack, 1, -1 do
            local curr_backtrack = antibruteforce.cache.backtrack[i]
            local curr_pos = curr_backtrack.origin

            if i < max_backtrack_ticks then
                goto skip
            end

            if i < #antibruteforce.cache.backtrack then
                if curr_pos:dist(cache[i + 1]) < .8 then
                    goto skip
                end
            end

            positions[#positions + 1] = curr_backtrack

            ::skip::

            cache[i] = curr_pos
        end

        backtrack_positions = positions
    end

    local impact = vector(e.x, e.y, e.z)

    local shot_pos_center = FN.ClosestPointOnRay(lp_eyepos, shooter_eyepos, impact)

    local closest_position do
        local distances = {}

        for i = 1, #backtrack_positions do
            local curr_backtrack = backtrack_positions[i]
            local curr_pos = curr_backtrack.final_pos

            local distance_to_shoot_pos = curr_pos:dist(shot_pos_center)

            distances[i] = distance_to_shoot_pos
        end

        local _, backtrack_tick = table.contains(distances, math.min(unpack(distances)))

        closest_position = {
            pos = backtrack_positions[backtrack_tick],
            backtrack_ticks = backtrack_tick - 1
        }
    end

    local shot_distance_to_closest_pos = shot_pos_center:dist(closest_position.pos.final_pos)

    local shot_side = (function()
        local left_pos = FN.extend_vector(closest_position.pos.eyepos, 5, anti_aim_f.normalize_angle(angle_to_shooter - 90 + 180))
        local right_pos = FN.extend_vector(closest_position.pos.eyepos, 5, anti_aim_f.normalize_angle(angle_to_shooter + 90 + 180))

        local shot_distance_to_left = shot_pos_center:dist(left_pos)
        local shot_distance_to_right = shot_pos_center:dist(right_pos)

        return shot_distance_to_left > shot_distance_to_right and 'right' or 'left'
    end)()

    local minimal_distance = closest_position.backtrack_ticks > 0 and 20 or 17

    -- last_data = {
    --     -- shooter_origin = { ('shooter_origin\n%.02f, %.02f, %.02f'):format(shooter_origin:unpack()), shooter_origin },
    --     -- shooter_viewoffset = { ('shooter_viewoffset\n%.02f, %.02f, %.02f'):format(shooter_viewoffset:unpack()), shooter_origin + vector(0, 0, 30) },
    --     -- shooter_eyepos = { ('shooter_eyepos\n%.02f, %.02f, %.02f'):format(shooter_eyepos:unpack()), shooter_eyepos },
    --     -- lp_origin = { ('lp_origin\n%.02f, %.02f, %.02f'):format(lp_origin:unpack()), lp_origin },
    --     -- lp_eyepos = { ('lp_eyepos\n%.02f, %.02f, %.02f'):format(lp_eyepos:unpack()), lp_eyepos },
    --     lp_final_pos = { 'lp_final_pos', lp_final_pos },
    --     -- angle_to_shooter = { ('angle_to_shooter\n%.02f'):format(angle_to_shooter), shooter_origin + vector(0, 0, 60) },
    --     -- left_pos = { ('left_pos\n%.02f, %.02f, %.02f'):format(left_pos:unpack()), left_pos },
    --     -- right_pos = { ('right_pos\n%.02f, %.02f, %.02f'):format(right_pos:unpack()), right_pos },
    --     impact = { 'impact', impact },
    --     -- head_pos = { ('head_pos\n%.02f, %.02f, %.02f'):format(head_pos:unpack()), head_pos },
    --     shot_pos_center = { 'shot_pos_center', shot_pos_center },
    --     -- shot_pos_to_head = { 'shot_pos_to_head', shot_pos_to_head },
    --     -- shot_pos_to_body = { 'shot_pos_to_body', shot_pos_to_body },
    --     closest_position = { ('closest_position\nticks: %d'):format(closest_position.backtrack_ticks), closest_position.final_pos --[[  + vector(0, 0, 30) ]] }
    -- }
    -- last_backtrack = backtrack_positions

    antibruteforce.cache.last_backtrack_ticks = closest_position.backtrack_ticks

    local menu_body_yaw = ui.get(ref.body_yaw[2])

    if shot_distance_to_closest_pos < minimal_distance then
        table.insert(antibruteforce.queue.missed, shooter, {
            p_state = var.p_state,
            shot_side = shot_side,
            body_yaw_side = antiaim.vars.body_yaw.side and 'left' or 'right',
            slider_body_yaw = menu_body_yaw,
            hitbox = nil,
            antiaim_data = antiaim.vars.current_antiaim,
            backtrack_ticks = closest_position.backtrack_ticks,
            time = globals.curtime()
        })
    end
end

antibruteforce.player_hurt = function(e)
    if e == nil then return end
    
    local plocal = entity.get_local_player()
    local victim = client.userid_to_entindex(e.userid)
    local attacker = client.userid_to_entindex(e.attacker)

    if not entity.is_enemy(attacker)
    or not entity.is_alive(plocal)
    or victim ~= plocal
    or plist.get(attacker, 'Add to whitelist') then
        return
    end

    if var.p_state[5] ~= var.condition_names.normal then
        return
    end

    for i = 1, #antibruteforce.vars.nonweapons do
        if e.weapon == antibruteforce.vars.nonweapons[i] then
            return
        end
    end

    local hitbox = var.hitgroup_names[e.hitgroup]

    local menu_body_yaw = ui.get(ref.body_yaw[2])

    table.insert(antibruteforce.queue.hit, attacker, {
        p_state = var.p_state,
        shot_side = menu_body_yaw > 0 and 'left' or 'right',
        body_yaw_side = antiaim.vars.body_yaw.side and 'left' or 'right',
        slider_body_yaw = menu_body_yaw,
        hitbox = hitbox,
        antiaim_data = antiaim.vars.current_antiaim,
        backtrack_ticks = antibruteforce.cache.last_backtrack_ticks,
        time = globals.curtime()
    })
end

antibruteforce.handle_values = function(type, idx, steamid, data)
    if steamid == nil then
        return
    end

    local condition, state, team, side = data.p_state[1], data.p_state[2], data.p_state[3], data.p_state[4]

    local antibruteforce_simple = function()
        local events = 'aa:antibruteforce:events'

        local index_names = {
            'miss',
            'hit',
            'headshot'
        }

        for i, index in pairs(index_names) do
            if not UI.contains(events, index) then
                goto skip
            end

            if index ~= type then
                goto skip
            end

            if antibruteforce.values.simple[steamid] == nil then
                antibruteforce.values.simple[steamid] = {
                    jitter = {
                        phases = {
                            phase = 0
                        },
                        automatic = {
                            amount = 0
                        }
                    },
                    static = {
                        side = 'left'
                    },
                    active = true,
                    last_time = globals.curtime(),
                    index = idx
                }
            end

            local mode = UI.get('aa:antibruteforce:simple:mode')

            if mode == 'jitter' then
                local jitter_mode = UI.get('aa:antibruteforce:simple:jitter:mode')

                if jitter_mode == 'automatic' then
                    local yaw_jitter_value = client.random_int(30, 70)

                    antibruteforce.values.simple[steamid].jitter.automatic.amount = yaw_jitter_value

                    do
                        local enemy_name = string.sub(entity.get_player_name(idx), 1, 15)

                        notifier.add({
                            time = notifier.time.short,
                            text = {
                                { '[' },
                                { 'bruteforce', true },
                                { '] changed jitter due to ' },
                                { index, true },
                                { ' by \'' },
                                { enemy_name, true },
                                { '\' [' },
                                { antibruteforce.values.simple[steamid].jitter.automatic.amount, true },
                                { ']' }
                            }
                        })
                    end
                elseif jitter_mode == 'phases' then
                    local phase_amount = UI.get('aa:antibruteforce:simple:jitter:phases:amount')
                    
                    antibruteforce.values.simple[steamid].jitter.phases.phase = antibruteforce.values.simple[steamid].jitter.phases.phase % phase_amount
                    antibruteforce.values.simple[steamid].jitter.phases.phase = antibruteforce.values.simple[steamid].jitter.phases.phase + 1

                    do
                        local enemy_name = string.sub(entity.get_player_name(idx), 1, 15)

                        local message = {
                            { '[' },
                            { 'bruteforce', true },
                            { '] changed jitter due to ' },
                            { index, true },
                            { ' by \'' },
                            { enemy_name, true },
                            { '\' [phase: ' },
                            { antibruteforce.values.simple[steamid].jitter.phases.phase, true },
                            { ']' }
                        }
    
                        if data.backtrack_ticks and data.backtrack_ticks > 0 then
                            message = {
                                { '[' },
                                { 'bruteforce', true },
                                { '] changed jitter due to ' },
                                { index, true },
                                { ' at ' },
                                { 'backtrack', true },
                                { ' [ticks: ' },
                                { data.backtrack_ticks, true },
                                { '] by \'' },
                                { enemy_name, true },
                                { '\' [phase: ' },
                                { antibruteforce.values.simple[steamid].jitter.phases.phase, true },
                                { ']' }
                            }
                        end

                        notifier.add({
                            time = notifier.time.short,
                            text = message
                        })
                    end
                end
            elseif mode == 'static' then
                local detect_side = UI.get('aa:antibruteforce:simple:static:detect_side')

                if detect_side then
                    antibruteforce.values.simple[steamid].static.side = data.shot_side == 'left' and 'right' or 'left'
                else
                    antibruteforce.values.simple[steamid].static.side = antibruteforce.values.simple[steamid].static.side == 'left' and 'right' or 'left'
                end

                do
                    local enemy_name = string.sub(entity.get_player_name(idx), 1, 15)

                    local message = {
                        { '[' },
                        { 'bruteforce', true },
                        { '] switched side to ' },
                        { antibruteforce.values.simple[steamid].static.side, true },
                        { ' due to ' },
                        { index, true },
                        { ' by \'' },
                        { enemy_name, true },
                        { '\'' }
                    }

                    if data.backtrack_ticks and data.backtrack_ticks > 0 then
                        message = {
                            { '[' },
                            { 'bruteforce', true },
                            { '] switched side to ' },
                            { antibruteforce.values.simple[steamid].static.side, true },
                            { ' due to ' },
                            { index, true },
                            { ' at ' },
                            { 'backtrack', true },
                            { ' [ticks: ' },
                            { data.backtrack_ticks, true },
                            { '] by \'' },
                            { enemy_name, true },
                            { '\'' }
                        }
                    end

                    notifier.add({
                        time = notifier.time.short,
                        text = message
                    })
                end
            end

            antibruteforce.values.simple[steamid].active = true
            antibruteforce.values.simple[steamid].last_time = globals.curtime()

            ::skip::
        end
    end

    local dynamic = function()
        if type == 'headshot' then
            antiaim.dynamic.values.antiaim_data[steamid][team][state][condition] = nil
            antiaim.dynamic.values.data[steamid] = nil

            do
                local enemy_name = string.sub(entity.get_player_name(idx), 1, 15)

                local message = {
                    { '[' },
                    { 'dynamic', true },
                    { '] reset antiaim data for (' },
                    { ('%s - %s - %s'):format(team, state, condition), true },
                    { ') due to ' },
                    { 'headshot', true },
                    { ' by \'' },
                    { enemy_name, true },
                    { '\'' }
                }

                if data.backtrack_ticks and data.backtrack_ticks > 0 then
                    message = {
                        { '[' },
                        { 'dynamic', true },
                        { '] reset antiaim data for (' },
                        { ('%s - %s - %s'):format(team, state, condition), true },
                        { ') due to ' },
                        { 'headshot', true },
                        { ' at ' },
                        { 'backtrack', true },
                        { ' [ticks: ' },
                        { data.backtrack_ticks, true },
                        { '] by \'' },
                        { enemy_name, true },
                        { '\'' }
                    }
                end

                notifier.add({
                    time = notifier.time.short,
                    text = message
                })
            end

            return
        end

        local events = 'aa:dynamic:antibruteforce:events'

        local index_names = {
            'miss',
            'hit'
        }

        for i, index in pairs(index_names) do
            if not UI.contains(events, index) then
                goto skip
            end

            if index ~= type then
                goto skip
            end

            if antiaim.dynamic.values.data[steamid] == nil then
                antiaim.dynamic.values.data[steamid] = {}
                for i, team in pairs(var.teams) do
                    antiaim.dynamic.values.data[steamid][team] = {}
                    for j, state in pairs(var.states) do
                        antiaim.dynamic.values.data[steamid][team][state] = {}
                        for k, condition in pairs(var.conditions) do
                            antiaim.dynamic.values.data[steamid][team][state][condition] = {
                                yaw = {
                                    left = 0,
                                    right = 0
                                },
                                yaw_jitter_value = 0
                            }
                        end
                    end
                end
            end

            local yaw_add, yaw_jitter_value_add = client.random_int(-5, 5), client.random_int(-10, 10)

            antiaim.dynamic.values.data[steamid][team][state][condition].yaw[data.shot_side] =
            antiaim.dynamic.values.data[steamid][team][state][condition].yaw[data.shot_side] + yaw_add

            antiaim.dynamic.values.data[steamid][team][state][condition].yaw_jitter_value =
            antiaim.dynamic.values.data[steamid][team][state][condition].yaw_jitter_value + yaw_jitter_value_add

            do
                local enemy_name = string.sub(entity.get_player_name(idx), 1, 15)

                local message = {
                    { '[' },
                    { 'dynamic', true },
                    { '] changed due to ' },
                    { index, true },
                    { ' by \'' },
                    { enemy_name, true },
                    { '\'' }
                }

                if data.backtrack_ticks and data.backtrack_ticks > 0 then
                    message = {
                        { '[' },
                        { 'dynamic', true },
                        { '] changed due to ' },
                        { index, true },
                        { ' at ' },
                        { 'backtrack', true },
                        { ' [ticks: ' },
                        { data.backtrack_ticks, true },
                        { '] by \'' },
                        { enemy_name, true },
                        { '\'' }
                    }
                end

                notifier.add({
                    time = notifier.time.short,
                    text = message
                })
            end

            ::skip::
        end
    end

    if condition ~= 'legit aa' and data.p_state[5] == 'normal' then
        if UI.get('aa:antiaim_preset') == 'dynamic' then
            dynamic()
        elseif UI.get('aa:antibruteforce:enable') then
            if UI.get('aa:antibruteforce:type') == 'simple' then
                antibruteforce_simple()
            end
        end
    end
end

antiaim.vars = {
    condition = {
        second = var.condition_names.normal,
        other_antiaim = false
    },
    builder_conditions = {
        team = 'tt',
        state = var.states[1],
        body_side = var.body_sides[1]
    },
    body_yaw = {
        side = false,
        value = 0
    },
    manual = {
        yaw = 0,
        last_press_time = 0  
    },
    freestanding = {
        hotkey = false,
        active = false,
        disabled = false,
        forced = false
    },
    antibruteforce = {
        active = false
    },
    xway = {
        stage = 1
    },
    doubletap = {
        disable = true
    },
    desync = {
        cache = {
            nade_time = 0,
            tickcount = 0,
            ladder_time = 0
        },
        side = false
    },
    current_antiaim = {
        yaw = 0,
        yaw_jitter = 'Off',
        yaw_jitter_value = 0,
        body_yaw = 'Off',
        body_yaw_value = 0,
        freestanding_body_yaw = false,
        fake_limit = 0
    }
}

antiaim.can_use_legit_antiaim = function()
    local plocal = entity.get_local_player()

    local bomb = entity.get_all('CPlantedC4')[1]
    local bomb_pos = vector(entity.get_prop(bomb, 'm_vecOrigin'))

    local player_pos = vector(entity.get_prop(plocal, 'm_vecOrigin'))
    local distance = bomb_pos:dist(player_pos)

    local team_num = entity.get_prop(plocal, 'm_iTeamNum')
    local defusing = team_num == 3 and distance < 60

    local on_bombsite = entity.get_prop(plocal, 'm_bInBombZone')

    local has_bomb = (function()
        local bomb = entity.get_all('CC4')[1]
        return bomb ~= nil and entity.get_prop(bomb, 'm_hOwnerEntity') == plocal
    end)()

    local eye_pos = vector(client.eye_position())
    local pitch, yaw = client.camera_angles()

    local sin_pitch = math.sin(math.rad(pitch))
    local cos_pitch = math.cos(math.rad(pitch))
    local sin_yaw = math.sin(math.rad(yaw))
    local cos_yaw = math.cos(math.rad(yaw))

    local dir_vec = { cos_pitch * cos_yaw, cos_pitch * sin_yaw, -sin_pitch }

    local fraction, entindex = client.trace_line(
        plocal,
        eye_pos.x, eye_pos.y, eye_pos.z,
        eye_pos.x + (dir_vec[1] * 8192), eye_pos.y + (dir_vec[2] * 8192), eye_pos.z + (dir_vec[3] * 8192)
    )

    local using = true

    if entindex ~= nil then
        for i = 1, #antiaim.legit_antiaim.vars.classnames do
            if entity.get_classname(entindex) == antiaim.legit_antiaim.vars.classnames[i] then
                using = false
            end
        end
    end

    if not using and not defusing then
        return true
    end

    return false
end

antiaim.player_condition = function(cmd)
    local plocal = entity.get_local_player()

    local flags = entity.get_prop(plocal, 'm_fFlags')
    local onground = bit.band(flags, 1) == 1 and cmd.in_jump == 0
    local velocity = vector(entity.get_prop(plocal, 'm_vecVelocity')):length2d()
    local legit_aa = UI.get('additions:binds:legitaa:key') and UI.contains('additions:bind_selector', 'legit anti-aim') and antiaim.can_use_legit_antiaim()
    local crouched = entity.get_prop(plocal, 'm_flDuckAmount') == 1 and onground
    local slowwalking = ui.get(ref.slowwalk[2]) and onground and (velocity > 1.02 and velocity ~= 0) and not crouched
    local inair_crouch = not onground and cmd.in_duck == 1
    local inair = not onground
    local fakeducking = ui.get(ref.fakeduck) and onground

    if entity.get_prop(entity.get_game_rules(), 'm_bFreezePeriod') == 1 then
        return var.conditions_to_int['stand']
    end

    if legit_aa then
        return var.conditions_to_int['legit aa']
    elseif inair_crouch then
        return var.conditions_to_int['air crouch']
    elseif inair then
        return var.conditions_to_int['air']
    elseif crouched or fakeducking then
        return var.conditions_to_int['crouch']
    elseif slowwalking then
        return var.conditions_to_int['slowwalk']
    elseif onground and (velocity > 1.02 and velocity ~= 0) then
        return var.conditions_to_int['move']
    else--if onground and velocity < 1.02 then
        return var.conditions_to_int['stand']
    end
end

antiaim.handle = function(self, cmd)
    local plocal = entity.get_local_player()

    local player_state_number = self.player_condition(cmd)

    local holding_exploit = (ui.get(ref.doubletap[1]) and ui.get(ref.doubletap[2])) or (ui.get(ref.onshotaa[1]) and ui.get(ref.onshotaa[2]))
    local exploiting = doubletap_state.charged or (ui.get(ref.onshotaa[1]) and ui.get(ref.onshotaa[2]))

    local state = exploiting and var.states[1] or var.states[2]

    if cmd.chokedcommands == 0 then
        local lp_bodyyaw = entity.get_prop(plocal, 'm_flPoseParameter', 11) * 120 - 60
        
        self.vars.body_yaw.value = lp_bodyyaw
        self.vars.body_yaw.side = lp_bodyyaw > 0

        self.vars.desync.side = cmd.command_number % 4 <= 1
    end

    local current_team_idx = entity.get_prop(plocal, 'm_iTeamNum')

    local team_indexes = {
        number_to_name = {
            [2] = 'terrorist',
            [3] = 'counter terrorist'
        }
    }

    var.p_state = {
        var.conditions[player_state_number],
        state,
        team_indexes.number_to_name[current_team_idx] ~= nil and team_indexes.number_to_name[current_team_idx] or team_indexes.number_to_name[2],
        self.vars.body_yaw.side and var.body_sides[1] or var.body_sides[2],
        self.vars.condition.second,
        player_state_number
    }

    if exploiting then
        cmd.no_choke = true
    end

    ui.set(ref.doubletap[1], not self.vars.doubletap.disable)
    ui.set(ref.doubletap_mode, 'Defensive')

    self.vars.doubletap.disable = false

    local force_defensive = false

    if UI.contains('additions:bind_selector', 'force defensive') then
        force_defensive = self.handle_force_defensive()

        if UI.get('additions:binds:force_defensive:key') then
            force_defensive = true
        end
    end

    if UI.contains('additions:bind_selector', 'cross assistant') and UI.get('additions:binds:cross_assistant:key') then
        if self.cross_assistant.handle() then
            ui.set(ref.doubletap[1], false)
            self.vars.doubletap.disable = true
        end

        force_defensive = false
    else
        self.cross_assistant.vars.activated = false
        self.cross_assistant.vars.charge_time = 0
        self.cross_assistant.vars.ready = false
    end

    -- cmd.force_defensive = (cmd.command_number % 28 == 0)

    -- if cmd.command_number % 32 == 0 then
    --     cmd.force_defensive = force_defensive
    -- end

    cmd.force_defensive = force_defensive

    ui.set(ref.antiaim_references.other.enabled, true)
    ui.set(ref.antiaim_references.other.roll, 0)
    ui.set(ref.antiaim_references.other.freestanding_key, 'Always on')
    ui.set(ref.antiaim_references.other.edge_yaw, false)

    ui.set(UI.get_element('additions:binds:manual:key:right'), 'On hotkey')
    ui.set(UI.get_element('additions:binds:manual:key:left'), 'On hotkey')
    ui.set(UI.get_element('additions:binds:manual:key:forward'), 'On hotkey')
end

antiaim.handle_yaw_offset = function(left_value, right_value)
    return antiaim.vars.body_yaw.side and left_value or right_value
end

antiaim.get_target = function()
    local current_threat = client.current_threat()

    if current_threat == nil then
        return nil, nil
    end

    local steamid = entity.get_steam64(current_threat)

    return current_threat, tostring(steamid)
end

antiaim.handle_force_defensive = function()
    if UI.contains('additions:binds:force_defensive:conditions', 'stand') and var.p_state[1] == 'stand'
    or UI.contains('additions:binds:force_defensive:conditions', 'move') and (
        var.p_state[1] ~= 'stand' and var.p_state[1] ~= 'air crouch' and var.p_state[1] ~= 'air' and var.p_state[1] ~= 'crouch'
    ) or UI.contains('additions:binds:force_defensive:conditions', 'in air') and (
        var.p_state[1] == 'air crouch' or var.p_state[1] == 'air'
    ) or UI.contains('additions:binds:force_defensive:conditions', 'quickpeeking') and(
        doubletap_state.charged and (ui.get(ref.quickpeek[1]) and ui.get(ref.quickpeek[2]))
    ) then
        return true
    end

    return false
end

antiaim.cross_assistant = {
    vars = {
        last_charge_time = 0,
        activated = false,
        charge_time = 0,
        ready = false
    }
}

antiaim.cross_assistant.handle = function()
    local wait_ticks = 1
    
    if doubletap_state.charged and not antiaim.cross_assistant.vars.activated then
        antiaim.cross_assistant.vars.last_charge_time = globals.curtime()
        antiaim.cross_assistant.vars.activated = true
    end

    if not doubletap_state.charged and doubletap_state.defensive.choke_until - globals.tickcount() < -wait_ticks then
        antiaim.cross_assistant.vars.activated = false
        antiaim.cross_assistant.vars.charge_time = 0
    else
        antiaim.cross_assistant.vars.charge_time = globals.curtime() - antiaim.cross_assistant.vars.last_charge_time
    end

    antiaim.cross_assistant.vars.ready = antiaim.cross_assistant.vars.charge_time > .6
    
    if doubletap_state.defensive.choke_until - globals.tickcount() <= 0
    and doubletap_state.defensive.choke_until - globals.tickcount() >= -wait_ticks
    and antiaim.cross_assistant.vars.ready then
        return true
    end

    return false
end

antiaim.manual_antiaim = {}

antiaim.manual_antiaim.handle = function()
    local curtime = globals.curtime()
    
    if UI.get('additions:binds:manual:key:right') and antiaim.vars.manual.last_press_time + .2 < curtime then
        antiaim.vars.manual.yaw = antiaim.vars.manual.yaw == 90 and 0 or 90
        antiaim.vars.manual.last_press_time = curtime
    elseif UI.get('additions:binds:manual:key:left') and antiaim.vars.manual.last_press_time + .2 < curtime then
        antiaim.vars.manual.yaw = antiaim.vars.manual.yaw == -90 and 0 or -90
        antiaim.vars.manual.last_press_time = curtime
    elseif UI.get('additions:binds:manual:key:forward') and antiaim.vars.manual.last_press_time + .2 < curtime then
        antiaim.vars.manual.yaw = antiaim.vars.manual.yaw == 180 and 0 or 180
        antiaim.vars.manual.last_press_time = curtime
    elseif antiaim.vars.manual.last_press_time > curtime then
        antiaim.vars.manual.last_press_time = curtime
    end
end

antiaim.manual_antiaim.set = function(idx, steamid, team, state, body_side, condition, cmd, roll)
    local data = {
        yaw = antiaim.vars.manual.yaw,
        yaw_jitter = 'Off',
        yaw_jitter_value = 0,
        body_yaw = 'Static',
        body_yaw_value = -180,
        freestanding_body_yaw = false,
        fake_limit = 60
    }

    if roll then
        cmd.roll = 50
    end

    return data
end

antiaim.handle_freestand_disablers = function(condition)
    local disable = false

    if condition == 'legit aa' then
        disable = true
    elseif antiaim.vars.condition.other_antiaim then
        disable = true
    elseif UI.contains('additions:binds:freestand:disablers', 'crouch') and condition == 'crouch'
    or UI.contains('additions:binds:freestand:disablers', 'in air') and (condition == 'air crouch' or condition == 'air')
    or UI.contains('additions:binds:freestand:disablers', 'slowwalk') and condition == 'slowwalk'
    or UI.contains('additions:binds:freestand:disablers', 'move') and condition == 'move' then
        disable = true
    end

    return disable
end

antiaim.legit_antiaim = {
    vars = {
        classnames = {
            'CWorld',
            'CCSPlayer',
            'CFuncBrush'
        }
    }
}

antiaim.legit_antiaim.set = function(idx, steamid, team, state, body_side, condition)  
    local side = globals.tickcount() % 16 <= 7

    local data = {
        left = {
            yaw = -180,
            yaw_jitter = 'Center',
            yaw_jitter_value = 42,
            body_yaw = 'Static',
            body_yaw_value = side and -90 or 90,
            freestanding_body_yaw = true,
            fake_limit = 60
        },
        right = {
            yaw = -180,
            yaw_jitter = 'Center',
            yaw_jitter_value = 42,
            body_yaw = 'Static',
            body_yaw_value = side and -90 or 90,
            freestanding_body_yaw = true,
            fake_limit = 60
        }
    }

    return data[body_side]
end

antiaim.builder = {}

antiaim.builder.set = function(idx, steamid, team, state, body_side, condition)
    local builder_data = {
        yaw = UI.get(('aa:builder:states:%s:%s:%s:%s:yaw_value'):format(team, state, condition, body_side)),
        yaw_jitter = UI.get(('aa:builder:states:%s:%s:%s:%s:yaw_jitter'):format(team, state, condition, body_side)),
        yaw_jitter_value = UI.get(('aa:builder:states:%s:%s:%s:%s:yaw_jitter_value'):format(team, state, condition, body_side)),
        body_yaw = UI.get(('aa:builder:states:%s:%s:%s:%s:body_yaw'):format(team, state, condition, body_side)),
        body_yaw_value = UI.get(('aa:builder:states:%s:%s:%s:%s:body_yaw_value'):format(team, state, condition, body_side)),
        freestanding_body_yaw = false,
        fake_limit = UI.get(('aa:builder:states:%s:%s:%s:%s:fake_limit'):format(team, state, condition, body_side))
    }

    local xway_data = {
        mode = UI.get(('aa:builder:states:%s:%s:%s:%s:yaw_jitter:xway:mode'):format(team, state, condition, body_side)),
        values = {
            UI.get(('aa:builder:states:%s:%s:%s:%s:xway:manual:value:1'):format(team, state, condition, body_side)),
            UI.get(('aa:builder:states:%s:%s:%s:%s:xway:manual:value:2'):format(team, state, condition, body_side)),
            UI.get(('aa:builder:states:%s:%s:%s:%s:xway:manual:value:3'):format(team, state, condition, body_side)),
            UI.get(('aa:builder:states:%s:%s:%s:%s:xway:manual:value:4'):format(team, state, condition, body_side)),
            UI.get(('aa:builder:states:%s:%s:%s:%s:xway:manual:value:5'):format(team, state, condition, body_side))
        }
    }

    if builder_data.yaw_jitter == '3-way' or builder_data.yaw_jitter == '5-way' then
        if xway_data.mode == 'manual' then
            builder_data.yaw_jitter_value = xway_data.values
        end
    end

    return builder_data
end

antiaim.dynamic = {
    values = {
        data = {},
        antiaim_data = {}
    }
}

antiaim.dynamic.reset_values = function()
    antiaim.dynamic.values.data = {}
    -- antiaim.dynamic.values.antiaim_data = {}
end

antiaim.dynamic.reset_round_start = function()
    antiaim.dynamic.reset_values()

    do
        -- if not UI.get('vis.notifier.style') ~= '-' then
            notifier.add({
                time = notifier.time.short,
                text = {
                    { '[' },
                    { 'dynamic', true },
                    { '] data has been reset due to (' },
                    { 'round start', true },
                    { ')' }
                }
            })
        -- end
    end
end

antiaim.dynamic.reset_connect = function(e)
    if client.userid_to_entindex(e.userid) == entity.get_local_player() then
        antiaim.dynamic.reset_values()

        do
            -- if not UI.get('vis.notifier.style') ~= '-' then
                notifier.add({
                    time = notifier.time.short,
                    text = {
                        { '[' },
                        { 'dynamic', true },
                        { '] data has been reset due to (' },
                        { 'connect', true },
                        { ')' }
                    }
                })
            -- end
        end
    end
end

antiaim.dynamic.set = function(idx, steamid, team, state, body_side, condition)
    local dynamic_data = {
        left = {
            yaw = 0,
            yaw_jitter = 'Off',
            yaw_jitter_value = 0,
            body_yaw = 'Off',
            body_yaw_value = 0,
            freestanding_body_yaw = false,
            fake_limit = 0
        },
        right = {
            yaw = 0,
            yaw_jitter = 'Off',
            yaw_jitter_value = 0,
            body_yaw = 'Off',
            body_yaw_value = 0,
            freestanding_body_yaw = false,
            fake_limit = 0
        }
    }

    do
        if steamid == nil then
            goto skip
        end

        if antiaim.dynamic.values.antiaim_data[steamid] == nil then
            antiaim.dynamic.values.antiaim_data[steamid] = {}
        end

        if antiaim.dynamic.values.antiaim_data[steamid][team] == nil then
            antiaim.dynamic.values.antiaim_data[steamid][team] = {}
        end

        if antiaim.dynamic.values.antiaim_data[steamid][team][state] == nil then
            antiaim.dynamic.values.antiaim_data[steamid][team][state] = {}
        end

        if antiaim.dynamic.values.antiaim_data[steamid][team][state][condition] == nil then
            local values = {
                yaw = {
                    left = client.random_int(-15, -5),
                    right = client.random_int(5, 15)
                },
                yaw_jitter_value = client.random_int(40, 70)
            }

            local xway_chance_ref = UI.get('aa:dynamic:xway_chance')
            local chance = client.random_int(0, 100) <= xway_chance_ref
            local xway = chance and state == var.states[1]
            local yaw_jitter = xway and '3-way' or 'Center'

            antiaim.dynamic.values.antiaim_data[steamid][team][state][condition] = {
                left = {
                    yaw = values.yaw.left,
                    yaw_jitter = yaw_jitter,
                    yaw_jitter_value = values.yaw_jitter_value,
                    body_yaw = 'Jitter',
                    body_yaw_value = 0,
                    freestanding_body_yaw = false,
                    fake_limit = 60
                },
                right = {
                    yaw = values.yaw.right,
                    yaw_jitter = yaw_jitter,
                    yaw_jitter_value = values.yaw_jitter_value,
                    body_yaw = 'Jitter',
                    body_yaw_value = 0,
                    freestanding_body_yaw = false,
                    fake_limit = 60
                }
            }
        end

        dynamic_data = antiaim.dynamic.values.antiaim_data[steamid][team][state][condition]

        ::skip::
    end

    local yaw_left, yaw_right, yaw_jitter_value = 0, 0, 0

    if antiaim.dynamic.values.data[steamid] ~= nil then
        yaw_left, yaw_right, yaw_jitter_value =
        antiaim.dynamic.values.data[steamid][team][state][condition].yaw.left,
        antiaim.dynamic.values.data[steamid][team][state][condition].yaw.right,
        antiaim.dynamic.values.data[steamid][team][state][condition].yaw_jitter_value
    end

    local data = {
        left = {
            yaw = dynamic_data.left.yaw + yaw_left,
            yaw_jitter = dynamic_data.left.yaw_jitter,
            yaw_jitter_value = dynamic_data.left.yaw_jitter_value + yaw_jitter_value,
            body_yaw = dynamic_data.left.body_yaw,
            body_yaw_value = dynamic_data.left.body_yaw_value,
            freestanding_body_yaw = dynamic_data.left.freestanding_body_yaw,
            fake_limit = dynamic_data.left.fake_limit
        },
        right = {
            yaw = dynamic_data.right.yaw + yaw_right,
            yaw_jitter = dynamic_data.right.yaw_jitter,
            yaw_jitter_value = dynamic_data.right.yaw_jitter_value + yaw_jitter_value,
            body_yaw = dynamic_data.right.body_yaw,
            body_yaw_value = dynamic_data.right.body_yaw_value,
            freestanding_body_yaw = dynamic_data.right.freestanding_body_yaw,
            fake_limit = dynamic_data.right.fake_limit
        }
    }

    return data[body_side]
end

antiaim.antibruteforce = {}

antiaim.antibruteforce.handle = function(idx, steamid, team, state, body_side, condition, antiaim_data)
    local data = antiaim_data

    local antibruteforce_type = UI.get('aa:antibruteforce:type')

    if antibruteforce_type == 'simple' then
        if antibruteforce.values.simple[steamid] == nil then
            goto skip
        end

        local active = antibruteforce.values.simple[steamid].active

        if not active then
            goto skip
        end

        local type = UI.get('aa:antibruteforce:simple:mode')

        if type == 'jitter' then
            local mode = UI.get('aa:antibruteforce:simple:jitter:mode')

            if mode == 'automatic' then
                data.yaw_jitter_value = antibruteforce.values.simple[steamid].jitter.automatic.amount
            elseif mode == 'phases' then
                local phase = antibruteforce.values.simple[steamid].jitter.phases.phase

                if phase ~= 0 then
                    local yaw_jitter_value_ref = UI.get(('aa:dynamic:antibruteforce:simple:jitter:phases:%d:yaw_jitter'):format(phase))

                    data.yaw_jitter_value = yaw_jitter_value_ref
                end
            end
        elseif type == 'static' then
            local side = antibruteforce.values.simple[steamid].static.side

            data.yaw = 0
            data.yaw_jitter = 'Off'
            data.yaw_jitter_value = 0
            data.body_yaw = 'Static'
            data.body_yaw_value = side == 'left' and 90 or -90
            data.freestanding_body_yaw = false
            data.fake_limit = 60
        end
    end

    ::skip::

    return data
end

antiaim.antibruteforce.reset = {
    vars = {
        last_curtime = globals.curtime()
    }
}

antiaim.antibruteforce.reset.on_round_start = function()
    antibruteforce.values.simple = {}

    do
        notifier.add({
            time = notifier.time.medium,
            text = {
                { '[' },
                { 'bruteforce', true },
                { '] reset data for ' },
                { 'all', true },
                { ' enemies due to ' },
                { 'round start', true }
            }
        })
    end
end

antiaim.antibruteforce.reset.on_shooter_death = function(e)
    local target = client.userid_to_entindex(e.userid)
    local target_steamid = tostring(entity.get_steam64(target))

    if antibruteforce.values.simple[target_steamid] == nil then
        return
    end

    if not antibruteforce.values.simple[target_steamid].active then
        return
    end

    antibruteforce.values.simple[target_steamid].active = false

    do
        local target_name = string.sub(entity.get_player_name(target), 1, 15)

        notifier.add({
            time = notifier.time.medium,
            text = {
                { '[' },
                { 'bruteforce', true },
                { '] reset data for \'' },
                { target_name, true },
                { '\' due to ' },
                { 'shooter death', true }
            }
        })
    end
end

antiaim.antibruteforce.reset.time = function()
    local current_time = globals.curtime()

    local time_reset = function()
        local reset_time = UI.get('aa:antibruteforce:reset_events:time')

        for steamid, data in pairs(antibruteforce.values.simple) do
            if not data.active then
                goto skip
            end

            if current_time > data.last_time + reset_time then
                antibruteforce.values.simple[steamid].active = false

                do
                    local target_name = string.sub(entity.get_player_name(data.index), 1, 15)

                    notifier.add({
                        time = notifier.time.medium,
                        text = {
                            { '[' },
                            { 'bruteforce', true },
                            { '] reset data for \'' },
                            { target_name, true },
                            { '\' due to ' },
                            { 'time', true }
                        }
                    })
                end
            end

            ::skip::
        end
    end

    if antiaim.antibruteforce.reset.vars.last_curtime < current_time - 1 then
        time_reset()

        antiaim.antibruteforce.reset.vars.last_curtime = current_time
    elseif antiaim.antibruteforce.reset.vars.last_curtime > current_time then
        antiaim.antibruteforce.reset.vars.last_curtime = current_time
    end
end

client.register_esp_flag('1', 255, 255, 255, function(entindex)
    local steamid = tostring(entity.get_steam64(entindex))
    if UI.get('aa:antiaim_preset') == 'dynamic' then return false end
    if not UI.get('aa:antibruteforce:enable') then return false end
    if not entity.is_alive(entity.get_local_player()) or entity.is_dormant(entindex) or antibruteforce.values.simple[steamid] == nil then return false end
    if not antibruteforce.values.simple[steamid].active then return false end

    local type = UI.get('aa:antibruteforce:simple:mode')

    if type == 'jitter' then
        local mode = UI.get('aa:antibruteforce:simple:jitter:mode')

        if mode == 'automatic' then
            return true, ('JITTER:%d'):format(antibruteforce.values.simple[steamid].jitter.automatic.amount)
        elseif mode == 'phases' then
            local phase = antibruteforce.values.simple[steamid].jitter.phases.phase

            if phase ~= 0 then
                return true, ('PHASE:%d'):format(phase)
            end
        end
    elseif type == 'static' then
        local side = antibruteforce.values.simple[steamid].static.side

        return true, ('SIDE:%s'):format(side:upper())
    end
end)

antiaim.set_antiaim_values = function(antiaim_data)
    local final_data = {
        antiaim_data.yaw,
        antiaim_data.yaw_jitter,
        antiaim_data.yaw_jitter_value,
        antiaim_data.body_yaw,
        antiaim_data.body_yaw_value,
        antiaim_data.freestanding_body_yaw,
        antiaim_data.fake_limit
    }

    for i = 1, #ref.antiaim_references.main do
        local item = ref.antiaim_references.main[i]
        local current_value = final_data[i]

        ui.set(item, current_value)
    end
end

antiaim.handle_antiaim_data = function(cmd, antiaim_data)
    local data = antiaim_data

    local xway = data.yaw_jitter == '3-way' or data.yaw_jitter == '5-way'

    if xway then
        if cmd.command_number % 2 == 0 then
            antiaim.vars.xway.stage = antiaim.vars.xway.stage % tonumber(data.yaw_jitter:sub(1, 1))
            antiaim.vars.xway.stage = antiaim.vars.xway.stage + 1
        end

        if type(data.yaw_jitter_value) == 'table' then
            local stages = {
                data.yaw_jitter_value[1],
                data.yaw_jitter_value[2],
                data.yaw_jitter_value[3],
                data.yaw_jitter_value[4],
                data.yaw_jitter_value[5]
            }

            data.yaw = math.clamp(data.yaw + stages[antiaim.vars.xway.stage], -180, 180)
            data.yaw_jitter = 'Off'
            data.yaw_jitter_value = 0
        else
            local stages = {
                ['3-way'] = {
                    -data.yaw_jitter_value / 2,
                    0,
                    data.yaw_jitter_value / 2
                },
                ['5-way'] = {
                    -data.yaw_jitter_value,
                    -data.yaw_jitter_value / 2,
                    0,
                    data.yaw_jitter_value / 2,
                    data.yaw_jitter_value
                }
            }

            data.yaw = math.clamp(data.yaw + stages[data.yaw_jitter][math.clamp(antiaim.vars.xway.stage, 1, tonumber(data.yaw_jitter:sub(1, 1)))], -180, 180)
            data.yaw_jitter = 'Off'
            data.yaw_jitter_value = 0
        end
    end

    if data.yaw_jitter == 'Off' then
        data.yaw_jitter_value = 0
    end

    if data.body_yaw == 'Off' then
        data.body_yaw_value = 0
    end

    return data, xway
end

antiaim.set_antiaim = function(self, cmd)
    local idx, steamid = self.get_target()
    local condition, state, team, body_side = var.p_state[1], var.p_state[2], var.p_state[3], var.p_state[4]

    local legitaa_on = condition == 'legit aa'

    if UI.contains('additions:bind_selector', 'manual anti-aim') then
        self.manual_antiaim.handle()
    else
        self.vars.manual.yaw = 0
    end

    if self.vars.freestanding.forced and not legitaa_on then
        self.vars.freestanding.hotkey = UI.contains('additions:bind_selector', 'freestand') and UI.get('additions:binds:freestand:key')
        self.vars.freestanding.disabled = false
        self.vars.freestanding.active = true

        ui.set(ref.freestanding[1], true)
    elseif UI.contains('additions:bind_selector', 'freestand') and UI.get('additions:binds:freestand:key') then
        self.vars.freestanding.hotkey = true
        self.vars.freestanding.disabled = self.handle_freestand_disablers(condition)
        self.vars.freestanding.active = not self.vars.freestanding.disabled

        ui.set(ref.freestanding[1], self.vars.freestanding.active)
    else
        self.vars.freestanding.hotkey = false
        self.vars.freestanding.disabled = false
        self.vars.freestanding.active = false

        ui.set(ref.freestanding[1], false)
    end

    self.vars.freestanding.forced = false

    local pitch_value = 'Default'
    local yaw_base_value = 'At targets'
    local yaw_value = '180'

    local curr_preset = UI.get('aa:antiaim_preset')

    local antiaim_data = {
        yaw = 0,
        yaw_jitter = 'Off',
        yaw_jitter_value = 0,
        body_yaw = 'Off',
        body_yaw_value = 0,
        freestanding_body_yaw = false,
        fake_limit = 0
    }

    local custom_codition, other_antiaim = 'normal', false

    if legitaa_on then        
        cmd.in_use = 0

        pitch_value = 'Off'
        yaw_base_value = 'Local view'

        antiaim_data = self.legit_antiaim.set(idx, steamid, team, state, body_side, condition)
    elseif self.vars.manual.yaw ~= 0 then
        local roll = false
        local roll_index = roll and 'roll' or 'normal'

        custom_codition = self.vars.manual.yaw ~= 180 and (
            self.vars.manual.yaw == 90
            and var.condition_names.manual[roll_index].right
            or var.condition_names.manual[roll_index].left
        ) or var.condition_names.manual[roll_index].forward
        other_antiaim = true

        yaw_base_value = 'Local view'

        antiaim_data = self.manual_antiaim.set(idx, steamid, team, state, body_side, condition, cmd, roll)
    elseif UI.contains('additions:bind_selector', 'breaker')
    and UI.get('additions:binds:breaker:key')
    and doubletap_state.defensive.choke_until - 1 > globals.tickcount() then
        custom_codition = 'breaker'
        other_antiaim = true

        local data = {
            yaw = cmd.command_number % 4 <= 1 and 100 or -100,
            yaw_jitter = 'Off',
            yaw_jitter_value = 0,
            body_yaw = 'Off',
            body_yaw_value = 0,
            freestanding_body_yaw = false,
            fake_limit = 60
        }

        pitch_value = 'Random'

        antiaim_data = data
    else
        if curr_preset == 'dynamic' then
            antiaim_data = self.dynamic.set(idx, steamid, team, state, body_side, condition)
        else
            if curr_preset == 'experimental' then
                antiaim_data = experimental_data()[team][state][condition][body_side]
            elseif curr_preset == 'configurator' then
                local b_team, b_state, b_body_side, b_condition = var.teams[1], var.states[1], var.body_sides[1], condition

                if UI.contains('aa:builder:builder_options', 'team based') then
                    b_team = team
                end

                if UI.contains('aa:builder:builder_options', 'state based') then
                    b_state = state
                end

                if UI.contains('aa:builder:builder_options', 'body side based') then
                    b_body_side = body_side
                end

                local preview_state = UI.get('aa:builder:preview_selected_state')

                if preview_state and ui.is_menu_open() then           
                    b_team = UI.get('aa:builder:team_selector')
                    b_state = UI.get('aa:builder:state_selector')
                    b_body_side = UI.get('aa:builder:body_side_selector')
                    b_condition = UI.get('aa:builder:condition_selector')
                end

                antiaim_data = self.builder.set(idx, steamid, b_team, b_state, b_body_side, b_condition)
            end

            if UI.get('aa:antibruteforce:enable') then
                antiaim_data = self.antibruteforce.handle(idx, steamid, team, state, body_side, condition, antiaim_data)
            end
        end
    end

    self.vars.current_antiaim = antiaim_data

    local final_data, xway = self.handle_antiaim_data(cmd, antiaim_data)

    self.set_antiaim_values(final_data)

    ui.set(ref.antiaim_references.other.pitch_mode, pitch_value)
    ui.set(ref.antiaim_references.other.yaw_base, yaw_base_value)
    ui.set(ref.antiaim_references.other.yaw, yaw_value)

    self.vars.condition.other_antiaim = other_antiaim
    self.vars.condition.second = custom_codition
end

local Draw = {
    rectangle = LPH_JIT_MAX(function(position, size, clr, rounding)
        local r, g, b, a = clr.r, clr.g, clr.b, clr.a

        if not rounding or rounding == 0 then
            renderer.rectangle(position.x, position.y, size.x, size.y, r, g, b, a)
            return
        end

        if type(rounding) == 'number' then
            local rectangle_data = {
                { position.x + rounding, position.y + rounding, size.x - rounding * 2, size.y - rounding * 2 },
                { position.x + rounding, position.y, size.x - rounding * 2, rounding },
                { position.x + size.x - rounding, position.y + rounding, rounding, size.y - rounding * 2 },
                { position.x + rounding, position.y + size.y - rounding, size.x - rounding * 2, rounding },
                { position.x, position.y + rounding, rounding, size.y - rounding * 2 }
            }

            local circle_data = {
                { position.x + rounding, position.y + rounding, 180 },
                { position.x + size.x - rounding, position.y + rounding, 90 },
                { position.x + size.x - rounding, position.y + size.y - rounding, 360 },
                { position.x + rounding, position.y + size.y - rounding, 270 },
            }

            for i = 1, #rectangle_data do
                local data = rectangle_data[i]
                renderer.rectangle(data[1], data[2], data[3], data[4], r, g, b, a)
            end

            for i = 1, #circle_data do
                local data = circle_data[i]
                renderer.circle(data[1], data[2], r, g, b, a, rounding, data[3], .25)
            end
        elseif type(rounding) == 'table' then
            local active_corners = rounding.active_corners
            local rounding = rounding.rounding

            local rectangle_data = {
                { position.x + rounding, position.y + rounding, size.x - rounding * 2, size.y - rounding * 2 },
                { position.x, position.y, size.x - rounding, rounding },
                { position.x + size.x - rounding, position.y, rounding, size.y - rounding },
                { position.x + rounding, position.y + size.y - rounding, size.x - rounding, rounding },
                { position.x, position.y + rounding, rounding, size.y - rounding }
            }

            for i = 1, #active_corners do
                local data = {
                    { position.x + rounding, position.y, size.x - rounding * 2, rounding },
                    { position.x + size.x - rounding, position.y + rounding, rounding, size.y - rounding * 2 },
                    { position.x + rounding, position.y + size.y - rounding, size.x - rounding * 2, rounding },
                    { position.x, position.y + rounding, rounding, size.y - rounding * 2 }
                }

                if active_corners[i] then
                    rectangle_data[i + 1] = data[i]
                end
            end

            local circle_data = {
                { position.x + rounding, position.y + rounding, 180 }, --left top
                { position.x + size.x - rounding, position.y + rounding, 90 }, --right top
                { position.x + size.x - rounding, position.y + size.y - rounding, 360 }, --right bottom
                { position.x + rounding, position.y + size.y - rounding, 270 }, --left bottom
            }

            for i = 1, #rectangle_data do
                local data = rectangle_data[i]
                renderer.rectangle(data[1], data[2], data[3], data[4], r, g, b, a)
            end

            for i = 1, #circle_data do
                local data = circle_data[i]

                if active_corners[i] then
                    renderer.circle(data[1], data[2], r, g, b, a, rounding, data[3], .25)
                end
            end
        end
    end),

    rectangle_outline = LPH_JIT_MAX(function(position, size, clr, rounding, thickness)
        local r, g, b, a = clr.r, clr.g, clr.b, clr.a

        local rectangle_data = {
            { position.x + rounding, position.y, size.x - rounding * 2, thickness },
            { position.x + size.x - thickness, position.y + rounding, thickness, size.y - rounding * 2 },
            { position.x + rounding, position.y + size.y - thickness, size.x - rounding * 2, thickness },
            { position.x, position.y + rounding, thickness, size.y - rounding * 2 }
        }

        local circle_data = {
            { position.x + rounding, position.y + rounding, 180 },
            { position.x + size.x - rounding, position.y + rounding, 270 },
            { position.x + size.x - rounding, position.y + size.y - rounding, 360 },
            { position.x + rounding, position.y + size.y - rounding, 90 },
        }

        for i = 1, #rectangle_data do
            local data = rectangle_data[i]
            renderer.rectangle(data[1], data[2], data[3], data[4], r, g, b, a)
        end

        if rounding > 0 then
            for i = 1, #circle_data do
                local data = circle_data[i]
                renderer.circle_outline(data[1], data[2], r, g, b, a, rounding, data[3], .25, thickness)
            end
        end
    end),

    shadow = LPH_JIT_MAX(function(self, pos, size, clr, rounding, steps, inside)
        if clr.a <= 0 then
            return
        end

        local accuracy = 1
        local clr = { r = clr.r, g = clr.g, b = clr.b, a = clr.a }

        if inside then
            self.rectangle(pos, size, clr, rounding)
        end

        for i = 1, steps do
            clr.a = clr.a * ((steps - (i - 1)) / steps) ^ 2

            if clr.a > 1 then
                self.rectangle_outline(
                    vector(pos.x - i * accuracy, pos.y - i * accuracy), vector(size.x + i * accuracy * 2, size.y + i * accuracy * 2),
                    clr, rounding + i * accuracy, accuracy
                )
            end
        end
    end)
}

local indicators = {
    center = {
        values = {
            scope = smoothy:new(0),
            hurt_anim = 0,
            dt = {
                fraction = smoothy:new(1),
                alpha = 0,
                offset = smoothy:new(0),
                last_text = '',
                values = { 0, 0, 0, 0, 0 }
            },
            hs = {
                fraction = smoothy:new(1),
                alpha = 0,
                values = { 0, 0, 0, 0, 0 },
                offset = smoothy:new(0),
                last_text = ''
            },
            fs = {
                fraction = smoothy:new(1),
                alpha = 0,
                values = { 0, 0, 0 },
                offset = smoothy:new(0),
                last_text = ''
            },
            other_binds = {
                fb = {
                    active = 0
                },
                sp = {
                    active = 0
                },
                alpha = 0,
                offset = smoothy:new(0)
            },
            state = {
                fraction = smoothy:new(1)
            },
        }
    },
    arrows = {
        values = {
            fractions = { left = 0, right = 0, forward = 0 },
            scope = 0
        }
    },
    vars = {
        nade_names = {
            'CHEGrenade', 'CFlashbang', 'CSmokeGrenade', 'CDecoyGrenade', 'CIncendiaryGrenade', 'CMolotovGrenade'
        }
    }
}

indicators.center.draw = LPH_JIT_MAX(function()
    local plocal = entity.get_local_player()
    if not entity.is_alive(plocal) then return end

    local values = indicators.center.values

    local screen_size = vector(client.screen_size())

    local ind_height = UI.get('visuals:indicators:height')

    local pos = screen_size / 2 + vector(0, ind_height)

    local color_ref = script_db.get_accent_color()
    local color = { r = color_ref[1], g = color_ref[2], b = color_ref[3], a = 255 }

    local frametime = globals.frametime()
    local speed, state_speed, offset_speed, scope_speed = .04, .03, .05, .06

    local font_style = UI.get('visuals:indicators:font_style')

    local fonts = {
        ['small'] = '-',
        ['normal'] = '',
        ['bold'] = 'b'
    }

    local font = fonts[font_style]

    local spacing = font == '-' and '  ' or ' '
    local text_func = font == '-' and 'upper' or 'lower'

    local offset = vector()

    local scoped = entity.get_prop(plocal, 'm_bIsScoped') == 1
    local scope_enabled = (UI.contains('visuals:indicators:adjustments', 'move indicators on scope')
    and scoped) or (UI.contains('visuals:indicators:adjustments', 'move indicators on nade')
    and FN.check_weapons(indicators.vars.nade_names))

    local doubletap = ui.get(ref.doubletap[1]) and ui.get(ref.doubletap[2])
    local lp_weapon = entity.get_player_weapon(plocal)
    local waiting_wpn = not FN.can_shoot()

    values.scope(scope_speed, scope_enabled)
    local scope_fraction = values.scope.value

    if scope_fraction < .03 then
        scope_fraction = 0
    elseif scope_fraction > .95 then
        scope_fraction = 1
    end

    do
        local name = string[text_func](script_db.lua_name)

        values.hurt_anim = math.clamp(values.hurt_anim - frametime * .7, 0, 1)
        local hurt_anim = easing.quad_out(values.hurt_anim, 0, 1, 1)

        local name_color = FN.color_swap({ 255, 255, 255, 255 }, { 255, 70, 70, 255 }, hurt_anim)
        local name_final = FN.colored_text(name, name_color)

        local version = string[text_func](script_db.version)
        local version_final = FN.gradient_text_anim(version, { 210, 210, 210, 150 }, { color.r, color.g, color.b, 255 }, 4)

        local text = name .. spacing .. version_final
        local text_size = vector(renderer.measure_text(font, text))

        local scope_text = math.floor(-(text_size.x / 2) * (1 - scope_fraction) + 3 * scope_fraction)

        renderer.text(pos.x + scope_text, pos.y, 255, 255, 255, 255, font, nil, text)

        offset.y = offset.y + (text_size.y - 1)
    end

    do
        local doubletap_charge = doubletap_state.charged
        local defensive_charged = doubletap_state.defensive.charged
        local work = doubletap

        values.dt.alpha = math.clamp(values.dt.alpha + (work and frametime * 2.5 or -frametime * 6), 0, 1)
        local alpha = values.dt.alpha

        local value = 0

        local text = FN.gradient_text(string[text_func]('DT'), { 255, 255, 255, 255 }, { 255, 255, 255, 150 }, 1 - values.dt.values[3])
        local text_size = vector(renderer.measure_text(font, text))

        local second_text = ''

        values.dt.values[3] = math.clamp(values.dt.values[3] + (waiting_wpn and frametime * 5 or -frametime * 5), 0, 1)
        local waiting = values.dt.values[3]

        if alpha > 0 then
            if work and alpha > .1 then
                value = text_size.x
            end

            local waiting_text = string[text_func]('WAITING')
            local waiting_text_final = FN.colored_text(waiting_text, { 255, 50, 50, 150 })
            local waiting_text_size = vector(renderer.measure_text(font, spacing .. waiting_text))

            values.dt.values[1] = math.clamp(
                values.dt.values[1] + ((alpha == 1 and not waiting_wpn) and frametime * 6 or -frametime * 9), 0, 1
            )
            local recharge = values.dt.values[1]

            values.dt.values[2] = math.clamp(values.dt.values[2] + ((recharge == 1 and doubletap_charge) and frametime * 4 or -frametime * 6), 0, 1)
            local recharge_hide = values.dt.values[2]

            local recharge_text = string[text_func]('CHARGING')
            local recharge_text_final = FN.gradient_text(recharge_text, { 255, 193, 69, 255 }, { 255, 90, 90, 150 }, recharge)
            local recharge_text_size = vector(renderer.measure_text(font, spacing .. recharge_text))

            values.dt.values[4] = math.clamp(values.dt.values[4] + (recharge_hide == 1 and frametime * 40 or -frametime * 40), 0, 1)
            local active_pre = values.dt.values[4]

            values.dt.values[5] = math.clamp(values.dt.values[5] + (active_pre == 1 and frametime * 1.5 or -frametime * 4), 0, 1)
            local active = values.dt.values[5]

            local ready_text = string[text_func]('READY')
            local ready_text_final = FN.gradient_text(ready_text, { 150, 220, 160, 255 }, { 255, 255, 255, 255 }, active, true)
            local ready_text_size = vector(renderer.measure_text(font, spacing .. ready_text))

            local active_text = string[text_func]('ACTIVE')
            local active_text_final = FN.gradient_text(active_text, { 112, 161, 224, 255 }, { 255, 255, 255, 255 }, active, true)
            local active_text_size = vector(renderer.measure_text(font, spacing .. active_text))

            if alpha > .6 then
                value = text_size.x + recharge_text_size.x
            end

            if recharge_hide > .6 then
                if defensive_charged then
                    second_text = spacing .. ready_text_final
                else
                    second_text = spacing .. active_text_final
                end
            else
                second_text = spacing .. recharge_text_final
            end

            if recharge_hide > .1 then
                value = text_size.x
            end

            if active_pre == 1 then
                if defensive_charged then
                    value = text_size.x + ready_text_size.x
                else
                    value = text_size.x + active_text_size.x
                end
            end

            if alpha > .6 and waiting_wpn then
                second_text = spacing .. waiting_text_final
                value = text_size.x + waiting_text_size.x
            end

            if work then
                values.dt.last_text = text .. second_text
            end

            if not work or alpha == 0 then
                value = 0
            end

            values.dt.fraction(speed, value + 3)
            local fraction = values.dt.fraction.value

            local text_final = values.dt.last_text
            local text_final_size = vector(renderer.measure_text(font, text_final))

            local scope_text = math.floor(-(text_final_size.x / 2) * (1 - scope_fraction) * (fraction / (text_final_size.x + 3)) + 3 * scope_fraction)

            renderer.text(pos.x + scope_text, pos.y + offset.y, 255, 255, 255, 255, font, fraction, text_final)
        end

        values.dt.offset(offset_speed, work and (text_size.y - 1) or 0)
        local h_offset = math.floor(values.dt.offset.value + .5)

        offset.y = offset.y + h_offset
    end

    do
        local hideshots = ui.get(ref.onshotaa[1]) and ui.get(ref.onshotaa[2])
        local work = hideshots

        values.hs.alpha = math.clamp(values.hs.alpha + (work and frametime * 2.5 or -frametime * 6), 0, 1)
        local alpha = values.hs.alpha

        local value = 0

        local text = string[text_func]('HIDE')
        local text_size = vector(renderer.measure_text(font, text))

        local second_text = ''

        if alpha > 0 then
            if work and alpha > .1 then
                value = text_size.x
            end

            values.hs.values[1] = math.clamp(values.hs.values[1] + (doubletap and frametime * 3.5 or -frametime * 3.5), 0, 1)
            local inactive = values.hs.values[1]

            values.hs.values[2] = math.clamp(values.hs.values[2] + (inactive == 1 and frametime * 3.5 or -frametime * 3.5), 0, 1)
            local inactive2 = values.hs.values[2]

            values.hs.values[3] = math.clamp(values.hs.values[3] + ((alpha == 1 and inactive2 > .1) and frametime * 1.5 or -frametime * 4), 0, 1)
            local inactive3 = values.hs.values[3]

            local inactive_text = string[text_func]('INACTIVE')
            local inactive_text_final = FN.gradient_text(inactive_text, { 242, 189, 75, 255 }, { 255, 255, 255, 255 }, inactive3, true)
            local inactive_text_size = vector(renderer.measure_text(font, spacing .. inactive_text))

            values.hs.values[4] = math.clamp(values.hs.values[4] + ((alpha == 1 and inactive == 0) and frametime * 40 or -frametime * 40), 0, 1)
            local active_pre = values.hs.values[4]

            values.hs.values[5] = math.clamp(values.hs.values[5] + (active_pre == 1 and frametime * 1.5 or -frametime * 4), 0, 1)
            local active = values.hs.values[5]

            local ready_text = string[text_func]('READY')
            local ready_text_final = FN.gradient_text(ready_text, { 150, 220, 160, 255 }, { 255, 255, 255, 255 }, active, true)
            local ready_text_size = vector(renderer.measure_text(font, spacing .. ready_text))

            local active_text = string[text_func]('ACTIVE')
            local active_text_final = FN.gradient_text(active_text, { 112, 161, 224, 255 }, { 255, 255, 255, 255 }, active, true)
            local active_text_size = vector(renderer.measure_text(font, spacing .. active_text))

            if alpha > .6 and inactive2 ~= 1 then
                if waiting_wpn then
                    value = text_size.x + active_text_size.x
                    second_text = spacing .. active_text_final
                else
                    second_text = spacing .. ready_text_final
                    value = text_size.x + ready_text_size.x
                end
            end

            if alpha > .6 and inactive > 0 then
                value = text_size.x
            end

            if alpha > .6 and inactive2 > 0 then
                second_text = spacing .. inactive_text_final
            end

            if alpha > .6 and inactive == 1 then
                value = text_size.x + inactive_text_size.x
            end

            if work then
                values.hs.last_text = second_text
            end

            if not work or alpha == 0 then
                value = 0
            end

            values.hs.fraction(speed, value + 3)
            local fraction = values.hs.fraction.value

            local text_final = text .. values.hs.last_text
            local text_final_size = vector(renderer.measure_text(font, text_final))

            local scope_text = math.floor(-(text_final_size.x / 2) * (1 - scope_fraction) * (fraction / (text_final_size.x + 3)) + 3 * scope_fraction)

            renderer.text(pos.x + scope_text, pos.y + offset.y, 255, 255, 255, 255, font, fraction, text_final)
        end

        values.hs.offset(offset_speed, work and (text_size.y - 1) or 0)
        local h_offset = math.floor(values.hs.offset.value + .5)

        offset.y = offset.y + h_offset
    end

    do
        local freestand = antiaim.vars.freestanding.hotkey
        local freestand_disabled = antiaim.vars.freestanding.disabled
        local work = freestand

        values.fs.alpha = math.clamp(values.fs.alpha + (work and frametime * 2.5 or -frametime * 6), 0, 1)
        local alpha = values.fs.alpha

        local value = 0

        local text = string[text_func]('FREESTAND')
        local text_size = vector(renderer.measure_text(font, text))

        local text_short = string[text_func]('FS')
        local text_short_size = vector(renderer.measure_text(font, text_short))

        local first_text = text
        local second_text = ''

        if alpha > 0 then
            if work and alpha > .1 then
                value = text_size.x
            end

            values.fs.values[1] = math.clamp(values.fs.values[1] + (freestand_disabled and frametime * 6 or -frametime * 6), 0, 1)
            local disabled = values.fs.values[1]

            values.fs.values[2] = math.clamp(values.fs.values[2] + (disabled == 1 and frametime * 3 or -frametime * 7), 0, 1)
            local disabled2 = values.fs.values[2]

            values.fs.values[3] = math.clamp(values.fs.values[3] + ((alpha == 1 and disabled2 == 1) and frametime * 1.5 or -frametime * 4), 0, 1)
            local disabled3 = values.fs.values[3]

            local disabled_text = string[text_func]('DISABLED')
            local disabled_text_final = FN.gradient_text(disabled_text, { 120, 120, 120, 255 }, { 255, 255, 255, 255 }, disabled3, true)
            local disabled_text_size = vector(renderer.measure_text(font, spacing .. disabled_text))

            if disabled ~= 0 then
                value = text_short_size.x - 7
            end

            if disabled > .5 then
                first_text = text_short
            end

            if disabled == 1 then
                value = text_short_size.x
            end

            if disabled2 > 0 then
                first_text = text_short .. spacing .. disabled_text_final
            end

            if alpha > .6 and disabled2 > .95 then
                value = value + disabled_text_size.x
            end

            if work then
                values.fs.last_text = first_text .. second_text
            end

            if not work or alpha == 0 then
                value = 0
            end

            values.fs.fraction(speed, value + 3)
            local fraction = values.fs.fraction.value

            local text_final = values.fs.last_text
            local text_final_size = vector(renderer.measure_text(font, text_final))

            local scope_text = math.floor(-(text_final_size.x / 2) * (1 - scope_fraction) * (fraction / (text_final_size.x + 3)) + 3 * scope_fraction)

            renderer.text(pos.x + scope_text, pos.y + offset.y, 255, 255, 255, 255, font, fraction, text_final)
        end

        values.fs.offset(offset_speed, work and (text_size.y - 1) or 0)
        local h_offset = math.floor(values.fs.offset.value + .5)

        offset.y = offset.y + h_offset
    end

    do
        local baim = ui.get(ref.forcebaim)
        local safepoint = ui.get(ref.safepoint)
        local work = baim or safepoint

        values.other_binds.alpha = math.clamp(values.other_binds.alpha + (work and frametime * 2.5 or -frametime * 6), 0, 1)
        local alpha = values.other_binds.alpha

        local spacing = spacing .. ' '
        local spacing_size = vector(renderer.measure_text(font, spacing))

        values.other_binds.fb.active = math.clamp(values.other_binds.fb.active + ((baim and alpha > .1) and frametime * 7 or -frametime * 9), 0, 1)
        local baim_active = values.other_binds.fb.active

        local baim_text = string[text_func]('BAIM')
        local baim_text_size = vector(renderer.measure_text(font, baim_text))

        values.other_binds.sp.active = math.clamp(values.other_binds.sp.active + ((safepoint and alpha > .1) and frametime * 7 or -frametime * 9), 0, 1)
        local safepoint_active = values.other_binds.sp.active

        local safepoint_text = string[text_func]('SAFE')
        local safepoint_text_size = vector(renderer.measure_text(font, safepoint_text))

        if alpha > 0 then
            local baim_pos = math.floor(-(baim_text_size.x / 2) * (1 - scope_fraction) * baim_active + 3 * scope_fraction + (-(safepoint_text_size.x / 2 + spacing_size.x / 2) * safepoint_active) * (1 - scope_fraction))

            renderer.text(pos.x + baim_pos, pos.y + offset.y, 255, 255, 255, 255, font, baim_text_size.x * baim_active + 3, baim_text)

            local safepoint_pos = math.floor(-(safepoint_text_size.x / 2) * (1 - scope_fraction) * safepoint_active + 3 * scope_fraction + ((baim_text_size.x / 2 + spacing_size.x / 2) * baim_active) * (1 - scope_fraction) + ((baim_text_size.x + spacing_size.x) * baim_active) * scope_fraction)

            renderer.text(pos.x + safepoint_pos, pos.y + offset.y, 255, 255, 255, 255, font, safepoint_text_size.x * safepoint_active + 3, safepoint_text)
        end

        values.other_binds.offset(offset_speed, work and ((math.max(baim_text_size.y, safepoint_text_size.y)) - 1) or 0)
        local h_offset = math.floor(values.other_binds.offset.value + .5)

        offset.y = offset.y + h_offset
    end

    do
        local condition_names = {
            ['stand'] = 'STANDING',
            ['move'] = 'MOVING',
            ['crouch'] = 'CROUCH',
            ['slowwalk'] = 'SLOWWALK',
            ['air crouch'] = 'AIR CROUCH',
            ['air'] = 'AIR',
            ['legit aa'] = 'LEGIT'
        }

        local condition = var.p_state[1]

        local text = var.p_state[5] == var.condition_names.normal and string[text_func](condition_names[condition]) or string[text_func](var.p_state[5])
        local text_size = vector(renderer.measure_text(font, text))

        local adder = '-'
        local adder_size = vector(renderer.measure_text(font, adder))

        values.state.fraction(state_speed, text_size.x + 3)
        local fraction = values.state.fraction.value

        local scope_text = math.floor(-(text_size.x / 2) * (1 - scope_fraction) * (math.clamp(fraction, 1, (text_size.x + 3)) / (text_size.x + 3)) + (adder_size.x + 2) * scope_fraction + 3 * scope_fraction)

        renderer.text(pos.x + scope_text, pos.y + offset.y, 255, 255, 255, 255, font, fraction, text)

        local scope_adder1 = math.floor((-fraction / 2 - adder_size.x) * (1 - scope_fraction) + 3 * scope_fraction)
        local scope_adder2 = math.floor((fraction / 2 + adder_size.x - 2) * (1 + scope_fraction) + (3 + 2) * scope_fraction)

        renderer.text(pos.x + scope_adder1, pos.y + offset.y, 255, 255, 255, 255, font, nil, adder)
        renderer.text(pos.x + scope_adder2, pos.y + offset.y, 255, 255, 255, 255, font, nil, adder)
    end
end)

indicators.center.on_player_hurt = function(e)
    local plocal = entity.get_local_player()
    local victim = client.userid_to_entindex(e.userid)

    if victim ~= plocal then
        return
    end

    indicators.center.values.hurt_anim = 1
end

indicators.arrows.draw = LPH_JIT_MAX(function()
    local plocal = entity.get_local_player()
    if not entity.is_alive(plocal) then return end

    local values = indicators.arrows.values

    local screen_size = vector(client.screen_size())

    local pos = screen_size / 2

    local color_ref = script_db.get_accent_color()
    local color = { r = color_ref[1], g = color_ref[2], b = color_ref[3], a = 255 }

    local frametime = globals.frametime()

    local scoped = entity.get_prop(plocal, 'm_bIsScoped') == 1
    local scope_enabled = UI.contains('visuals:indicators:adjustments', 'move arrows on scope') and scoped

    local speed = frametime * 5

    values.scope = math.clamp(values.scope + (scope_enabled and speed or -speed), 0, 1)
    local adder = easing.quad_in_out(values.scope, 0, 1, 1)

    values.fractions.left = math.clamp(values.fractions.left + (antiaim.vars.manual.yaw == -90 and speed or -speed), 0, 1)
    values.fractions.right = math.clamp(values.fractions.right + (antiaim.vars.manual.yaw == 90 and speed or -speed), 0, 1)
    values.fractions.forward = math.clamp(values.fractions.forward + (antiaim.vars.manual.yaw == 180 and speed or -speed), 0, 1)

    local alpha_left = easing.linear(values.fractions.left, 0, 1, 1)
    local alpha_right = easing.linear(values.fractions.right, 0, 1, 1)
    local alpha_forward = easing.linear(values.fractions.forward, 0, 1, 1)

    if alpha_left > 0 then
        renderer.text(pos.x - 35, pos.y - 2 - 15 * adder, color.r, color.g, color.b, 255 * alpha_left, 'c', nil, '')
    end
    if alpha_right > 0 then
        renderer.text(pos.x + 35, pos.y - 2 - 15 * adder, color.r, color.g, color.b, 255 * alpha_right, 'c', nil, '')
    end
    if alpha_forward > 0 then
        renderer.text(pos.x, pos.y - 25 - 2 - 10 * adder, color.r, color.g, color.b, 255 * alpha_forward, 'cb', nil, '^')
    end
end)

local watermark = {
    images = {}
}

for key, value in pairs(script_db.links.watermark) do
    if value == '' or not value then goto skip end

    watermark.images[key] = ''

    http.get(value, function(s, r)
        if s and r.status == 200 then
            watermark.images[key] = images.load(r.body)
        end
    end)

    ::skip::
end

watermark.draw = LPH_JIT_MAX(function()
    for key, value in pairs(watermark.images) do
        if value == '' then return end
    end

    local plocal = entity.get_local_player()
    if not entity.is_alive(plocal) then return end

    local screen_size = vector(client.screen_size())

    local pos = vector(screen_size.x, 0)

    local color_ref = script_db.get_accent_color()
    local color = { r = color_ref[1], g = color_ref[2], b = color_ref[3], a = 255 }

    local frametime = globals.frametime()

    local glow_steps = 7
    local thickness = 1
    local rounding = 11

    local offset = vector()

    local outline = function(pos, size, thickness, rounding, clr)
        local this_offset = vector()

        for i = 1, glow_steps do
            local g_alpha = math.max(80, math.abs(math.sin(globals.curtime() * 1.5)) * 150)
            g_alpha = g_alpha * ((glow_steps - (i - 1)) / glow_steps) ^ 2

            if glow_steps * .75 - i > 0 then
                renderer.gradient(
                    pos.x - size.x - rounding - thickness - i, pos.y,
                    1, glow_steps * .75 - i,
                    clr.r, clr.g, clr.b, g_alpha, clr.r, clr.g, clr.b, 0, false
                )
            end

            renderer.circle_outline(
                pos.x - size.x - rounding - thickness,
                pos.y + rounding - thickness,
                clr.r, clr.g, clr.b, g_alpha, rounding - i, 270, .25, thickness
            )

            renderer.rectangle(
                pos.x - size.x - thickness * 2 - i,
                pos.y + rounding - thickness,
                1, size.y - rounding * 2 + thickness * 2,
                clr.r, clr.g, clr.b, g_alpha
            )

            renderer.circle_outline(
                pos.x - size.x + rounding - thickness * 2,
                pos.y + size.y - rounding + thickness,
                clr.r, clr.g, clr.b, g_alpha, rounding + i, 90, .25, thickness
            )

            renderer.rectangle(
                pos.x - size.x + rounding - thickness * 2,
                pos.y + size.y + thickness - 1 + i,
                size.x - rounding * 2 + thickness * 3, 1,
                clr.r, clr.g, clr.b, g_alpha
            )

            renderer.circle_outline(
                pos.x - rounding + thickness,
                pos.y + size.y + rounding,
                clr.r, clr.g, clr.b, g_alpha, rounding - i, 270, .25, thickness
            )

            if glow_steps * .75 - i > 0 then
                renderer.gradient(
                    pos.x, pos.y + size.y + rounding - 1 + i,
                    i - glow_steps * .75, 1,
                    clr.r, clr.g, clr.b, g_alpha, clr.r, clr.g, clr.b, 0, true
                )
            end
        end

        renderer.circle_outline(
            pos.x - size.x - rounding - thickness,
            pos.y + rounding - thickness,
            clr.r, clr.g, clr.b, clr.a, rounding, 270, .25, thickness
        )

        renderer.rectangle(
            pos.x - size.x - thickness * 2,
            pos.y + rounding - thickness,
            thickness, size.y - rounding * 2 + thickness * 2,
            clr.r, clr.g, clr.b, clr.a
        )

        renderer.circle_outline(
            pos.x - size.x + rounding - thickness * 2,
            pos.y + size.y - rounding + thickness,
            clr.r, clr.g, clr.b, clr.a, rounding, 90, .25, thickness
        )

        renderer.rectangle(
            pos.x - size.x + rounding - thickness * 2,
            pos.y + size.y,
            size.x - rounding * 2 + thickness * 3, thickness,
            clr.r, clr.g, clr.b, clr.a
        )

        renderer.circle_outline(
            pos.x - rounding + thickness,
            pos.y + size.y + rounding,
            clr.r, clr.g, clr.b, clr.a, rounding, 270, .25, thickness
        )
    end

    local inside = function(pos, size, thickness, rounding, clr)
        Draw.rectangle(
            pos - vector(size.x + thickness * 2 - 1),
            size + vector(thickness * 2 - 1, thickness),
            clr, {
                active_corners = { false, false, false, true },
                rounding = rounding
            }
        )

        renderer.circle_outline(
            pos.x - size.x - rounding + 1,
            pos.y + rounding - thickness,
            clr.r, clr.g, clr.b, clr.a, rounding, 270, .25, thickness + 1
        )

        renderer.circle_outline(
            pos.x - size.x - rounding + thickness * 2 + 3,
            pos.y + rounding - thickness,
            clr.r, clr.g, clr.b, clr.a, rounding, 270, .25, thickness + 2
        )

        renderer.circle_outline(
            pos.x - rounding + thickness,
            pos.y + size.y + rounding - thickness - 1,
            clr.r, clr.g, clr.b, clr.a, rounding, 270, .25, thickness + 1
        )

        renderer.circle_outline(
            pos.x - rounding + thickness,
            pos.y + size.y + rounding - thickness * 2 - 4,
            clr.r, clr.g, clr.b, clr.a, rounding, 270, .25, thickness + 2
        )
    end

    local text_flag = ''

    local username = script_db.username
    local username_size = vector(renderer.measure_text(text_flag, username))

    local version = script_db.version
    local version_size = vector(renderer.measure_text(text_flag, version))

    local lua_name = FN.gradient_text_anim(script_db.lua_name:upper(), { color.r, color.g, color.b, 255 }, { color.r * .5, color.g * .5, color.b * .5, 255 * .5 }, 2)
    local lua_name_size = vector(renderer.measure_text('b', lua_name))

    local logo = watermark.images.logo
    local logo_size = vector(logo:measure()) * .8

    local size = vector(math.max(username_size.x, version_size.x) + 7 + lua_name_size.x + logo_size.x + 15, username_size.y + version_size.y + 4)

    inside(pos, size, thickness, rounding, { r = 25, g = 25, b = 25, a = color.a })
    outline(pos, size, thickness, rounding, color)

    logo:draw(
        pos.x - size.x + thickness + logo_size.x / 2 - 3, pos.y + size.y / 2 - logo_size.y / 2,
        logo_size.x, logo_size.y,
        color.r, color.g, color.b, math.max(200, math.abs(math.sin(globals.curtime() * 1.5)) * 255)
    )

    renderer.text(
        pos.x - 3,
        pos.y + 1,
        color.r, color.g, color.b, 200, text_flag .. 'r', nil, username
    )

    renderer.text(
        pos.x - 3,
        pos.y + username_size.y,
        color.r, color.g, color.b, 200, text_flag .. 'r', nil, version
    )

    renderer.text(
        pos.x - 3 - math.max(username_size.x, version_size.x) - 7,
        pos.y + size.y / 2 - lua_name_size.y / 2 - 1,
        255, 255, 255, 255, 'rb', nil, lua_name
    )
end)

local popups = {
    logo = {
        alpha = smoothy:new(0)
    },
    values = {},
    all_active = false,
    images = {}
}

for key, value in pairs(script_db.links.popups) do
    if value == '' or not value then goto skip end

    popups.images[key] = ''

    http.get(value, function(s, r)
        if s and r.status == 200 then
            popups.images[key] = images.load(r.body)
        end
    end)

    ::skip::
end

popups.draw_element = LPH_JIT_MAX(function(index, base_text, ready_text, base_active, ready, bar_fraction, color, position, offset)   
    if popups.values[index] == nil then
        popups.values[index] = {
            tweens = smoothy:new({
                alpha = 0,
                load_fraction = 0,
                text_fraction = 1,
                bar_fraction = 4,
                offset = 0
            })
        }
    end

    local speed, offset_speed = base_active and .05 or .04, .05
    local glow_steps = 9

    local this_values = popups.values[index]
    local this_offset = vector()
    local spacing = ' '
    local curr_text, curr_text_size = '', 0

    this_values.tweens(speed, {
        alpha = base_active,
        load_fraction = base_active and ready
    })

    local alpha = this_values.tweens.value.alpha
    local load_fraction = this_values.tweens.value.load_fraction

    position.y = position.y + offset.y * alpha

    if alpha > 0 then
        local base_text_final = FN.gradient_text(base_text, { 255, 255, 255, 255 * alpha }, { 210, 210, 210, 150 * alpha }, load_fraction)
        local base_text_size = vector(renderer.measure_text('', base_text))

        local ready_text_final = FN.colored_text(ready_text, { color.r, color.g, color.b, 255 * alpha })
        local ready_text_size = vector(renderer.measure_text('', spacing .. ready_text))

        curr_text = base_text_final .. spacing .. ready_text_final
        curr_text_size = base_text_size.x

        if ready then
            curr_text_size = base_text_size.x + ready_text_size.x
        end

        if not base_active then
            curr_text_size = 0
        end

        this_values.tweens(speed, { text_fraction = curr_text_size + 2 })
        local text_fraction = this_values.tweens.value.text_fraction

        renderer.text(position.x, position.y, 255, 255, 255, 255 * alpha, 'c', text_fraction, curr_text)

        this_offset.y = this_offset.y + math.ceil(math.max(glow_steps + 2, math.max(base_text_size.y - 3, ready_text_size.y - 3)) * alpha)

        local bar_width = base_text_size.x + ready_text_size.x
        local bar_pos = vector(position.x - math.ceil((bar_width / 2) * alpha), position.y + this_offset.y)

        if type(bar_fraction) == 'boolean' then
            this_values.tweens(base_active and .14 or speed, {
                bar_fraction = (bar_fraction and alpha > .9) and bar_width or 4
            })
        elseif type(bar_fraction) == 'number' then
            bar_fraction = math.clamp(bar_fraction, 0, 1)

            this_values.tweens(base_active and .025 or speed, {
                bar_fraction = alpha > .9 and math.max(bar_width * bar_fraction, 4) or 4
            })
        end

        local bar_fraction_value = math.ceil(this_values.tweens.value.bar_fraction)

        Draw:shadow(
            bar_pos, vector(math.ceil((bar_width + 1) * alpha), 4),
            { r = color.r, g = color.g, b = color.b, a = 90 * alpha }, 2, glow_steps
        )

        Draw.rectangle(
            vector(position.x - bar_fraction_value / 2, bar_pos.y), vector(bar_fraction_value + 1, 4),
            { r = color.r, g = color.g, b = color.b, a = 255 * alpha }, 2
        )
    end

    this_values.tweens(offset_speed, { offset = alpha > .2 and 20 + glow_steps or 0 })

    local offset = math.floor(this_values.tweens.value.offset + .5)

    return base_active, offset
end)

popups.elements = {
    {
        index = 'cross_assistant',
        vars = function()
            local base_text = 'cross assistant'
            local ready_text = 'ready'
            local base_active = antiaim.cross_assistant.vars.charge_time > 0
            local ready = antiaim.cross_assistant.vars.ready
            local bar_fraction = antiaim.cross_assistant.vars.charge_time * 2

            return base_text, ready_text, base_active, ready, bar_fraction
        end
    },
    {
        index = 'defensive_choke',
        vars = function()
            local ticks_from_discharge = doubletap_state.defensive.choke_until - globals.tickcount()

            local base_text = 'defensive'
            local ready_text = 'choking'
            local base_active = ticks_from_discharge > -25
            local ready = true
            local bar_fraction = ((doubletap_state.defensive.choke_ticks - ticks_from_discharge) / doubletap_state.defensive.choke_ticks)

            if not UI.contains('visuals:popups:elements', 'defensive choking') then
                base_active, ready = false, false
            end

            return base_text, ready_text, base_active, ready, bar_fraction
        end
    },
    {
        index = 'slowdown_warning',
        vars = function()
            local plocal = entity.get_local_player()
            local velocity_modifier = entity.get_prop(plocal, 'm_flVelocityModifier')

            local base_text = 'slowed down'
            local ready_text = ('%d%%'):format(velocity_modifier * 100)
            local base_active = velocity_modifier < 1
            local ready = true
            local bar_fraction = velocity_modifier

            if not UI.contains('visuals:popups:elements', 'slowdown warning') then
                base_active, ready = false, false
            end

            return base_text, ready_text, base_active, ready, bar_fraction
        end
    }
}

popups.draw = LPH_JIT_MAX(function()
    for key, value in pairs(popups.images) do
        if value == '' then return end
    end

    local plocal = entity.get_local_player()
    if not entity.is_alive(plocal) then return end

    local values = popups.values

    local screen_size = vector(client.screen_size())

    local pos = vector(screen_size.x / 2, 130)

    local color_ref = script_db.get_accent_color()
    local color = { r = color_ref[1], g = color_ref[2], b = color_ref[3], a = 255 }

    do
        local this_values = popups.logo

        this_values.alpha(.04, popups.all_active)
        local alpha = this_values.alpha.value

        local image = popups.images.logo

        local logo_size = vector(image:measure())
        local final_logo_size = vector(math.ceil(logo_size.x * alpha), math.ceil(logo_size.y * alpha))

        if alpha > 0 then
            image:draw(
                pos.x - final_logo_size.x / 2, pos.y - (final_logo_size.y + 9) * alpha,
                final_logo_size.x, final_logo_size.y,
                color.r, color.g, color.b, 255 * alpha
            )
        end
    end

    local all_active = false
    local offset = vector()

    for i = 1, #popups.elements do
        local this = popups.elements[i]

        if this.color then
            color = this.color()
        end

        local base_text, ready_text, base_active, ready, bar_fraction = this.vars()

        local this_active, this_offset = popups.draw_element(
            this.index, base_text, ready_text, base_active, ready, bar_fraction, color, pos, offset
        )

        offset.y = offset.y + this_offset

        if this_active then
            all_active = true
        end
    end

    popups.all_active = all_active
end)

notifier.images = {}

for key, value in pairs(script_db.links.notifier) do
    if value == '' or not value then goto skip end

    notifier.images[key] = ''

    http.get(value, function(s, r)
        if s and r.status == 200 then
            notifier.images[key] = images.load(r.body)
        end
    end)

    ::skip::
end

notifier.draw = LPH_JIT_MAX(function()
    for key, value in pairs(notifier.images) do
        if value == '' then return end
    end

    local screen_size = vector(client.screen_size())

    local realtime = globals.realtime()
    local frametime = globals.frametime()

    local rounding = 6
    local glow_steps = 8
    local h_offset = glow_steps + 1
    local prefix_offset = 5

    for i = #notifier.data.active, 1, -1 do
        local this = notifier.data.active[i]
        if not this then return end

        if not this.time.created then
            this.time.value = realtime + this.time_add + 999
            this.time.created = true
        end

        local fraction = this.fraction.value

        if not this.time.started and fraction.z > 95 then
            this.time.value = realtime + this.time_add
            this.time.started = true
        end

        this.alpha = math.clamp(this.alpha + (fraction.y > -1 and frametime * 3.5 or -frametime * 9), 0, 1)
        local alpha = easing.quad_in(this.alpha, 0, 1, 1)

        if alpha <= 0 then
            table.remove(notifier.data.queue, i)
            table.remove(notifier.data.active, i)
        end

        local color = { r = this.color.r, g = this.color.g, b = this.color.b, a = 255 * alpha }

        local prefix_text = FN.colored_text(script_db.lua_name .. ':', { color.r, color.g, color.b, color.a })

        local text do
            local txt = {}

            for i = 1, #this.text do
                local curr_text = this.text[i]

                local curr_color = { r = 255, g = 255, b = 255 }

                if curr_text[2] then
                    curr_color = this.color
                end

                txt[i] = FN.colored_text(curr_text[1], { curr_color.r, curr_color.g, curr_color.b, 255 * alpha })
            end

            text = table.concat(txt)
        end

        local prefix_logo = notifier.images[this.icon]

        local prefix_text_size = vector(renderer.measure_text('b', prefix_text))
        local prefix_logo_size = vector(prefix_logo:measure())

        local text_size = vector(renderer.measure_text('', text))

        local prefix_size = prefix_text_size

        if this.prefix == 'logo' then
            prefix_size = prefix_logo_size
        end

        local final_size = prefix_size + text_size + vector(prefix_offset) + vector(rounding * 2)

        local pos = vector(screen_size.x / 2, screen_size.y - 220)
        local size = vector(final_size.x, 21)

        pos.x = pos.x - size.x / 2

        if not this.created then
            this.fraction(0, vector(0, (size.y + h_offset) * i))
            this.created = true
        end

        local position = vector()

        if realtime > this.time.value and i == 1 then
            position.y = -(size.y + h_offset + 5)
        end

        this.fraction(.1, vector(0, position.y + (size.y + h_offset) * (i - 1), 100))

        pos.y = pos.y + math.floor(fraction.y)

        Draw.rectangle(pos, size, { r = 30, g = 30, b = 30, a = color.a }, rounding)

        if table.contains(this.style, 'glow') then
            Draw:shadow(pos, size, { r = color.r, g = color.g, b = color.b, a = color.a * .4 }, rounding, glow_steps)
        end

        if table.contains(this.style, 'gradient') then
            renderer.rectangle(pos.x - 1, pos.y + rounding, 2, size.y - rounding * 2, color.r, color.g, color.b, color.a)
            renderer.circle_outline(pos.x + rounding, pos.y + rounding, color.r, color.g, color.b, color.a, rounding + 1, 180, .25, 2)
            renderer.circle_outline(pos.x + rounding, pos.y + size.y - rounding, color.r, color.g, color.b, color.a, rounding + 1, 90, .25, 2)
            renderer.gradient(pos.x + rounding, pos.y - 1, size.x / 2, 2, color.r, color.g, color.b, color.a, 0, 0, 0, 0, true)
            renderer.gradient(pos.x + rounding, pos.y - 1 + size.y, size.x / 2, 2, color.r, color.g, color.b, color.a, 0, 0, 0, 0, true)

            renderer.rectangle(pos.x - 1 + size.x, pos.y + rounding, 2, size.y - rounding * 2, color.r, color.g, color.b, color.a)
            renderer.circle_outline(pos.x + size.x - rounding, pos.y + rounding, color.r, color.g, color.b, color.a, rounding + 1, 270, .25, 2)
            renderer.circle_outline(pos.x + size.x - rounding, pos.y + size.y - rounding, color.r, color.g, color.b, color.a, rounding + 1, 0, .25, 2)
            renderer.gradient(pos.x + size.x - rounding, pos.y - 1, -size.x / 2, 2, color.r, color.g, color.b, color.a, 0, 0, 0, 0, true)
            renderer.gradient(pos.x + size.x - rounding, pos.y - 1 + size.y, -size.x / 2, 2, color.r, color.g, color.b, color.a, 0, 0, 0, 0, true)
        end

        if this.prefix == 'logo' then
            prefix_logo:draw(
                pos.x + rounding, pos.y + size.y / 2 - prefix_size.y / 2,
                prefix_size.x, prefix_size.y,
                color.r, color.g, color.b, color.a
            )
        else
            renderer.text(pos.x + rounding, pos.y + size.y / 2 - prefix_size.y / 2, 255, 255, 255, color.a, 'b', nil, prefix_text)
        end

        renderer.text(pos.x + rounding + prefix_size.x + prefix_offset, pos.y + size.y / 2 - text_size.y / 2, 255, 255, 255, color.a, '', nil, text)
    end
end)

notifier.add = function(args)
    local color_ref = script_db.get_accent_color()
    local prefix = UI.get('visuals:notifier:prefix')
    
    args = args or {}

    args.color = args.color or { r = color_ref[1], g = color_ref[2], b = color_ref[3], a = 255 }
    args.time = 3
    args.text = args.text or { { '' } }
    args.prefix = args.prefix or prefix
    args.icon = args.icon or 'logo'

    table.insert(notifier.data.queue, {
        fraction = smoothy:new(vector()),
        created = false,
        alpha = .0001,
        time = { created = false, started = false, value = 0 },
        type = args.type,
        time_add = args.time,
        color = args.color,
        text = args.text,
        prefix = args.prefix,
        icon = args.icon,
        style = UI.get('visuals:notifier:style')
    })
end

notifier.handle = LPH_JIT_MAX(function()
    for i, data in pairs(notifier.data.queue) do
        if i > notifier.max then goto skip end

        if notifier.data.active[i] == nil then
            table.insert(notifier.data.active, data)
        end

        ::skip::
    end

    notifier.draw()
end)

local aimbot_logs = {
    data = {},
    shots = {}
}

aimbot_logs.on_aim_fire = function(e)   
    aimbot_logs.data[e.id] = e
end

aimbot_logs.on_aim_hit = function(e)
    local target_health = entity.get_prop(e.target, 'm_iHealth')
    local target_name = string.sub(entity.get_player_name(e.target), 1, 20)
    local hitgroup = var.hitgroup_names[e.hitgroup] or '?'

    if aimbot_logs.shots[e.target] == nil then
        aimbot_logs.shots[e.target] = {
            shots = 0,
            damage = 0
        }
    end

    aimbot_logs.shots[e.target].shots = aimbot_logs.shots[e.target].shots + 1
    aimbot_logs.shots[e.target].damage = aimbot_logs.shots[e.target].damage + e.damage

    if target_health <= 0 then return end

    if UI.contains('misc:aimbot_log', 'notify') then
        notifier.add({
            time = notifier.time.medium,
            text = {
                { 'Hit ' },
                { target_name, true },
                { ' in ' },
                { hitgroup, true },
                { ' for ' },
                { e.damage, true },
                { ' damage' }
            }
        })
    end

    if UI.contains('misc:aimbot_log', 'console') then
        local color = script_db.get_accent_color()
        
        script_db.handlers.console_message(color, {
            { 'Hit ' },
            { target_name, true },
            { ' in ' },
            { hitgroup, true },
            { ' for ' },
            { e.damage, true },
            { ' damage' }
        })
    end
end

aimbot_logs.on_aim_miss = function(e)
    if aimbot_logs.data[e.id] == nil then return end

    local on_fire_data = aimbot_logs.data[e.id]
    
    local target_name = string.sub(entity.get_player_name(e.target), 1, 20)
    local on_fire_hitgroup = var.hitgroup_names[on_fire_data.hitgroup] or '?'
    local reason = e.reason == '?' and 'unknown' or e.reason

    if aimbot_logs.shots[e.target] == nil then
        aimbot_logs.shots[e.target] = {
            shots = 0,
            damage = 0
        }
    end

    aimbot_logs.shots[e.target].shots = aimbot_logs.shots[e.target].shots + 1

    if UI.contains('misc:aimbot_log', 'notify') then
        notifier.add({
            time = notifier.time.medium,
            text = {
                { 'Missed ' },
                { target_name, true },
                { '\'s ' },
                { on_fire_hitgroup, true },
                { ' due to ' },
                { reason, true }
            }
        })
    end

    if UI.contains('misc:aimbot_log', 'console') then
        local color = script_db.get_accent_color()
        
        script_db.handlers.console_message(color, {
            { 'Missed ' },
            { target_name, true },
            { '\'s ' },
            { on_fire_hitgroup, true },
            { ' due to ' },
            { reason, true }
        })
    end
end

aimbot_logs.on_player_death = function(e)
    local attacker = client.userid_to_entindex(e.attacker)
    local target = client.userid_to_entindex(e.userid)

    if attacker ~= entity.get_local_player() then return end

    client.delay_call(.0001, function()
        if aimbot_logs.shots[target] == nil then
            return
        end

        local target_name = string.sub(entity.get_player_name(target), 1, 20)
        local shots = aimbot_logs.shots[target].shots
        local shots_text = shots == 1 and 'shot' or 'shots'
        local damage = aimbot_logs.shots[target].damage

        if UI.contains('misc:aimbot_log', 'notify') then
            notifier.add({
                time = notifier.time.medium,
                text = {
                    { 'Killed ' },
                    { target_name, true },
                    { ' in ' },
                    { shots, true },
                    { (' %s and did '):format(shots_text) },
                    { damage, true },
                    { ' total damage' }
                }
            })
        end

        if UI.contains('misc:aimbot_log', 'console') then
            local color = script_db.get_accent_color()
            
            script_db.handlers.console_message(color, {
                { 'Killed ' },
                { target_name, true },
                { ' in ' },
                { shots, true },
                { (' %s and did '):format(shots_text) },
                { damage, true },
                { ' total damage' }
            })
        end

        aimbot_logs.shots[target].shots = 0
        aimbot_logs.shots[target].damage = 0
    end)
end

aimbot_logs.on_round_start = function()
    aimbot_logs.shots = {}
end

local animation_breaker = {
    last_tickcount = 0,
    ping_check = globals.tickcount(),
    ground_ticks = 1,
    end_time = 0
}

animation_breaker.on_pre_render = function()
    local plocal = entity.get_local_player()
    if not entity.is_alive(plocal) then return end

    local animation_breakers = 'misc:animation_breakers'

    if UI.contains(animation_breakers, 'legs on ground') then
        local leg_breaker = UI.get('misc:leg_breaker')

        if leg_breaker == 'jitter' then
            local move_yaw = entity.get_prop(plocal, 'm_flPoseParameter', 7)

            local ping_ticks = toticks(client.latency()) + 1

            if globals.tickcount() > animation_breaker.last_tickcount then
                animation_breaker.ping_check = math.random(0, 14) / 14 < ping_ticks / 14
            end

            local feet_yaw = move_yaw + .5 + (animation_breaker.ping_check and math.random(-10, 10) / 100 or 0)

            if feet_yaw > 1 then
                feet_yaw = feet_yaw - 1
            end

            entity.set_prop(plocal, 'm_flPoseParameter', feet_yaw, 0)

            if globals.chokedcommands() == 0 and animation_breaker.ping_check then
                entity.set_prop(plocal, 'm_flPoseParameter', math.random(), 1)
                entity.set_prop(plocal, 'm_flPoseParameter', math.random(), 3)
                entity.set_prop(plocal, 'm_flPoseParameter', math.random(), 1)
                entity.set_prop(plocal, 'm_flPoseParameter', math.random(), 8)
            end

            ui.set(ref.leg_movement, math.random(0, 2) >= 1 and 'Never slide' or 'Always slide')

            animation_breaker.last_tickcount = globals.tickcount()
        elseif leg_breaker == 'moonwalk' then
            entity.set_prop(plocal, 'm_flPoseParameter', -1, 7)

            ui.set(ref.leg_movement, 'Never slide')
        end
    end

    if UI.contains(animation_breakers, 'legs in air') then
        entity.set_prop(plocal, 'm_flPoseParameter', 1, 6)
    end

    if UI.contains(animation_breakers, 'pitch zero on land') then
        local on_ground = bit.band(entity.get_prop(plocal, 'm_fFlags'), 1)

        if on_ground == 1 then
            animation_breaker.ground_ticks = animation_breaker.ground_ticks + 1
        else
            animation_breaker.ground_ticks = 0
            animation_breaker.end_time = globals.curtime() + 1
        end 

        if animation_breaker.ground_ticks > ui.get(ref.fakelag_limit) + 1 and animation_breaker.end_time > globals.curtime() then
            entity.set_prop(plocal, 'm_flPoseParameter', .5, 12)
        end
    end
end

local clantag = {
    clan_tag_prev = '',
    disable_clantag = false
}

clantag.gamesense_anim = function(text, indices)
    local text_anim = '               ' .. text .. '                      ' 
    local tickinterval = globals.tickinterval()
    local tickcount = globals.tickcount() + toticks(client.latency())
    local i = tickcount / toticks(.3)
    i = math.floor(i % #indices)
    i = indices[i + 1] + 1

    return string.sub(text_anim, i, i + 15)
end

clantag.run_tag_animation = function()
    local clan_tag = clantag.gamesense_anim(
        string.lower(script_db.lua_name),
        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 }
    )
    if clan_tag ~= clantag.clan_tag_prev then
        client.set_clan_tag(clan_tag)
    end
    clantag.clan_tag_prev = clan_tag
end

clantag.clantag_paint = function()
    local plocal = entity.get_local_player()
    if plocal ~= nil and (not entity.is_alive(plocal)) and globals.tickcount() % 2 == 0 then
        clantag.run_tag_animation()
    end
    clantag.disable_clantag = true
end

clantag.clantag_run_command = function(cmd)
    if cmd.chokedcommands == 0 then
        clantag.run_tag_animation()
    end
end

clantag.reset_clantag = function()
    client.set_clan_tag('\0')
end

local callbacks = {}

callbacks.run_command = function(cmd)   
    antibruteforce.store_backtrack()

    if UI.get('aa:antiaim_preset') ~= 'dynamic' and UI.get('aa:antibruteforce:enable') then
        if UI.contains('aa:antibruteforce:reset_events', 'time') then
            antiaim.antibruteforce.reset.time()
        end
    end

    if UI.get('misc:clantag') then
        clantag.clantag_run_command(cmd)
    end
end

callbacks.setup_command = function(cmd)
    doubletap_state.funcs.on_setup_command()
    
    antiaim:handle(cmd)
    antiaim:set_antiaim(cmd)
end

callbacks.indicator = function(indicator)
    doubletap_state.funcs.on_indicator(indicator)
end

callbacks.paint_ui = function()
    doubletap_state.funcs.on_paint_ui()
    
    antibruteforce:handle_shots()
    
    notifier.handle()

    if not ui.is_menu_open() then return end

    menu.handle.skeet_menu(false)
    menu.handle.visibility()

    ui.set_visible(ref.leg_movement, UI.get('misc:leg_breaker') == '-')

    menu.builder.handle.configuring_label()
end

callbacks.paint = function()
    local curr_indicators = UI.get('visuals:indicators:style')

    if curr_indicators ~= '-' then
        if curr_indicators == 'modern' then
            indicators.center.draw()
        end
    end

    if UI.get('visuals:indicators:manual_arrows') then
        indicators.arrows.draw()
    end

    if UI.get('visuals:watermark') then
        watermark.draw()
    else
        local color_ref = script_db.get_accent_color()
        color_ref[4] = 255

        local text = FN.gradient_text(
            ('%s - %s'):format(script_db.lua_name, script_db.version),
            color_ref, { 255, 255, 255, 255 }, math.abs(math.sin(globals.curtime() / 2)), true
        )

        renderer.text(1, 0, 255, 255, 255, 255, '', nil, text)
    end

    popups.draw()

    if UI.get('misc:clantag') then
        clantag.clantag_paint()
    elseif clantag.disable_clantag then
        clantag.reset_clantag()
        clantag.disable_clantag = false
    end
end

callbacks.bullet_impact = function(e)
    antibruteforce.bullet_impact(e)
end

callbacks.player_hurt = function(e)
    antibruteforce.player_hurt(e)

    indicators.center.on_player_hurt(e)
end

-- callbacks.player_connect_full = function(e)

-- end

callbacks.round_start = function()
    if UI.get('aa:antiaim_preset') ~= 'dynamic' and UI.get('aa:antibruteforce:enable') then
        if UI.contains('aa:antibruteforce:reset_events', 'round start') then
            antiaim.antibruteforce.reset.on_round_start()
        end
    end

    if #UI.get('misc:aimbot_log') > 0 then
        aimbot_logs.on_round_start()
    end
end

-- callbacks.weapon_fire = function(e)

-- end

callbacks.aim_fire = function(e)
    if #UI.get('misc:aimbot_log') > 0 then
        aimbot_logs.on_aim_fire(e)
    end
end

callbacks.aim_hit = function(e)
    if #UI.get('misc:aimbot_log') > 0 then
        aimbot_logs.on_aim_hit(e)
    end
end

callbacks.aim_miss = function(e)
    if #UI.get('misc:aimbot_log') > 0 then
        aimbot_logs.on_aim_miss(e)
    end
end

callbacks.player_death = function(e)
    if UI.get('aa:antiaim_preset') ~= 'dynamic' and UI.get('aa:antibruteforce:enable') then
        if UI.contains('aa:antibruteforce:reset_events', 'shooter death') then
            antiaim.antibruteforce.reset.on_shooter_death(e)
        end
    end

    if #UI.get('misc:aimbot_log') > 0 then
        aimbot_logs.on_player_death(e)
    end
end

callbacks.pre_render = function()
    local animation_breakers = UI.get('misc:animation_breakers')

    if #animation_breakers ~= 0 then
        animation_breaker.on_pre_render()
    end
end

callbacks.pre_config_save = function()
    menu.handle.reset_antiaim()
end

callbacks.shutdown = function()
    menu.handle.skeet_menu(true)
    menu.handle.reset_antiaim()

    ui.set_visible(ref.leg_movement, true)
    ui.set(ref.ticks_user, 16)

    script_db.database.configs.hidden_config = script_db.hidden_config
    -- script_db.database.configs.last_used_config = menu.configs.last_loaded_config
    script_db.database.configs.list = menu.configs.list
    -- script_db.database.antiaim.antibruteforce = {
    --     data = antibruteforce.data,
    --     all_stored_shots = antibruteforce.all_stored_shots
    -- }
    script_db.database.antiaim.dynamic = {
        values = antiaim.dynamic.values.data,
        antiaim_data = antiaim.dynamic.values.antiaim_data
    }

    database.write(script_db.database_key, script_db.database)
end

do
    if script_db.database.configs.hidden_config ~= nil then
        script_db.hidden_config = script_db.database.configs.hidden_config
    end

    if script_db.database.configs.list ~= nil then
        menu.configs.list = script_db.database.configs.list
        ui.update(menu.configs.menu.config_list, menu.configs.list)
    end

    -- if script_db.database.configs.last_used_config ~= nil then
    --     client.delay_call(1, function()
    --         menu.configs.handle.load_config(script_db.database.configs.last_used_config, true)
    --         UI.visibility_handle()
    --     end)
    -- end

    -- if script_db.database.antiaim.antibruteforce.data ~= nil then
    --     antibruteforce.data = script_db.database.antiaim.antibruteforce.data
    -- end

    -- if script_db.database.antiaim.antibruteforce.all_stored_shots ~= nil then
    --     antibruteforce.all_stored_shots = script_db.database.antiaim.antibruteforce.all_stored_shots
    -- end

    if script_db.database.antiaim.dynamic.values ~= nil then
        antiaim.dynamic.values.data = script_db.database.antiaim.dynamic.values
    end

    if script_db.database.antiaim.dynamic.antiaim_data ~= nil then
        antiaim.dynamic.values.antiaim_data = script_db.database.antiaim.dynamic.antiaim_data
    end

    UI.visibility_handle()
end

for key, value in pairs(callbacks) do
    client.set_event_callback(key, value)
end

if script_db.source then
    writefile('risen_db.json', inspect(script_db.database))
end