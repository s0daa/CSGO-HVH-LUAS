--[[

        /ᐠ. ｡.ᐟ\ᵐᵉᵒʷˎˊ˗ 
        Made by NeDIAD a.k.a NotDIAD
        https://github.com/NeDIAD/tweaks \ https://github.com/NeDIAD

]]

tweaks = tweaks or {}


tweaks.presets = {
    trashtalk = {
        Tweaks = {
            Kill = {'Kill phrase 1, %s', 'Kill phrase 2, %s', 'Kill phrase 3, %s'},
            Death = {'Death phrase 1, %s', 'Death phrase 2, %s', 'Death phrase 3, %s'},
        },
        ['English Agressive'] = {
            Kill = {"U think u good? luckily im here #SKEET","youre value compared to me  is but a grain of sand","all romanian(you) will die to me(gypys king)","this isnt phasmaphobia: global offensive please dont speak","SKEET trap house","I guarntee youre loss forever and always","𝕡𝕣𝕠𝕓𝕝𝕖𝕞?","cope"," 格拉格拉 < you? 无功无过 < me B) #SKEET","in hvh war i will win","below average performance SKEET performance","SPEAK BULGARIAN? WILL TALK CN","you are loss it is decided with my SKEET.lua","you do not perform this hvh against SKEET","qahahaha i am top of this region","this weak snail is spoke of victory but is door unhinged to loss","you do not have the impression of owning the performance-enhancing software known as Gamesense.pub","how you will feel knowing im skeethaving and u will skeetless #SKEET","your mexican familia never make it out from trailer #SKEET","cant understand u. any noname translator? #SKEET","you waste aka fecal matter/shit(you)","sorry for u loss, me always better like life","better luck next round, oh wait i alr won BAHAHHA","ur lua & u sucks get SKEET >.<","when you spawn tell me why u die to me","how hit chance in deagle? i sit.", "shitting on your cheat speedrun any% WR run feat SKEET","smelly lapdog dreams of success in 1x1 but is handed 9 casualities","dude where are my diamonds?","all weak dogs fall to SKEET","WOW SKEET .。GYPSY 的科技 (TECHNOLOGY) ? "},
                -- starlight killsay's
            Death = false
        },
        ['Russian Agressive'] = {
            Kill = {"нюхай пятку сын шаболды ёбаной","сосешь хуже мегионских цыпочек","омг nice small pisunchik","ты нихуя не ледженд","OWNED, сын шлюхи ёбаной","позволь моей писечке исследовать недры шахты твоей матери","целуй писичку fucking no legend","твоя писичка такая же маленькая как и iqshe4ka","в следущей раз выйграешь ледженда","Are you legend? Пройдите проверку на писечку для уточнения вопроса - clocked#5537 virtual#0085","ВЫ ТАКОЙ ЖЕ ТАНЦОР КАК ЛЯСТИЧКИ NOLEGENDICKI","Твоя мать такая же жирная как idle nolegend (140)","накончал на твою лысинку она как у батька шамелисика","твоя мамаша приготовила мне вкусные бутербродики как у gachi nolegend","ты очень хорошо лижешь пяточки научи клокедика legendicka","шлюха ебаная так же сдохла как бабка фиппа и маута","сын шлюхи у тебя такие же компьютерики как у vanino nolegend","твоя мамаша лижет мороженное ой блять это же моя писечка","у твоей матери такая же узкая пизда как глаза d4ssh legend","ты такой же ебаный пес как  l4fn nolegend","мда играешь ты конечно хуево не то что virtual legendick","разбомбил тебе ебасосину как бомбят walper nolegend","ты никогда не будешь legend с такой small pise4ka","пока ты сосешь хуй мы чилим на острове legendickov","шлюха ебаная так же сдохла как бабка фиппа и маута","хочешь купить config by legendick? ПОШЕЛ НАХУЙ СЫН ШЛЮХИ ЁБАНОЙ","ЭХХХ КАК ЖЕ АХУЕННО СОСЕТ ТВОЯ МАМАША МОЙ PISUN4IK","e1","рандерандерандеву твоя мать шлюха сосала наяву","пузо твоей матери шлюхи такое же большое как у shirazu nolegend","АХАХХАА БЛЯ ЧЕЛ ТЫ ИГРАЕШЬ ХУЖЕ HOLATV","NEW META FUCKING NO LEGEND?","ебать я тя ебнул как бабку маута","СОСИ ХУЙ ПЛАКСА ЁБАНАЯ","ИЗВИНЯЙСЯ СЫН ШЛЮХИ ЁБАНОЙ","шлюха ебаная так же сдохла как бабка фиппа и маута","ВЫЕБАНА В ПОПЭПНЦИЮ FUCKING NO LEGEND","ЁБАНЫЙ СЫН ШЛЮХИ ТЫ ХОЧЕШЬ КАК ВИТМА И СТИВАХА МНЕ ПРОЕАТЬ","сын шлюхи ты думал моя писечка сравнится с твоей?","если хочешь я могу тебя на стриме обоссать","ТЫ НЕ ЗНАЕШЬ ЛЕДЖЕНДОВ? ЁБАНЫЙ СЫН ШЛЮХИ С 2023 ЛИВНИ","ты так же зафейлишь проверку на писечки как mishat nolegend","ты танцуешь с бутылкой как ебаный clocked legend?","1","нахуй ты от меня убегаешь как батек virtual legend","ебать я тя ебнул как бабку маута","если хочешь можешь прикупить айфончик 5 s как у merlex nolegend","если хочешь научиться играть тебе нужно попасть в стак legend pise4ki","твоя мать такая же ебаная инвалидка как fiks nolegend","че пидорас цапнул в писечку?","ебать я тя ебнул как бабку маута","ты сдох раньше своей матери шлюхи ой или она уже сдохла ?","твоя мамка любит большие леджендские ололо","ёбаный ноу ледженд ты кого пытался убить?","ой братан походу тебе нужно купить кфгешку леджендика","жду реванша сын ебаной шлюхи","ебать я тя ебнул как бабку маута","переиграна 12 летка ебучая ","знаешь чем пахнут мои яички? спроси у своей мамаши шлюхи ёбаной ", "может сначала купишь пкешочки как у леджендиков? ", "че то ты мои грязные яички облизал сын ёбаной пизды"},
                -- bluhgang killsay's
            Death = false
        },
        ['Just One'] = {
            Kill = {'1', '①', '❶', '111', '.•°*”˜˜”*°• 1 •°*”˜˜”*°•', '.•°*”˜˜”*°•♥●•٠ 1 ٠•●♥°*”˜˜”*°•', '☀*”˜ 1 ˜”*☀'}, 
            Death = false
        },
        
        --[[
        
            %s - Nickname who was killed / you

            function(player) return entity.get_player_name(player) end -- PlayerName 
            event = false -- Disable event

        ]]
    },
    clantag = {
        Tweaks = {
            '>> tweaks.lua:_', 'tweaks.lua', 'tweaks.lua', '<<'
        },
        ['nya :3'] = {
            '>> nya :3:_', 'nya :3',  'nya :3', '<<' 
        }
        
        --[[
        
            Markup:

            '@:' = ':' Escape

            '>> clantag:animation': -- Animate text
                Sample = '>> 123:_'
                Result: '1_', '2_', '3_'

                Another Sample = '>> 123'
                Result: '1', '2', '3'

            '<<': -- Reverse tag
                Sample = {'1', '2', '<<', '4', '3', '<<'}
                Result: '1', '2', '2', '1', '4', '3', '3', '4'

            {...}: -- Table of tags
                Sample = {{'1', '2', '3'}, {'3', '2', '1'}}
                Result: '1', '2', '3', '3', '2', '1'

            function(history) return history end: Function, first argument (table) = history of tags
                Sample = {'1', '2', function(history) return history end}
                Result: '1', '2', '1', '2'
                    -- ^^ Explanation:
                    Because function returns a table of tags, resolver will resolve every tag & add it to preset.

        ]]
    }
}

local hg = {'generic', 'head', 'chest', 'stomach', 'left arm', 'right arm', 'left leg', 'right leg', 'neck', '?', 'gear'}

table.reverse = function(a) local b = {} for i, v in ipairs(a) do table.insert(b, 1, v) end return b end
table.find = function(a, b) for i, v in ipairs(a) do if v == b then return i end end for i, v in pairs(a) do if v == b then return i end end return false end
string.split = function(input, sep) if sep == nil then sep = '%s' end local t = {} for str in string.gmatch(input, "([^"..sep.."]+)") do table.insert(t, str) end return t end

local function Lerp(d, h, t)
    if not d or not h or not t then return 0 end

	if d > 1 then return to end
    if d < 0 then return from end
    
	return (h + ( t - h ) * d or 0) 
end

local ffi = require('ffi')
local http = require('gamesense/http')

local color do
    local hex_rgb = function (hex)
        hex = string.gsub(hex, "^#", "")
        return tonumber(string.sub(hex, 1, 2), 16), tonumber(string.sub(hex, 3, 4), 16), tonumber(string.sub(hex, 5, 6), 16), tonumber(string.sub(hex, 7, 8), 16) or 255
    end

    
    local mt = {
        __eq = function (a, b)
            return a.r == b.r and a.g == b.g and a.b == b.b and a.a == b.a
        end,
        lerp = function (h, t, w)
            return create(h.r + (t.r - h.r) * w, h.g + (t.g - h.g) * w, h.b + (t.b - h.b) * w, h.a + (t.a - h.a) * w)
        end,
        to_hex = hex_rgb,
        alphen = function (self, a, r)
            return create(self.r, self.g, self.b, r and a * self.a or a)
        end,
    }	mt.__index = mt
    
    local create = ffi.metatype(ffi.typeof("struct { uint8_t r; uint8_t g; uint8_t b; uint8_t a; }"), mt)
    
    color = {}
    
    color.rgb = function (r,g,b,a)
        r = math.min(r or 255, 255)
        return create(r, g and math.min(g, 255) or r, b and math.min(b, 255) or r, a and math.min(a, 255) or 255)
    end
    color.hex = function (hex)
        local r,g,b,a = hex_rgb(hex)
        return create(r,g,b,a)
    end
end

local printf do
	local native_print = vtable_bind("vstdlib.dll", "VEngineCvar007", 25, "void(__cdecl*)(void*, const void*, const char*, ...)")
    
	printf = function (...)
		for i, v in ipairs{...} do
			local r = "\aD9D9D9" .. string.gsub(tostring(v), "[\r\v]", {["\r"] = "\aD9D9D9", ["\v"] = "\a".. (('\a74A6A9FF'):sub(1, 7))})
			for col, text in r:gmatch("\a(%x%x%x%x%x%x)([^\a]*)") do
				native_print(color.hex(col), text)
			end
		end
		native_print(color.rgb(217, 217, 217), "\n")
	end
end

local function rgb(r, g, b, a)
    r = r or 255; g = g or 255; b = b or 255; a = a or 255;

    if a == 255 then
        return string.format('\a%02X%02X%02X', r, g, b)
    else
        return string.format('\a%02X%02X%02X%02X', r, g, b, a)
    end
end

tweaks.colors = {
    base = rgb(164, 158, 229),
    gray = rgb(221, 221, 221),
    white = rgb(255, 255, 255),

    red = rgb(243, 74, 74),
    green = rgb(74, 243, 97),

    render_color = {
        base = {r = 128, g = 125, b = 165, a = 170}
    }
}

tweaks.settings = {
    prefix = '   ' .. tweaks.colors.base .. 'tweaks.lua \a'.. tweaks.colors.white ..'» ',
    dev = false,
    version = 'alpha 0.3'
}

client.exec('clear')

printf(
    tweaks.colors.base .. '    _____                  _          _\n',        
    tweaks.colors.base .. '   |_   _|                | |        | |\n',      
    tweaks.colors.base .. '     | |_      _____  __ _| | _____  | |_   _  __ _\n',
    tweaks.colors.base .. '     | \\ \\ /\\ / / _ \\/ _` | |/ / __| | | | | |/ _` |\n',
    tweaks.colors.base .. '     | |\\ V  V /  __/ (_| |   <\\__ \\_| | |_| | (_| |\n',
    tweaks.colors.base .. '     \\_/ \\_/\\_/ \\___|\\__,_|_|\\_\\___(_)_|\\__,_|\\__,_|\n'
)

function tweaks.print(...) 
    local args = {...}
    printf(tweaks.settings.prefix, unpack(args))
end

local function assert(str) if tweaks.settings.dev then tweaks.print(str) end end

local function process(str) tweaks.print('Processing ' .. tweaks.colors.white .. str .. tweaks.colors.base ..' (' .. string.format('%.2f', client.timestamp() - tweaks.start) .. 's)') end
local function process_end(str) tweaks.print('Processed ' .. tweaks.colors.white .. str .. tweaks.colors.base ..' (' .. string.format('%.2f', client.timestamp() - tweaks.start) .. 's)') end

tweaks.print('Processing started ')
tweaks.start = client.timestamp()
tweaks.print('Init version: ' .. tweaks.colors.base .. tweaks.settings.version)

if tweaks.settings.dev then tweaks.print('Loaded in ' .. tweaks.colors.base .. 'dev-mode' .. tweaks.colors.gray ..'!') end

printf('')

local render do
    process('Render library')
    render = {}

    function render.rectangle(x, y, w, h, r, g, b, a, radius)
        x = type(x) == 'number' and x or 0; y = type(y) == 'number' and y or 0; w = type(w) == 'number' and w or 0; h = type(h) == 'number' and h or 0; r = r or 255 g = g or 255 b = b or 255 a = a or 255 radius = radius or 8
        x = math.floor(x); y = math.floor(y); w = math.floor(w); h = math.floor(h)

        if h < 10 then h = 10 end
        if w < 10 then w = 10 end

        renderer.rectangle(x + radius, y, w - 2 * radius, h, r, g, b, a)
        renderer.rectangle(x, y + radius, radius, h - 2 * radius, r, g, b, a)
        renderer.rectangle(x + w - radius, y + radius, radius, h - 2 * radius, r, g, b, a)

        renderer.circle(x + radius, y + h - radius, r, g, b, a, radius, -90, 0.25) -- l b
        renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25) -- l t
        renderer.circle(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25) -- r b
        renderer.circle(x + w - radius, y + radius, r, g, b, a, radius, 90, 0.25) -- r t
    end
   
    process_end('Render library')
end

local mouse do
    process('Mouse library')

    mouse = {}
    
    function mouse.held() return client.key_state(0x01) end
    function mouse.inbounds(x, y, w, h) 
        if not x or not y or not w or not h then assert('Memory leak? Nil values defined!') end

        x = x or 0 y = y or 0 w = w or 0 h = h or 0

        local endX, endY = x + w, y + h
        local mX, mY = ui.mouse_position()

        return mX >= x and mY >= y and mX <= endX and mY <= endY
    end
    function mouse.calc(x1, y1, x2, y2, w, h)
        local scrW, scrH = client.screen_size()
        local mX, mY = ui.mouse_position()
    
        local offsetX = x2 - x1
        local offsetY = y2 - y1

        local newX = mX - offsetX
        local newY = mY - offsetY

        --assert('x1, x2, y1, y2, resX, resY: '..' '.. x1..' '.. x2..' '.. y1..' '.. y2..' '.. newX..' '.. newY)
        --assert('mX, mY, scrW, scrH: '.. mX ..' '.. mY..' '.. scrW..' '.. scrH)

        if newX < 0 then assert('x < 0') newX = 0 end
        if newY < 0 then assert('y < 0') newY = 0 end
        if newX + w > scrW then assert('x > scr') newX = scrW - w end
        if newY + h > scrH then assert('y > scr') newY = scrH - h end

        return newX, newY
    end

    process_end('Mouse library')
end

--[[ -- -- -- -- -- -- MAIN -- -- -- -- -- --  ]]--

local widgets do
    process('Widgets')

    widgets = {}
    widgets.__index = widgets
    widgets.widgets = {}
    local scrW, scrH = client.screen_size()

    local mouse_magnet = {
        y = {35, scrH / 2, scrH - 35},
        x = {scrW / 2}
    }

    
    function widgets.new(id, push, x, y, w, h, draggable, tooltip, lock_size)
        if not id or widgets.widgets[id] then return false end
        push = type(push) == 'function' and push or function() end
        x, y, w, h = type(x) == 'number' and x or 0, type(y) == 'number' and y or 0, type(w) == 'number' and w or 50, type(h) == 'number' and h or 50
        
        draggable = type(draggable) == 'table' and draggable or { x = true, y = true }

        local self = setmetatable({}, widgets)
        
        self.current = {x = x, y = y, w = w, h = h}
        self.animate = {x = x, y = y, w = w, h = h}
        self.paint = true

        local function line(x1, y1, x2, y2) renderer.line(x1, y1, x2, y2, 255, 255, 255, (self.line_alpha or 0)) end

        local function slider(scale, init, align)

            --[[
                align:true = Y
                align:false = X
            ]]

            local slide = ui.new_slider('CONFIG', 'Presets', id .. ':' .. scale, 0, (align and scrH or scrW), init)
            if not tweaks.settings.dev then ui.set_visible(slide, false) end

           return slide
        end

        self.ui = {
            x = slider('x', x),
            y = slider('y', y, true),
        }

        if not lock_size then
            self.ui.w = slider('w', w)
            self.ui.h = slider('h', h, true)
        end

        for scale, slider in pairs(self.ui) do
            ui.set_callback(slider, function() self.current[scale] = ui.get(slider) end)
        end

        self.push = function()

            -- Handling data:

            if type(self.current) ~= 'table' then assert('Rebuild: self.current') self.current = {x = x, y = y, w = w, h = h} end
            if type(self.animate) ~= 'table' then assert('Rebuild: self.animate') self.animate = self.current end
            if type(self.ui) ~= 'table' then assert('Memory leak! No UI elements') return false end

            if type(self.alpha) ~= 'number' then self.alpha = 20 end
            
            -- --
            
            -- Lerps:
            
            for scale, value in pairs(self.current) do
                if self.animate[scale] == value then goto continue end
                
                self.animate[scale] = Lerp(globals.frametime() * 10, self.animate[scale], value)
                
                ::continue::
            end
            
            if not self.paint and self.alpha < 10 then return false end
            
            -- --
            
            -- Render:
            
            self.snap = ui.is_menu_open() and self.drag and not client.key_state(0x10) and tooltip
            
            if ui.is_menu_open() or not globals.mapname() then
                
                -- Handling mouse:
                
                local check = self.drag or mouse.inbounds(self.current.x, self.current.y, self.current.w, self.current.h)
                self.alpha = Lerp(globals.frametime() * 10, self.alpha, (check and self.paint) and 70 or (self.paint and 20 or 0))
                
                if mouse.held() and check and (draggable.x or draggable.y) and (not widgets.drag_id or widgets.drag_id == id) then
                    widgets.drag_id = id
                    
                    if not self.drag then 
                        self.drag = {sX = self.current.x, sY = self.current.y} 
                        self.drag.mX, self.drag.mY = ui.mouse_position()
                    end
                    local x, y = mouse.calc(self.drag.sX, self.drag.sY, self.drag.mX, self.drag.mY, self.current.w, self.current.h)
                    
                    local scales = {
                        x = x,
                        y = y
                    }
                    
                    if self.snap then
                        for scale, magnet in pairs(mouse_magnet) do
                            if not draggable[scale] then goto continue end
                            
                            for i, value in ipairs(magnet) do
                                if math.abs(scales[scale] - value) <= self.current[scale == 'x' and 'w' or 'h'] then
                                    scales[scale] = value - self.current[scale == 'x' and 'w' or 'h'] / 2
                                    if scales[scale] < 0 then scales[scale] = value end
                                    if scales[scale] > (scale == 'x' and scrW - self.current.w or scrH - self.current.h) then scales[scale] = value - self.current[scale == 'x' and 'w' or 'h']  end
                                end
                            end
                            
                            ::continue::
                        end
                    end
                    
                    if draggable.x then ui.set(self.ui.x, scales.x) end
                    if draggable.y then ui.set(self.ui.y, scales.y) end
                else
                    if widgets.drag_id == id then widgets.drag_id = nil end
                    self.drag = nil
                end
                
                -- --
                
            else
                self.alpha = Lerp(globals.frametime() * 10, self.alpha, 0)
            end
            
            if (self.alpha or 0) > 5 then
                local c = self.animate
                
                render.rectangle(c.x, c.y, c.w, c.h, 255, 255, 255, self.alpha, 4)
                
                self.line_alpha = Lerp(globals.frametime() * 10, self.line_alpha, (self.drag and self.snap) and 200 or 0)

                if (self.line_alpha or 0) > 5 and tooltip then

                    for scale, magnets in pairs(mouse_magnet) do
                        if not draggable[scale] then goto continue end
                        
                        for i, value in ipairs(magnets) do
                            local style = (scale == 'y' and {0, value, scrW, value} or {value, 0, value, scrH})
                            
                            line(unpack(style))
                        end
                        
                        ::continue::
                    end
                    
                    if draggable.x or draggable.y then 
                        self.text_multi = Lerp(globals.frametime() * 10, self.line_alpha, (self.drag and self.snap) and scrW + scrH or 1)

                        renderer.text(scrW / 2, scrH - 100, 255, 255, 255, 255, 'cb+', self.text_multi,  tweaks.colors.base .. 'FFSHIFT' .. tweaks.colors.gray .. 'FF - Disable snap to grid') 
                        renderer.text(self.animate.x + self.animate.w / 2, self.animate.y + self.animate.h / 2, 255, 255, 255, 255, 'cb+', self.text_multi, tweaks.colors.gray .. 'FFX: ' .. tweaks.colors.base .. 'FF' .. self.current.x .. tweaks.colors.gray .. 'FF Y:' .. tweaks.colors.base .. 'FF' .. self.current.y)
                    end
                    
                end
            end
            
            -- --
            
            local status, err = pcall(push)
            if not status then assert(err) end
        end
        
        widgets.widgets[id] = self
        
        return self
    end
    
    client.set_event_callback('paint_ui', function()
        for id, self in pairs(widgets.widgets) do
            if type(self) ~= 'table' or type(self.push) ~= 'function' then assert('Type error! '.. id) goto continue end

            local status, err = pcall(function() self.push() end)
            if not status then assert('Error: '.. err) end

            ::continue::
        end 
    end)

    process_end('Widgets')
end

local t, l = 'Lua', 'A'

local tabs do
    process('Tabs')
    local active_tab, combo, tabslist = nil, nil, {}
    
    tabs = {}
    tabs.__index = tabs
    
    tabs.tabs = {}
    
    function tabs.new(name)
        if not name then return false end
        name = tostring(name)
        
        local prev_value
        
        if combo then prev_value = ui.get(combo); ui.set_visible(combo, false) end
        
        table.insert(tabslist, name)
        
        combo = ui.new_combobox(t, 'B', tweaks.colors.white .. 'FF • '.. tweaks.colors.base .. 'FFTweaks' .. tweaks.colors.white .. 'FF »'.. tweaks.colors.gray ..'FF Select tab', unpack(tabslist))
        if prev_value then ui.set(combo, prev_value) end
        
        tabs.tabs[name] = {}
        
        local self = setmetatable({tab = name, elements = tabs.tabs[name]}, tabs)
        
        return self
    end
    
    function tabs:add(element, requirement)
        if not element or not self or type(self) ~= 'table' then return false end
        requirement = requirement or function() return true end
        
        table.insert(self.elements, {element, requirement})
    end
    
    client.set_event_callback('paint_ui', function()
        if not ui.is_menu_open() then return false end
        
        for i,v in pairs(tabs.tabs) do
            if type(v) ~= 'table' then assert('Tab ' .. tostring(i) .. ' not table') goto continue end
            
            for _, element in ipairs(v) do
                if type(element) ~= 'table' then assert('Element ' .. tostring(_) .. ' not table!') goto continue end
                if not element[1] or type(element[2]) ~= 'function' then assert('One of elements error') goto continue end
                
                local success, err = pcall(function() ui.set_visible(element[1], element[2]() and ui.get(combo) == i) end)
                if not success then assert(err) end
                
                ::continue::
            end
            
            ::continue::
        end
    end)

    process_end('Tabs')
end
local function format(space, value) return tweaks.colors.gray ..'FF' .. space .. tweaks.colors.white .. 'FF » ' .. tweaks.colors.base .. 'FF' .. value end

--[[

    M   I   S   C

]]

local misc = tabs.new('Misc')

local trashtalk do
    process('Trash-talk')

    local checkbox = ui.new_checkbox(t, l, 'Enable Trash-talk')
    misc:add(checkbox)

    process('Trash-talk > Presets')

    local unpack_presets, unpack_events = {}, {}

    for name, preset in pairs(tweaks.presets.trashtalk) do 
        assert('New preset: '.. name)

        table.insert(unpack_presets, name)

        for event, phrases in pairs(preset) do
        
        if not table.find(unpack_events, event) then assert('New event: '.. event) table.insert(unpack_events, event) end

        --[[    for i, phrase in ipairs(phrases) do-- В будующем здесь возможно что-то будет
                assert('New phrase: ' .. tostring(phrase) .. ':' .. type(phrase))
            end ]]
        end
    end

    if #unpack_presets <= 0 then unpack_presets = {'No presets!'} end
    if #unpack_events <= 0 then unpack_events = {'No events!'} end

    local preset = ui.new_combobox(t, l, format('Trash-talk', 'Preset'), unpack(unpack_presets))
    local events = ui.new_multiselect(t, l, format('Trash-talk', 'Events'), unpack(unpack_events))
    misc:add(events, function() return ui.get(checkbox) end)
    misc:add(preset, function() return ui.get(checkbox) end)

    local function get_preset(field, player)
        local preset = tweaks.presets.trashtalk[ui.get(preset)]
        if not preset[field] then return false end

        if #preset[field] <= 1 then return preset[field][1] or '?' end

        local phrase = preset[field][client.random_int(1, #preset[field])]

        if type(phrase) == 'function' then phrase = phrase(player) end
        return phrase
    end

    ui.set_callback(checkbox, function()
        local v = ui.get(checkbox)

        client[(v and 'set' or 'unset') .. '_event_callback']('player_death', function(data)
        
            local vid, aid = data.userid, data.attacker
            if not vid or not aid then return false end

            local victim, attacker = client.userid_to_entindex(vid), client.userid_to_entindex(aid)

            if entity.is_enemy(victim) and attacker == entity.get_local_player() and table.find(ui.get(events), 'Kill') then
                assert('Trash-talk (kill)')

                local phrase = get_preset('Kill', victim)

                if not phrase then return false end
                client.delay_call(.3, function() client.exec('say ', string.format(phrase, entity.get_player_name(victim))) end)
            elseif entity.is_enemy(attacker) and victim == entity.get_local_player() and table.find(ui.get(events), 'Death') then
                assert('Trash-talk (death)')
                
                local phrase = get_preset('Death', attacker)

                if not phrase then return false end
                client.delay_call(.3, function() client.exec('say ', string.format(phrase, entity.get_player_name(attacker))) end)
            else
                assert('Trash-talk (skip)')
            end

        end)
    end)

    process_end('Trash-talk')
end

local clantag do
    process('Clan-tag')

    local checkbox = ui.new_checkbox(t, l, 'Enable Clan-tag')
    misc:add(checkbox)

    process('Clan-tag > Presets')

    local unpack_presets = {}
    local history = {}

    -- PRESETS RESOLVER:

    local resolvers = {
        ['^>> '] = function(tag, preset)

            should_remove = string.find(tag, ':')

            tag = string.gsub(tag, '^>> ', '')
            local solve = ''

            if string.find(tag, '@:.$') then
                local tag = string.gsub(tag, '@([^@]*)$', '%1')
                table.insert(history, tag)
                table.insert(preset, tag)

                assert(tag)

                return true 
            end
            
            local split = string.split(tag, ':')
            
            if #split > 1 then
                solve = split[#split]
            end

            tag = string.sub(tag, 1, #tag - #solve - (should_remove and 1 or 0))

            local result = ''

            table.remove(split, #split)

            for char in tag:gmatch('.') do
                result = result .. char

                local gtag = result .. solve

                table.insert(history, gtag)
                table.insert(preset, gtag)

                assert(gtag)
            end
            
            return true
        end,
        ['^<<'] = function(tag, preset)
            
            local history = table.reverse(history)

            for i, tag in ipairs(history) do
                table.insert(preset, tag)
                assert(tag)
            end

            history = {}

            return true
        end
    }

    local presets = {}

    for name, preset in pairs(tweaks.presets.clantag) do 
        unpack_presets[name] = unpack_presets[name] or {}
        table.insert(presets, name)
        history= {}

        local preset = {}

        for i, tag in ipairs(tweaks.presets.clantag[name]) do
            
            if type(tag) == 'function' then tag = tag(history) end 

            if type(tag) == 'table' then 
                for index, element in ipairs(tag) do
                    table.insert(tweaks.presets.clantag[name], element)
                end

                goto continue
            end

            for resolver, callback in pairs(resolvers) do
                if string.find(tag, resolver) then callback(tag, preset) goto continue end
            end

            table.insert(history, tag)
            table.insert(preset, tag)

            assert(tag)

            ::continue::

        end

        unpack_presets[name] = preset
    end

    if #presets <= 0 then presets = {'No presets!'} end

    -- --

    local preset = ui.new_combobox(t, l, format('Clan-tag', 'Preset'), unpack(presets))
    local refresh = ui.new_slider(t, l, format('Clan-tag', 'Refresh rate'), 1, 250, 5, true, nil, .1, true)

    misc:add(preset, function() return ui.get(checkbox) end)
    misc:add(refresh, function() return ui.get(checkbox) end)
    local last

    
    ui.set_callback(checkbox, function()
        local v = ui.get(checkbox)

        client[(v and 'set' or 'unset') .. '_event_callback']('net_update_start', function()
            local tag = unpack_presets[ui.get(preset)]

            if not tag then return false end
    
            local time = math.floor(globals.curtime() * ui.get(refresh) + 0.5)
            local i = time % #tag + 1

            if i == last then return false end

            last = i
            client.set_clan_tag(tag[i])
        end)

        if not v then client.set_clan_tag('') end
    end)

    process_end('Clan-tag')
end

--[[

    V   I   S   U   A   L   S

]]

local visuals = tabs.new('Visuals')

local hitlog do
    process('Hit-logs')

    local checkbox = ui.new_checkbox(t, l, 'Enable hit-logs')
    visuals:add(checkbox)
    
    local ui_output, widget

    local logs = {}

    local output = {
        ['Console'] = function(str) if table.find(ui.get(ui_output), 'Console') and ui.get(checkbox) then tweaks.print(str) end end,
        ['Screen'] = function(str) if table.find(ui.get(ui_output), 'Screen') and ui.get(checkbox) then table.insert(logs, {
            text = str
        }) end end,
    }

    local events = {
        ['Ragebot'] = function(hit, data)
            output.Console(string.format(
                tweaks.colors[hit and 'green' or 'red'] .. '• ' .. tweaks.colors.gray .. '%s ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. '\'s ' .. tweaks.colors.base .. '%s ' .. tweaks.colors.gray ..'for ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' hp (%s hp left) ' .. tweaks.colors.base .. '~' .. tweaks.colors.gray .. '%s%s %s',
                (hit and 'Hit' or 'Missed'),
                entity.get_player_name(data.target),
                hg[data.hitgroup + 1] or '?',
                (data.damage or data.shot.damage),
                entity.get_prop(data.target, 'm_iHealth'),
                (hit and '' or ' ' .. data.reason .. ','),
                data.hitgroup ~= data.shot.hitgroup and (' exp:' .. tweaks.colors.base .. ' ' .. hg[data.shot.hitgroup+1] .. '-' .. data.shot.damage .. tweaks.colors.gray .. ', ') or '',
                tweaks.colors.base .. (data.backtrack or data.shot.backtrack) .. tweaks.colors.gray .. 't'
            ))

            output.Screen(string.format(
                tweaks.colors.gray .. 'FF%s ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF\'s ' .. tweaks.colors.base .. 'FF%s ' .. tweaks.colors.gray ..'FFfor ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF hp %s',
                (hit and 'Hit' or 'Missed'),
                entity.get_player_name(data.target),
                hg[data.hitgroup + 1] or '?',
                (data.damage or data.shot.damage),
                (hit and '' or tweaks.colors.base .. 'FF~ ' .. tweaks.colors.gray .. 'FF' .. data.reason)
            ))

            if not entity.is_alive(data.target) then
                output.Console(string.format(
                    tweaks.colors.base .. '• ' .. tweaks.colors.gray .. 'You killed ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' in ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. '!',
                    entity.get_player_name(data.target),
                    hg[data.hitgroup + 1] or '?'
                ))

                output.Screen(string.format(
                    tweaks.colors.gray .. 'FFYou killed ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF in ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF!',
                    entity.get_player_name(data.target),
                    hg[data.hitgroup + 1] or '?'
                ))
            end
        end,
        ['Damage'] = function(data)
            output.Console(string.format(
                tweaks.colors.red .. '• ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' damaged ' .. tweaks.colors.base .. 'You' .. tweaks.colors.gray .. ' in ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' for ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. 'hp',
                entity.get_player_name(data.attacker),
                hg[data.hitgroup + 1],
                (data.dmg_health or 0)
            ))

            output.Screen(string.format(
                tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF damaged ' .. tweaks.colors.base .. 'FFYou' .. tweaks.colors.gray .. 'FF in ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF (' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FFhp)',
                entity.get_player_name(data.attacker),
                hg[data.hitgroup + 1],
                (data.dmg_health or 0)
            ))

            if data.health <= 0 then
                output.Console(string.format(
                    tweaks.colors.red .. '• ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' killed ' .. tweaks.colors.base .. 'You' .. tweaks.colors.gray .. ' in ' .. tweaks.colors.base .. '%s',
                    entity.get_player_name(data.attacker),
                    hg[data.hitgroup + 1]
                ))
                output.Screen(string.format(
                    tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF killed ' .. tweaks.colors.base .. 'FFYou' .. tweaks.colors.gray .. 'FF in ' .. tweaks.colors.base .. 'FF%s',
                    entity.get_player_name(data.attacker),
                    hg[data.hitgroup + 1]
                ))
            end
        end,
    }

    local unpack_events, unpack_output = {}, {}

    for i, v in pairs(output) do table.insert(unpack_output, i) end 
    for i, v in pairs(events) do table.insert(unpack_events, i) end

    local ui_events = ui.new_multiselect(t, l, format('Hit-logs', 'Events'), unpack(unpack_events))
    ui_output = ui.new_multiselect(t, l, format('Hit-logs', 'Output'), unpack(unpack_output))

    visuals:add(ui_events, function() return ui.get(checkbox) end)
    visuals:add(ui_output, function() return ui.get(checkbox) end)

    local connected = {}

    local aim_log = {}

    -- RAGEBOT:

    client.set_event_callback('aim_fire', function(data) aim_log[data.id] = data end)
    client.set_event_callback('aim_miss', function(data)
        if not aim_log[data.id] or not table.find(ui.get(ui_events), 'Ragebot') or not ui.get(checkbox) then return false end

        local full = data
        full.shot = aim_log[data.id]        
        full.backtrack = globals.tickcount() - full.shot.tick 

        events.Ragebot(false, full)
    end)
    client.set_event_callback('aim_hit', function(data)
        if not aim_log[data.id] or not table.find(ui.get(ui_events), 'Ragebot') or not ui.get(checkbox) then return false end

        local full = data
        full.shot = aim_log[data.id]        
        full.backtrack = globals.tickcount() - full.shot.tick  

        events.Ragebot(true, full)
    end)

    -- DAMAGE:

    client.set_event_callback('player_hurt', function(data)
        if not ui.get(checkbox) or not table.find(ui.get(ui_events), 'Damage') then return false end

        local vid, aid = data.userid, data.attacker
        if not vid or not aid then return false end

        local victim, attacker = client.userid_to_entindex(vid), client.userid_to_entindex(aid)

        data.attacker = attacker

        if victim == entity.get_local_player() and entity.is_enemy(attacker) then events.Damage(data) end
    end)

    -- --

    local scrW, scrH = client.screen_size()

    local w, h = 400, 150
    local x, y = scrW / 2 - w / 2, scrH - h - 200

    local function render_log(i, data)
        local anim = widget.animate
        local x, y, w, h = anim.x, anim.y, anim.w, anim.h

        if #logs >= i + 4 then data.disabled = true end

        local tW, tH = renderer.measure_text('c', data.text)

        data.start = data.start or client.timestamp()
        data.timeout = data.timeout or 5000
        data.pos_lerp = data.pos_lerp or .75
        data.alpha_lerp = data.alpha_lerp or 0
        data.widht = data.widht or 1

        if data.disabled and data.alpha_lerp < .05 then table.remove(logs, i) return false end
        
        data.alpha_lerp = Lerp(globals.frametime() * 10, data.alpha_lerp, data.disabled and 0 or 1)
        data.pos_lerp = Lerp(globals.frametime() * 4, data.pos_lerp, data.disabled and 2 or 1)
        
        local w, h = (15 + tW) * data.alpha_lerp, 24
        w = math.floor(w)
        
        data.widht = Lerp(globals.frametime() * 10, data.widht, data.disabled and 1 or w)
        data.y_pos = data.y_pos or y + h
        data.x_pos = data.x_pos or anim.x + (anim.w / 2 - w / 2)
        data.x_pos = Lerp(globals.frametime() * 10, data.x_pos, anim.x + (anim.w / 2 - w / 2))
        data.y_pos = Lerp(globals.frametime() * 10, data.y_pos, y + 10 + (h * 1.5 * (i - 1)))
        
        render.rectangle(data.x_pos, data.y_pos * data.pos_lerp, w, h, 0, 0, 0, 125 * data.alpha_lerp, 4)
        renderer.text(data.x_pos + w / 2, (data.y_pos + h / 2) *  data.pos_lerp, 255, 255, 255, 255, 'c', data.widht, data.text)

        if client.timestamp() - data.start >= data.timeout then data.disabled = true end
    end

    widget = widgets.new('hit_log', function()

        for i, data in ipairs(logs) do
            local status, err = pcall(function() return render_log(i, data) end)
            if not status then assert(err) end
        end
        
    end, x, y, w, h, nil, true, true)

    ui.set_callback(checkbox, function()
        widget.paint = ui.get(checkbox)
    end)

    widget.paint = ui.get(checkbox)

    process_end('Hit-logs')
end

--[[ -- -- -- -- -- -- END: -- -- -- -- -- --  ]]--

printf('')
process_end('Tweaks.lua')