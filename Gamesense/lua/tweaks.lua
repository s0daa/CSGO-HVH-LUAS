--[[

        /á . ï½¡.áŸ\áµáµ‰áµ’Ê·ËËŠË— 
        Made by NeDIAD a.k.a NotDIAD
        https://github.com/NeDIAD/tweaks \ https://github.com/NeDIAD

]]

tweaks = tweaks or {}


tweaks.presets = {
    trashtalk = {
        Tweaks = {
            Kill = {'Kill phrase 1, %s', 'Kill phrase 2, %s', 'Kill phrase 3, %s'},
            Death = {'Death phrase 1, %s', 'Death phrase 2, %s', 'Death phrase 3, %s'},
        },
        ['English Agressive'] = {
            Kill = {"U think u good? luckily im here #SKEET","youre value compared to me  is but a grain of sand","all romanian(you) will die to me(gypys king)","this isnt phasmaphobia: global offensive please dont speak","SKEET trap house","I guarntee youre loss forever and always","ğ•¡ğ•£ğ• ğ•“ğ•ğ•–ğ•?","cope"," æ ¼æ‹‰æ ¼æ‹‰ < you? æ— åŠŸæ— è¿‡ < me B) #SKEET","in hvh war i will win","below average performance SKEET performance","SPEAK BULGARIAN? WILL TALK CN","you are loss it is decided with my SKEET.lua","you do not perform this hvh against SKEET","qahahaha i am top of this region","this weak snail is spoke of victory but is door unhinged to loss","you do not have the impression of owning the performance-enhancing software known as Gamesense.pub","how you will feel knowing im skeethaving and u will skeetless #SKEET","your mexican familia never make it out from trailer #SKEET","cant understand u. any noname translator? #SKEET","you waste aka fecal matter/shit(you)","sorry for u loss, me always better like life","better luck next round, oh wait i alr won BAHAHHA","ur lua & u sucks get SKEET >.<","when you spawn tell me why u die to me","how hit chance in deagle? i sit.", "shitting on your cheat speedrun any% WR run feat SKEET","smelly lapdog dreams of success in 1x1 but is handed 9 casualities","dude where are my diamonds?","all weak dogs fall to SKEET","WOW SKEET .ã€‚GYPSY çš„ç§‘æŠ€ (TECHNOLOGY) ? "},
                -- starlight killsay's
            Death = false
        },
        ['Russian Agressive'] = {
            Kill = {"Ğ½ÑÑ…Ğ°Ğ¹ Ğ¿ÑÑ‚ĞºÑƒ ÑÑ‹Ğ½ ÑˆĞ°Ğ±Ğ¾Ğ»Ğ´Ñ‹ Ñ‘Ğ±Ğ°Ğ½Ğ¾Ğ¹","ÑĞ¾ÑĞµÑˆÑŒ Ñ…ÑƒĞ¶Ğµ Ğ¼ĞµĞ³Ğ¸Ğ¾Ğ½ÑĞºĞ¸Ñ… Ñ†Ñ‹Ğ¿Ğ¾Ñ‡ĞµĞº","Ğ¾Ğ¼Ğ³ nice small pisunchik","Ñ‚Ñ‹ Ğ½Ğ¸Ñ…ÑƒÑ Ğ½Ğµ Ğ»ĞµĞ´Ğ¶ĞµĞ½Ğ´","OWNED, ÑÑ‹Ğ½ ÑˆĞ»ÑÑ…Ğ¸ Ñ‘Ğ±Ğ°Ğ½Ğ¾Ğ¹","Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑŒ Ğ¼Ğ¾ĞµĞ¹ Ğ¿Ğ¸ÑĞµÑ‡ĞºĞµ Ğ¸ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½ĞµĞ´Ñ€Ñ‹ ÑˆĞ°Ñ…Ñ‚Ñ‹ Ñ‚Ğ²Ğ¾ĞµĞ¹ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸","Ñ†ĞµĞ»ÑƒĞ¹ Ğ¿Ğ¸ÑĞ¸Ñ‡ĞºÑƒ fucking no legend","Ñ‚Ğ²Ğ¾Ñ Ğ¿Ğ¸ÑĞ¸Ñ‡ĞºĞ° Ñ‚Ğ°ĞºĞ°Ñ Ğ¶Ğµ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ°Ñ ĞºĞ°Ğº Ğ¸ iqshe4ka","Ğ² ÑĞ»ĞµĞ´ÑƒÑ‰ĞµĞ¹ Ñ€Ğ°Ğ· Ğ²Ñ‹Ğ¹Ğ³Ñ€Ğ°ĞµÑˆÑŒ Ğ»ĞµĞ´Ğ¶ĞµĞ½Ğ´Ğ°","Are you legend? ĞŸÑ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ğ½Ğ° Ğ¿Ğ¸ÑĞµÑ‡ĞºÑƒ Ğ´Ğ»Ñ ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ° - clocked#5537 virtual#0085","Ğ’Ğ« Ğ¢ĞĞšĞĞ™ Ğ–Ğ• Ğ¢ĞĞĞ¦ĞĞ  ĞšĞĞš Ğ›Ğ¯Ğ¡Ğ¢Ğ˜Ğ§ĞšĞ˜ NOLEGENDICKI","Ğ¢Ğ²Ğ¾Ñ Ğ¼Ğ°Ñ‚ÑŒ Ñ‚Ğ°ĞºĞ°Ñ Ğ¶Ğµ Ğ¶Ğ¸Ñ€Ğ½Ğ°Ñ ĞºĞ°Ğº idle nolegend (140)","Ğ½Ğ°ĞºĞ¾Ğ½Ñ‡Ğ°Ğ» Ğ½Ğ° Ñ‚Ğ²Ğ¾Ñ Ğ»Ñ‹ÑĞ¸Ğ½ĞºÑƒ Ğ¾Ğ½Ğ° ĞºĞ°Ğº Ñƒ Ğ±Ğ°Ñ‚ÑŒĞºĞ° ÑˆĞ°Ğ¼ĞµĞ»Ğ¸ÑĞ¸ĞºĞ°","Ñ‚Ğ²Ğ¾Ñ Ğ¼Ğ°Ğ¼Ğ°ÑˆĞ° Ğ¿Ñ€Ğ¸Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ğ»Ğ° Ğ¼Ğ½Ğµ Ğ²ĞºÑƒÑĞ½Ñ‹Ğµ Ğ±ÑƒÑ‚ĞµÑ€Ğ±Ñ€Ğ¾Ğ´Ğ¸ĞºĞ¸ ĞºĞ°Ğº Ñƒ gachi nolegend","Ñ‚Ñ‹ Ğ¾Ñ‡ĞµĞ½ÑŒ Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¾ Ğ»Ğ¸Ğ¶ĞµÑˆÑŒ Ğ¿ÑÑ‚Ğ¾Ñ‡ĞºĞ¸ Ğ½Ğ°ÑƒÑ‡Ğ¸ ĞºĞ»Ğ¾ĞºĞµĞ´Ğ¸ĞºĞ° legendicka","ÑˆĞ»ÑÑ…Ğ° ĞµĞ±Ğ°Ğ½Ğ°Ñ Ñ‚Ğ°Ğº Ğ¶Ğµ ÑĞ´Ğ¾Ñ…Ğ»Ğ° ĞºĞ°Ğº Ğ±Ğ°Ğ±ĞºĞ° Ñ„Ğ¸Ğ¿Ğ¿Ğ° Ğ¸ Ğ¼Ğ°ÑƒÑ‚Ğ°","ÑÑ‹Ğ½ ÑˆĞ»ÑÑ…Ğ¸ Ñƒ Ñ‚ĞµĞ±Ñ Ñ‚Ğ°ĞºĞ¸Ğµ Ğ¶Ğµ ĞºĞ¾Ğ¼Ğ¿ÑŒÑÑ‚ĞµÑ€Ğ¸ĞºĞ¸ ĞºĞ°Ğº Ñƒ vanino nolegend","Ñ‚Ğ²Ğ¾Ñ Ğ¼Ğ°Ğ¼Ğ°ÑˆĞ° Ğ»Ğ¸Ğ¶ĞµÑ‚ Ğ¼Ğ¾Ñ€Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾Ğµ Ğ¾Ğ¹ Ğ±Ğ»ÑÑ‚ÑŒ ÑÑ‚Ğ¾ Ğ¶Ğµ Ğ¼Ğ¾Ñ Ğ¿Ğ¸ÑĞµÑ‡ĞºĞ°","Ñƒ Ñ‚Ğ²Ğ¾ĞµĞ¹ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸ Ñ‚Ğ°ĞºĞ°Ñ Ğ¶Ğµ ÑƒĞ·ĞºĞ°Ñ Ğ¿Ğ¸Ğ·Ğ´Ğ° ĞºĞ°Ğº Ğ³Ğ»Ğ°Ğ·Ğ° d4ssh legend","Ñ‚Ñ‹ Ñ‚Ğ°ĞºĞ¾Ğ¹ Ğ¶Ğµ ĞµĞ±Ğ°Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ ĞºĞ°Ğº  l4fn nolegend","Ğ¼Ğ´Ğ° Ğ¸Ğ³Ñ€Ğ°ĞµÑˆÑŒ Ñ‚Ñ‹ ĞºĞ¾Ğ½ĞµÑ‡Ğ½Ğ¾ Ñ…ÑƒĞµĞ²Ğ¾ Ğ½Ğµ Ñ‚Ğ¾ Ñ‡Ñ‚Ğ¾ virtual legendick","Ñ€Ğ°Ğ·Ğ±Ğ¾Ğ¼Ğ±Ğ¸Ğ» Ñ‚ĞµĞ±Ğµ ĞµĞ±Ğ°ÑĞ¾ÑĞ¸Ğ½Ñƒ ĞºĞ°Ğº Ğ±Ğ¾Ğ¼Ğ±ÑÑ‚ walper nolegend","Ñ‚Ñ‹ Ğ½Ğ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ğ±ÑƒĞ´ĞµÑˆÑŒ legend Ñ Ñ‚Ğ°ĞºĞ¾Ğ¹ small pise4ka","Ğ¿Ğ¾ĞºĞ° Ñ‚Ñ‹ ÑĞ¾ÑĞµÑˆÑŒ Ñ…ÑƒĞ¹ Ğ¼Ñ‹ Ñ‡Ğ¸Ğ»Ğ¸Ğ¼ Ğ½Ğ° Ğ¾ÑÑ‚Ñ€Ğ¾Ğ²Ğµ legendickov","ÑˆĞ»ÑÑ…Ğ° ĞµĞ±Ğ°Ğ½Ğ°Ñ Ñ‚Ğ°Ğº Ğ¶Ğµ ÑĞ´Ğ¾Ñ…Ğ»Ğ° ĞºĞ°Ğº Ğ±Ğ°Ğ±ĞºĞ° Ñ„Ğ¸Ğ¿Ğ¿Ğ° Ğ¸ Ğ¼Ğ°ÑƒÑ‚Ğ°","Ñ…Ğ¾Ñ‡ĞµÑˆÑŒ ĞºÑƒĞ¿Ğ¸Ñ‚ÑŒ config by legendick? ĞŸĞĞ¨Ğ•Ğ› ĞĞĞ¥Ğ£Ğ™ Ğ¡Ğ«Ğ Ğ¨Ğ›Ğ®Ğ¥Ğ˜ ĞĞ‘ĞĞĞĞ™","Ğ­Ğ¥Ğ¥Ğ¥ ĞšĞĞš Ğ–Ğ• ĞĞ¥Ğ£Ğ•ĞĞĞ Ğ¡ĞĞ¡Ğ•Ğ¢ Ğ¢Ğ’ĞĞ¯ ĞœĞĞœĞĞ¨Ğ ĞœĞĞ™ PISUN4IK","e1","Ñ€Ğ°Ğ½Ğ´ĞµÑ€Ğ°Ğ½Ğ´ĞµÑ€Ğ°Ğ½Ğ´ĞµĞ²Ñƒ Ñ‚Ğ²Ğ¾Ñ Ğ¼Ğ°Ñ‚ÑŒ ÑˆĞ»ÑÑ…Ğ° ÑĞ¾ÑĞ°Ğ»Ğ° Ğ½Ğ°ÑĞ²Ñƒ","Ğ¿ÑƒĞ·Ğ¾ Ñ‚Ğ²Ğ¾ĞµĞ¹ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸ ÑˆĞ»ÑÑ…Ğ¸ Ñ‚Ğ°ĞºĞ¾Ğµ Ğ¶Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğµ ĞºĞ°Ğº Ñƒ shirazu nolegend","ĞĞ¥ĞĞ¥Ğ¥ĞĞ Ğ‘Ğ›Ğ¯ Ğ§Ğ•Ğ› Ğ¢Ğ« Ğ˜Ğ“Ğ ĞĞ•Ğ¨Ğ¬ Ğ¥Ğ£Ğ–Ğ• HOLATV","NEW META FUCKING NO LEGEND?","ĞµĞ±Ğ°Ñ‚ÑŒ Ñ Ñ‚Ñ ĞµĞ±Ğ½ÑƒĞ» ĞºĞ°Ğº Ğ±Ğ°Ğ±ĞºÑƒ Ğ¼Ğ°ÑƒÑ‚Ğ°","Ğ¡ĞĞ¡Ğ˜ Ğ¥Ğ£Ğ™ ĞŸĞ›ĞĞšĞ¡Ğ ĞĞ‘ĞĞĞĞ¯","Ğ˜Ğ—Ğ’Ğ˜ĞĞ¯Ğ™Ğ¡Ğ¯ Ğ¡Ğ«Ğ Ğ¨Ğ›Ğ®Ğ¥Ğ˜ ĞĞ‘ĞĞĞĞ™","ÑˆĞ»ÑÑ…Ğ° ĞµĞ±Ğ°Ğ½Ğ°Ñ Ñ‚Ğ°Ğº Ğ¶Ğµ ÑĞ´Ğ¾Ñ…Ğ»Ğ° ĞºĞ°Ğº Ğ±Ğ°Ğ±ĞºĞ° Ñ„Ğ¸Ğ¿Ğ¿Ğ° Ğ¸ Ğ¼Ğ°ÑƒÑ‚Ğ°","Ğ’Ğ«Ğ•Ğ‘ĞĞĞ Ğ’ ĞŸĞĞŸĞ­ĞŸĞĞ¦Ğ˜Ğ® FUCKING NO LEGEND","ĞĞ‘ĞĞĞ«Ğ™ Ğ¡Ğ«Ğ Ğ¨Ğ›Ğ®Ğ¥Ğ˜ Ğ¢Ğ« Ğ¥ĞĞ§Ğ•Ğ¨Ğ¬ ĞšĞĞš Ğ’Ğ˜Ğ¢ĞœĞ Ğ˜ Ğ¡Ğ¢Ğ˜Ğ’ĞĞ¥Ğ ĞœĞĞ• ĞŸĞ ĞĞ•ĞĞ¢Ğ¬","ÑÑ‹Ğ½ ÑˆĞ»ÑÑ…Ğ¸ Ñ‚Ñ‹ Ğ´ÑƒĞ¼Ğ°Ğ» Ğ¼Ğ¾Ñ Ğ¿Ğ¸ÑĞµÑ‡ĞºĞ° ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ñ‚ÑÑ Ñ Ñ‚Ğ²Ğ¾ĞµĞ¹?","ĞµÑĞ»Ğ¸ Ñ…Ğ¾Ñ‡ĞµÑˆÑŒ Ñ Ğ¼Ğ¾Ğ³Ñƒ Ñ‚ĞµĞ±Ñ Ğ½Ğ° ÑÑ‚Ñ€Ğ¸Ğ¼Ğµ Ğ¾Ğ±Ğ¾ÑÑĞ°Ñ‚ÑŒ","Ğ¢Ğ« ĞĞ• Ğ—ĞĞĞ•Ğ¨Ğ¬ Ğ›Ğ•Ğ”Ğ–Ğ•ĞĞ”ĞĞ’? ĞĞ‘ĞĞĞ«Ğ™ Ğ¡Ğ«Ğ Ğ¨Ğ›Ğ®Ğ¥Ğ˜ Ğ¡ 2023 Ğ›Ğ˜Ğ’ĞĞ˜","Ñ‚Ñ‹ Ñ‚Ğ°Ğº Ğ¶Ğµ Ğ·Ğ°Ñ„ĞµĞ¹Ğ»Ğ¸ÑˆÑŒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ğ½Ğ° Ğ¿Ğ¸ÑĞµÑ‡ĞºĞ¸ ĞºĞ°Ğº mishat nolegend","Ñ‚Ñ‹ Ñ‚Ğ°Ğ½Ñ†ÑƒĞµÑˆÑŒ Ñ Ğ±ÑƒÑ‚Ñ‹Ğ»ĞºĞ¾Ğ¹ ĞºĞ°Ğº ĞµĞ±Ğ°Ğ½Ñ‹Ğ¹ clocked legend?","1","Ğ½Ğ°Ñ…ÑƒĞ¹ Ñ‚Ñ‹ Ğ¾Ñ‚ Ğ¼ĞµĞ½Ñ ÑƒĞ±ĞµĞ³Ğ°ĞµÑˆÑŒ ĞºĞ°Ğº Ğ±Ğ°Ñ‚ĞµĞº virtual legend","ĞµĞ±Ğ°Ñ‚ÑŒ Ñ Ñ‚Ñ ĞµĞ±Ğ½ÑƒĞ» ĞºĞ°Ğº Ğ±Ğ°Ğ±ĞºÑƒ Ğ¼Ğ°ÑƒÑ‚Ğ°","ĞµÑĞ»Ğ¸ Ñ…Ğ¾Ñ‡ĞµÑˆÑŒ Ğ¼Ğ¾Ğ¶ĞµÑˆÑŒ Ğ¿Ñ€Ğ¸ĞºÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ°Ğ¹Ñ„Ğ¾Ğ½Ñ‡Ğ¸Ğº 5 s ĞºĞ°Ğº Ñƒ merlex nolegend","ĞµÑĞ»Ğ¸ Ñ…Ğ¾Ñ‡ĞµÑˆÑŒ Ğ½Ğ°ÑƒÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ñ‚ĞµĞ±Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ Ğ² ÑÑ‚Ğ°Ğº legend pise4ki","Ñ‚Ğ²Ğ¾Ñ Ğ¼Ğ°Ñ‚ÑŒ Ñ‚Ğ°ĞºĞ°Ñ Ğ¶Ğµ ĞµĞ±Ğ°Ğ½Ğ°Ñ Ğ¸Ğ½Ğ²Ğ°Ğ»Ğ¸Ğ´ĞºĞ° ĞºĞ°Ğº fiks nolegend","Ñ‡Ğµ Ğ¿Ğ¸Ğ´Ğ¾Ñ€Ğ°Ñ Ñ†Ğ°Ğ¿Ğ½ÑƒĞ» Ğ² Ğ¿Ğ¸ÑĞµÑ‡ĞºÑƒ?","ĞµĞ±Ğ°Ñ‚ÑŒ Ñ Ñ‚Ñ ĞµĞ±Ğ½ÑƒĞ» ĞºĞ°Ğº Ğ±Ğ°Ğ±ĞºÑƒ Ğ¼Ğ°ÑƒÑ‚Ğ°","Ñ‚Ñ‹ ÑĞ´Ğ¾Ñ… Ñ€Ğ°Ğ½ÑŒÑˆĞµ ÑĞ²Ğ¾ĞµĞ¹ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸ ÑˆĞ»ÑÑ…Ğ¸ Ğ¾Ğ¹ Ğ¸Ğ»Ğ¸ Ğ¾Ğ½Ğ° ÑƒĞ¶Ğµ ÑĞ´Ğ¾Ñ…Ğ»Ğ° ?","Ñ‚Ğ²Ğ¾Ñ Ğ¼Ğ°Ğ¼ĞºĞ° Ğ»ÑĞ±Ğ¸Ñ‚ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ğµ Ğ»ĞµĞ´Ğ¶ĞµĞ½Ğ´ÑĞºĞ¸Ğµ Ğ¾Ğ»Ğ¾Ğ»Ğ¾","Ñ‘Ğ±Ğ°Ğ½Ñ‹Ğ¹ Ğ½Ğ¾Ñƒ Ğ»ĞµĞ´Ğ¶ĞµĞ½Ğ´ Ñ‚Ñ‹ ĞºĞ¾Ğ³Ğ¾ Ğ¿Ñ‹Ñ‚Ğ°Ğ»ÑÑ ÑƒĞ±Ğ¸Ñ‚ÑŒ?","Ğ¾Ğ¹ Ğ±Ñ€Ğ°Ñ‚Ğ°Ğ½ Ğ¿Ğ¾Ñ…Ğ¾Ğ´Ñƒ Ñ‚ĞµĞ±Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ ĞºÑƒĞ¿Ğ¸Ñ‚ÑŒ ĞºÑ„Ğ³ĞµÑˆĞºÑƒ Ğ»ĞµĞ´Ğ¶ĞµĞ½Ğ´Ğ¸ĞºĞ°","Ğ¶Ğ´Ñƒ Ñ€ĞµĞ²Ğ°Ğ½ÑˆĞ° ÑÑ‹Ğ½ ĞµĞ±Ğ°Ğ½Ğ¾Ğ¹ ÑˆĞ»ÑÑ…Ğ¸","ĞµĞ±Ğ°Ñ‚ÑŒ Ñ Ñ‚Ñ ĞµĞ±Ğ½ÑƒĞ» ĞºĞ°Ğº Ğ±Ğ°Ğ±ĞºÑƒ Ğ¼Ğ°ÑƒÑ‚Ğ°","Ğ¿ĞµÑ€ĞµĞ¸Ğ³Ñ€Ğ°Ğ½Ğ° 12 Ğ»ĞµÑ‚ĞºĞ° ĞµĞ±ÑƒÑ‡Ğ°Ñ ","Ğ·Ğ½Ğ°ĞµÑˆÑŒ Ñ‡ĞµĞ¼ Ğ¿Ğ°Ñ…Ğ½ÑƒÑ‚ Ğ¼Ğ¾Ğ¸ ÑĞ¸Ñ‡ĞºĞ¸? ÑĞ¿Ñ€Ğ¾ÑĞ¸ Ñƒ ÑĞ²Ğ¾ĞµĞ¹ Ğ¼Ğ°Ğ¼Ğ°ÑˆĞ¸ ÑˆĞ»ÑÑ…Ğ¸ Ñ‘Ğ±Ğ°Ğ½Ğ¾Ğ¹ ", "Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ½Ğ°Ñ‡Ğ°Ğ»Ğ° ĞºÑƒĞ¿Ğ¸ÑˆÑŒ Ğ¿ĞºĞµÑˆĞ¾Ñ‡ĞºĞ¸ ĞºĞ°Ğº Ñƒ Ğ»ĞµĞ´Ğ¶ĞµĞ½Ğ´Ğ¸ĞºĞ¾Ğ²? ", "Ñ‡Ğµ Ñ‚Ğ¾ Ñ‚Ñ‹ Ğ¼Ğ¾Ğ¸ Ğ³Ñ€ÑĞ·Ğ½Ñ‹Ğµ ÑĞ¸Ñ‡ĞºĞ¸ Ğ¾Ğ±Ğ»Ğ¸Ğ·Ğ°Ğ» ÑÑ‹Ğ½ Ñ‘Ğ±Ğ°Ğ½Ğ¾Ğ¹ Ğ¿Ğ¸Ğ·Ğ´Ñ‹"},
                -- bluhgang killsay's
            Death = false
        },
        ['Just One'] = {
            Kill = {'1', 'â‘ ', 'â¶', '111', '.â€¢Â°*â€ËœËœâ€*Â°â€¢ 1 â€¢Â°*â€ËœËœâ€*Â°â€¢', '.â€¢Â°*â€ËœËœâ€*Â°â€¢â™¥â—â€¢Ù  1 Ù â€¢â—â™¥Â°*â€ËœËœâ€*Â°â€¢', 'â˜€*â€Ëœ 1 Ëœâ€*â˜€'}, 
            Death = false
        },
        
        --[[
        
            %s - Nickname who was killed / you

            function(player) return entity.get_player_name(player) end -- PlayerName 
            event = false -- Disable event

        ]]
    },
    clantag = {
        Tweaks = {
            '>> tweaks.lua:_', 'tweaks.lua', 'tweaks.lua', '<<'
        },
        ['nya :3'] = {
            '>> nya :3:_', 'nya :3',  'nya :3', '<<' 
        }
        
        --[[
        
            Markup:

            '@:' = ':' Escape

            '>> clantag:animation': -- Animate text
                Sample = '>> 123:_'
                Result: '1_', '2_', '3_'

                Another Sample = '>> 123'
                Result: '1', '2', '3'

            '<<': -- Reverse tag
                Sample = {'1', '2', '<<', '4', '3', '<<'}
                Result: '1', '2', '2', '1', '4', '3', '3', '4'

            {...}: -- Table of tags
                Sample = {{'1', '2', '3'}, {'3', '2', '1'}}
                Result: '1', '2', '3', '3', '2', '1'

            function(history) return history end: Function, first argument (table) = history of tags
                Sample = {'1', '2', function(history) return history end}
                Result: '1', '2', '1', '2'
                    -- ^^ Explanation:
                    Because function returns a table of tags, resolver will resolve every tag & add it to preset.

        ]]
    }
}

local hg = {'generic', 'head', 'chest', 'stomach', 'left arm', 'right arm', 'left leg', 'right leg', 'neck', '?', 'gear'}

table.reverse = function(a) local b = {} for i, v in ipairs(a) do table.insert(b, 1, v) end return b end
table.find = function(a, b) for i, v in ipairs(a) do if v == b then return i end end for i, v in pairs(a) do if v == b then return i end end return false end
string.split = function(input, sep) if sep == nil then sep = '%s' end local t = {} for str in string.gmatch(input, "([^"..sep.."]+)") do table.insert(t, str) end return t end

local function Lerp(d, h, t)
    if not d or not h or not t then return 0 end

	if d > 1 then return to end
    if d < 0 then return from end
    
	return (h + ( t - h ) * d or 0) 
end

local ffi = require('ffi')
local http = require('gamesense/http')

local color do
    local hex_rgb = function (hex)
        hex = string.gsub(hex, "^#", "")
        return tonumber(string.sub(hex, 1, 2), 16), tonumber(string.sub(hex, 3, 4), 16), tonumber(string.sub(hex, 5, 6), 16), tonumber(string.sub(hex, 7, 8), 16) or 255
    end

    
    local mt = {
        __eq = function (a, b)
            return a.r == b.r and a.g == b.g and a.b == b.b and a.a == b.a
        end,
        lerp = function (h, t, w)
            return create(h.r + (t.r - h.r) * w, h.g + (t.g - h.g) * w, h.b + (t.b - h.b) * w, h.a + (t.a - h.a) * w)
        end,
        to_hex = hex_rgb,
        alphen = function (self, a, r)
            return create(self.r, self.g, self.b, r and a * self.a or a)
        end,
    }	mt.__index = mt
    
    local create = ffi.metatype(ffi.typeof("struct { uint8_t r; uint8_t g; uint8_t b; uint8_t a; }"), mt)
    
    color = {}
    
    color.rgb = function (r,g,b,a)
        r = math.min(r or 255, 255)
        return create(r, g and math.min(g, 255) or r, b and math.min(b, 255) or r, a and math.min(a, 255) or 255)
    end
    color.hex = function (hex)
        local r,g,b,a = hex_rgb(hex)
        return create(r,g,b,a)
    end
end

local printf do
	local native_print = vtable_bind("vstdlib.dll", "VEngineCvar007", 25, "void(__cdecl*)(void*, const void*, const char*, ...)")
    
	printf = function (...)
		for i, v in ipairs{...} do
			local r = "\aD9D9D9" .. string.gsub(tostring(v), "[\r\v]", {["\r"] = "\aD9D9D9", ["\v"] = "\a".. (('\a74A6A9FF'):sub(1, 7))})
			for col, text in r:gmatch("\a(%x%x%x%x%x%x)([^\a]*)") do
				native_print(color.hex(col), text)
			end
		end
		native_print(color.rgb(217, 217, 217), "\n")
	end
end

local function rgb(r, g, b, a)
    r = r or 255; g = g or 255; b = b or 255; a = a or 255;

    if a == 255 then
        return string.format('\a%02X%02X%02X', r, g, b)
    else
        return string.format('\a%02X%02X%02X%02X', r, g, b, a)
    end
end

tweaks.colors = {
    base = rgb(164, 158, 229),
    gray = rgb(221, 221, 221),
    white = rgb(255, 255, 255),

    red = rgb(243, 74, 74),
    green = rgb(74, 243, 97),

    render_color = {
        base = {r = 128, g = 125, b = 165, a = 170}
    }
}

tweaks.settings = {
    prefix = '   ' .. tweaks.colors.base .. 'tweaks.lua \a'.. tweaks.colors.white ..'Â» ',
    dev = false,
    version = 'alpha 0.3'
}

client.exec('clear')

printf(
    tweaks.colors.base .. '    _____                  _          _\n',        
    tweaks.colors.base .. '   |_   _|                | |        | |\n',      
    tweaks.colors.base .. '     | |_      _____  __ _| | _____  | |_   _  __ _\n',
    tweaks.colors.base .. '     | \\ \\ /\\ / / _ \\/ _` | |/ / __| | | | | |/ _` |\n',
    tweaks.colors.base .. '     | |\\ V  V /  __/ (_| |   <\\__ \\_| | |_| | (_| |\n',
    tweaks.colors.base .. '     \\_/ \\_/\\_/ \\___|\\__,_|_|\\_\\___(_)_|\\__,_|\\__,_|\n'
)

function tweaks.print(...) 
    local args = {...}
    printf(tweaks.settings.prefix, unpack(args))
end

local function assert(str) if tweaks.settings.dev then tweaks.print(str) end end

local function process(str) tweaks.print('Processing ' .. tweaks.colors.white .. str .. tweaks.colors.base ..' (' .. string.format('%.2f', client.timestamp() - tweaks.start) .. 's)') end
local function process_end(str) tweaks.print('Processed ' .. tweaks.colors.white .. str .. tweaks.colors.base ..' (' .. string.format('%.2f', client.timestamp() - tweaks.start) .. 's)') end

tweaks.print('Processing started ')
tweaks.start = client.timestamp()
tweaks.print('Init version: ' .. tweaks.colors.base .. tweaks.settings.version)

if tweaks.settings.dev then tweaks.print('Loaded in ' .. tweaks.colors.base .. 'dev-mode' .. tweaks.colors.gray ..'!') end

printf('')

local render do
    process('Render library')
    render = {}

    function render.rectangle(x, y, w, h, r, g, b, a, radius)
        x = type(x) == 'number' and x or 0; y = type(y) == 'number' and y or 0; w = type(w) == 'number' and w or 0; h = type(h) == 'number' and h or 0; r = r or 255 g = g or 255 b = b or 255 a = a or 255 radius = radius or 8
        x = math.floor(x); y = math.floor(y); w = math.floor(w); h = math.floor(h)

        if h < 10 then h = 10 end
        if w < 10 then w = 10 end

        renderer.rectangle(x + radius, y, w - 2 * radius, h, r, g, b, a)
        renderer.rectangle(x, y + radius, radius, h - 2 * radius, r, g, b, a)
        renderer.rectangle(x + w - radius, y + radius, radius, h - 2 * radius, r, g, b, a)

        renderer.circle(x + radius, y + h - radius, r, g, b, a, radius, -90, 0.25) -- l b
        renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25) -- l t
        renderer.circle(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25) -- r b
        renderer.circle(x + w - radius, y + radius, r, g, b, a, radius, 90, 0.25) -- r t
    end
   
    process_end('Render library')
end

local mouse do
    process('Mouse library')

    mouse = {}
    
    function mouse.held() return client.key_state(0x01) end
    function mouse.inbounds(x, y, w, h) 
        if not x or not y or not w or not h then assert('Memory leak? Nil values defined!') end

        x = x or 0 y = y or 0 w = w or 0 h = h or 0

        local endX, endY = x + w, y + h
        local mX, mY = ui.mouse_position()

        return mX >= x and mY >= y and mX <= endX and mY <= endY
    end
    function mouse.calc(x1, y1, x2, y2, w, h)
        local scrW, scrH = client.screen_size()
        local mX, mY = ui.mouse_position()
    
        local offsetX = x2 - x1
        local offsetY = y2 - y1

        local newX = mX - offsetX
        local newY = mY - offsetY

        --assert('x1, x2, y1, y2, resX, resY: '..' '.. x1..' '.. x2..' '.. y1..' '.. y2..' '.. newX..' '.. newY)
        --assert('mX, mY, scrW, scrH: '.. mX ..' '.. mY..' '.. scrW..' '.. scrH)

        if newX < 0 then assert('x < 0') newX = 0 end
        if newY < 0 then assert('y < 0') newY = 0 end
        if newX + w > scrW then assert('x > scr') newX = scrW - w end
        if newY + h > scrH then assert('y > scr') newY = scrH - h end

        return newX, newY
    end

    process_end('Mouse library')
end

--[[ -- -- -- -- -- -- MAIN -- -- -- -- -- --  ]]--

local widgets do
    process('Widgets')

    widgets = {}
    widgets.__index = widgets
    widgets.widgets = {}
    local scrW, scrH = client.screen_size()

    local mouse_magnet = {
        y = {35, scrH / 2, scrH - 35},
        x = {scrW / 2}
    }

    
    function widgets.new(id, push, x, y, w, h, draggable, tooltip, lock_size)
        if not id or widgets.widgets[id] then return false end
        push = type(push) == 'function' and push or function() end
        x, y, w, h = type(x) == 'number' and x or 0, type(y) == 'number' and y or 0, type(w) == 'number' and w or 50, type(h) == 'number' and h or 50
        
        draggable = type(draggable) == 'table' and draggable or { x = true, y = true }

        local self = setmetatable({}, widgets)
        
        self.current = {x = x, y = y, w = w, h = h}
        self.animate = {x = x, y = y, w = w, h = h}
        self.paint = true

        local function line(x1, y1, x2, y2) renderer.line(x1, y1, x2, y2, 255, 255, 255, (self.line_alpha or 0)) end

        local function slider(scale, init, align)

            --[[
                align:true = Y
                align:false = X
            ]]

            local slide = ui.new_slider('CONFIG', 'Presets', id .. ':' .. scale, 0, (align and scrH or scrW), init)
            if not tweaks.settings.dev then ui.set_visible(slide, false) end

           return slide
        end

        self.ui = {
            x = slider('x', x),
            y = slider('y', y, true),
        }

        if not lock_size then
            self.ui.w = slider('w', w)
            self.ui.h = slider('h', h, true)
        end

        for scale, slider in pairs(self.ui) do
            ui.set_callback(slider, function() self.current[scale] = ui.get(slider) end)
        end

        self.push = function()

            -- Handling data:

            if type(self.current) ~= 'table' then assert('Rebuild: self.current') self.current = {x = x, y = y, w = w, h = h} end
            if type(self.animate) ~= 'table' then assert('Rebuild: self.animate') self.animate = self.current end
            if type(self.ui) ~= 'table' then assert('Memory leak! No UI elements') return false end

            if type(self.alpha) ~= 'number' then self.alpha = 20 end
            
            -- --
            
            -- Lerps:
            
            for scale, value in pairs(self.current) do
                if self.animate[scale] == value then goto continue end
                
                self.animate[scale] = Lerp(globals.frametime() * 10, self.animate[scale], value)
                
                ::continue::
            end
            
            if not self.paint and self.alpha < 10 then return false end
            
            -- --
            
            -- Render:
            
            self.snap = ui.is_menu_open() and self.drag and not client.key_state(0x10) and tooltip
            
            if ui.is_menu_open() or not globals.mapname() then
                
                -- Handling mouse:
                
                local check = self.drag or mouse.inbounds(self.current.x, self.current.y, self.current.w, self.current.h)
                self.alpha = Lerp(globals.frametime() * 10, self.alpha, (check and self.paint) and 70 or (self.paint and 20 or 0))
                
                if mouse.held() and check and (draggable.x or draggable.y) and (not widgets.drag_id or widgets.drag_id == id) then
                    widgets.drag_id = id
                    
                    if not self.drag then 
                        self.drag = {sX = self.current.x, sY = self.current.y} 
                        self.drag.mX, self.drag.mY = ui.mouse_position()
                    end
                    local x, y = mouse.calc(self.drag.sX, self.drag.sY, self.drag.mX, self.drag.mY, self.current.w, self.current.h)
                    
                    local scales = {
                        x = x,
                        y = y
                    }
                    
                    if self.snap then
                        for scale, magnet in pairs(mouse_magnet) do
                            if not draggable[scale] then goto continue end
                            
                            for i, value in ipairs(magnet) do
                                if math.abs(scales[scale] - value) <= self.current[scale == 'x' and 'w' or 'h'] then
                                    scales[scale] = value - self.current[scale == 'x' and 'w' or 'h'] / 2
                                    if scales[scale] < 0 then scales[scale] = value end
                                    if scales[scale] > (scale == 'x' and scrW - self.current.w or scrH - self.current.h) then scales[scale] = value - self.current[scale == 'x' and 'w' or 'h']  end
                                end
                            end
                            
                            ::continue::
                        end
                    end
                    
                    if draggable.x then ui.set(self.ui.x, scales.x) end
                    if draggable.y then ui.set(self.ui.y, scales.y) end
                else
                    if widgets.drag_id == id then widgets.drag_id = nil end
                    self.drag = nil
                end
                
                -- --
                
            else
                self.alpha = Lerp(globals.frametime() * 10, self.alpha, 0)
            end
            
            if (self.alpha or 0) > 5 then
                local c = self.animate
                
                render.rectangle(c.x, c.y, c.w, c.h, 255, 255, 255, self.alpha, 4)
                
                self.line_alpha = Lerp(globals.frametime() * 10, self.line_alpha, (self.drag and self.snap) and 200 or 0)

                if (self.line_alpha or 0) > 5 and tooltip then

                    for scale, magnets in pairs(mouse_magnet) do
                        if not draggable[scale] then goto continue end
                        
                        for i, value in ipairs(magnets) do
                            local style = (scale == 'y' and {0, value, scrW, value} or {value, 0, value, scrH})
                            
                            line(unpack(style))
                        end
                        
                        ::continue::
                    end
                    
                    if draggable.x or draggable.y then 
                        self.text_multi = Lerp(globals.frametime() * 10, self.line_alpha, (self.drag and self.snap) and scrW + scrH or 1)

                        renderer.text(scrW / 2, scrH - 100, 255, 255, 255, 255, 'cb+', self.text_multi,  tweaks.colors.base .. 'FFSHIFT' .. tweaks.colors.gray .. 'FF - Disable snap to grid') 
                        renderer.text(self.animate.x + self.animate.w / 2, self.animate.y + self.animate.h / 2, 255, 255, 255, 255, 'cb+', self.text_multi, tweaks.colors.gray .. 'FFX: ' .. tweaks.colors.base .. 'FF' .. self.current.x .. tweaks.colors.gray .. 'FF Y:' .. tweaks.colors.base .. 'FF' .. self.current.y)
                    end
                    
                end
            end
            
            -- --
            
            local status, err = pcall(push)
            if not status then assert(err) end
        end
        
        widgets.widgets[id] = self
        
        return self
    end
    
    client.set_event_callback('paint_ui', function()
        for id, self in pairs(widgets.widgets) do
            if type(self) ~= 'table' or type(self.push) ~= 'function' then assert('Type error! '.. id) goto continue end

            local status, err = pcall(function() self.push() end)
            if not status then assert('Error: '.. err) end

            ::continue::
        end 
    end)

    process_end('Widgets')
end

local t, l = 'Lua', 'A'

local tabs do
    process('Tabs')
    local active_tab, combo, tabslist = nil, nil, {}
    
    tabs = {}
    tabs.__index = tabs
    
    tabs.tabs = {}
    
    function tabs.new(name)
        if not name then return false end
        name = tostring(name)
        
        local prev_value
        
        if combo then prev_value = ui.get(combo); ui.set_visible(combo, false) end
        
        table.insert(tabslist, name)
        
        combo = ui.new_combobox(t, 'B', tweaks.colors.white .. 'FF â€¢ '.. tweaks.colors.base .. 'FFTweaks' .. tweaks.colors.white .. 'FF Â»'.. tweaks.colors.gray ..'FF Select tab', unpack(tabslist))
        if prev_value then ui.set(combo, prev_value) end
        
        tabs.tabs[name] = {}
        
        local self = setmetatable({tab = name, elements = tabs.tabs[name]}, tabs)
        
        return self
    end
    
    function tabs:add(element, requirement)
        if not element or not self or type(self) ~= 'table' then return false end
        requirement = requirement or function() return true end
        
        table.insert(self.elements, {element, requirement})
    end
    
    client.set_event_callback('paint_ui', function()
        if not ui.is_menu_open() then return false end
        
        for i,v in pairs(tabs.tabs) do
            if type(v) ~= 'table' then assert('Tab ' .. tostring(i) .. ' not table') goto continue end
            
            for _, element in ipairs(v) do
                if type(element) ~= 'table' then assert('Element ' .. tostring(_) .. ' not table!') goto continue end
                if not element[1] or type(element[2]) ~= 'function' then assert('One of elements error') goto continue end
                
                local success, err = pcall(function() ui.set_visible(element[1], element[2]() and ui.get(combo) == i) end)
                if not success then assert(err) end
                
                ::continue::
            end
            
            ::continue::
        end
    end)

    process_end('Tabs')
end
local function format(space, value) return tweaks.colors.gray ..'FF' .. space .. tweaks.colors.white .. 'FF Â» ' .. tweaks.colors.base .. 'FF' .. value end

--[[

    M   I   S   C

]]

local misc = tabs.new('Misc')

local trashtalk do
    process('Trash-talk')

    local checkbox = ui.new_checkbox(t, l, 'Enable Trash-talk')
    misc:add(checkbox)

    process('Trash-talk > Presets')

    local unpack_presets, unpack_events = {}, {}

    for name, preset in pairs(tweaks.presets.trashtalk) do 
        assert('New preset: '.. name)

        table.insert(unpack_presets, name)

        for event, phrases in pairs(preset) do
        
        if not table.find(unpack_events, event) then assert('New event: '.. event) table.insert(unpack_events, event) end

        --[[    for i, phrase in ipairs(phrases) do-- Ğ’ Ğ±ÑƒĞ´ÑƒÑÑ‰ĞµĞ¼ Ğ·Ğ´ĞµÑÑŒ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ‡Ñ‚Ğ¾-Ñ‚Ğ¾ Ğ±ÑƒĞ´ĞµÑ‚
                assert('New phrase: ' .. tostring(phrase) .. ':' .. type(phrase))
            end ]]
        end
    end

    if #unpack_presets <= 0 then unpack_presets = {'No presets!'} end
    if #unpack_events <= 0 then unpack_events = {'No events!'} end

    local preset = ui.new_combobox(t, l, format('Trash-talk', 'Preset'), unpack(unpack_presets))
    local events = ui.new_multiselect(t, l, format('Trash-talk', 'Events'), unpack(unpack_events))
    misc:add(events, function() return ui.get(checkbox) end)
    misc:add(preset, function() return ui.get(checkbox) end)

    local function get_preset(field, player)
        local preset = tweaks.presets.trashtalk[ui.get(preset)]
        if not preset[field] then return false end

        if #preset[field] <= 1 then return preset[field][1] or '?' end

        local phrase = preset[field][client.random_int(1, #preset[field])]

        if type(phrase) == 'function' then phrase = phrase(player) end
        return phrase
    end

    ui.set_callback(checkbox, function()
        local v = ui.get(checkbox)

        client[(v and 'set' or 'unset') .. '_event_callback']('player_death', function(data)
        
            local vid, aid = data.userid, data.attacker
            if not vid or not aid then return false end

            local victim, attacker = client.userid_to_entindex(vid), client.userid_to_entindex(aid)

            if entity.is_enemy(victim) and attacker == entity.get_local_player() and table.find(ui.get(events), 'Kill') then
                assert('Trash-talk (kill)')

                local phrase = get_preset('Kill', victim)

                if not phrase then return false end
                client.delay_call(.3, function() client.exec('say ', string.format(phrase, entity.get_player_name(victim))) end)
            elseif entity.is_enemy(attacker) and victim == entity.get_local_player() and table.find(ui.get(events), 'Death') then
                assert('Trash-talk (death)')
                
                local phrase = get_preset('Death', attacker)

                if not phrase then return false end
                client.delay_call(.3, function() client.exec('say ', string.format(phrase, entity.get_player_name(attacker))) end)
            else
                assert('Trash-talk (skip)')
            end

        end)
    end)

    process_end('Trash-talk')
end

local clantag do
    process('Clan-tag')

    local checkbox = ui.new_checkbox(t, l, 'Enable Clan-tag')
    misc:add(checkbox)

    process('Clan-tag > Presets')

    local unpack_presets = {}
    local history = {}

    -- PRESETS RESOLVER:

    local resolvers = {
        ['^>> '] = function(tag, preset)

            should_remove = string.find(tag, ':')

            tag = string.gsub(tag, '^>> ', '')
            local solve = ''

            if string.find(tag, '@:.$') then
                local tag = string.gsub(tag, '@([^@]*)$', '%1')
                table.insert(history, tag)
                table.insert(preset, tag)

                assert(tag)

                return true 
            end
            
            local split = string.split(tag, ':')
            
            if #split > 1 then
                solve = split[#split]
            end

            tag = string.sub(tag, 1, #tag - #solve - (should_remove and 1 or 0))

            local result = ''

            table.remove(split, #split)

            for char in tag:gmatch('.') do
                result = result .. char

                local gtag = result .. solve

                table.insert(history, gtag)
                table.insert(preset, gtag)

                assert(gtag)
            end
            
            return true
        end,
        ['^<<'] = function(tag, preset)
            
            local history = table.reverse(history)

            for i, tag in ipairs(history) do
                table.insert(preset, tag)
                assert(tag)
            end

            history = {}

            return true
        end
    }

    local presets = {}

    for name, preset in pairs(tweaks.presets.clantag) do 
        unpack_presets[name] = unpack_presets[name] or {}
        table.insert(presets, name)
        history= {}

        local preset = {}

        for i, tag in ipairs(tweaks.presets.clantag[name]) do
            
            if type(tag) == 'function' then tag = tag(history) end 

            if type(tag) == 'table' then 
                for index, element in ipairs(tag) do
                    table.insert(tweaks.presets.clantag[name], element)
                end

                goto continue
            end

            for resolver, callback in pairs(resolvers) do
                if string.find(tag, resolver) then callback(tag, preset) goto continue end
            end

            table.insert(history, tag)
            table.insert(preset, tag)

            assert(tag)

            ::continue::

        end

        unpack_presets[name] = preset
    end

    if #presets <= 0 then presets = {'No presets!'} end

    -- --

    local preset = ui.new_combobox(t, l, format('Clan-tag', 'Preset'), unpack(presets))
    local refresh = ui.new_slider(t, l, format('Clan-tag', 'Refresh rate'), 1, 250, 5, true, nil, .1, true)

    misc:add(preset, function() return ui.get(checkbox) end)
    misc:add(refresh, function() return ui.get(checkbox) end)
    local last

    
    ui.set_callback(checkbox, function()
        local v = ui.get(checkbox)

        client[(v and 'set' or 'unset') .. '_event_callback']('net_update_start', function()
            local tag = unpack_presets[ui.get(preset)]

            if not tag then return false end
    
            local time = math.floor(globals.curtime() * ui.get(refresh) + 0.5)
            local i = time % #tag + 1

            if i == last then return false end

            last = i
            client.set_clan_tag(tag[i])
        end)

        if not v then client.set_clan_tag('') end
    end)

    process_end('Clan-tag')
end

--[[

    V   I   S   U   A   L   S

]]

local visuals = tabs.new('Visuals')

local hitlog do
    process('Hit-logs')

    local checkbox = ui.new_checkbox(t, l, 'Enable hit-logs')
    visuals:add(checkbox)
    
    local ui_output, widget

    local logs = {}

    local output = {
        ['Console'] = function(str) if table.find(ui.get(ui_output), 'Console') and ui.get(checkbox) then tweaks.print(str) end end,
        ['Screen'] = function(str) if table.find(ui.get(ui_output), 'Screen') and ui.get(checkbox) then table.insert(logs, {
            text = str
        }) end end,
    }

    local events = {
        ['Ragebot'] = function(hit, data)
            output.Console(string.format(
                tweaks.colors[hit and 'green' or 'red'] .. 'â€¢ ' .. tweaks.colors.gray .. '%s ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. '\'s ' .. tweaks.colors.base .. '%s ' .. tweaks.colors.gray ..'for ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' hp (%s hp left) ' .. tweaks.colors.base .. '~' .. tweaks.colors.gray .. '%s%s %s',
                (hit and 'Hit' or 'Missed'),
                entity.get_player_name(data.target),
                hg[data.hitgroup + 1] or '?',
                (data.damage or data.shot.damage),
                entity.get_prop(data.target, 'm_iHealth'),
                (hit and '' or ' ' .. data.reason .. ','),
                data.hitgroup ~= data.shot.hitgroup and (' exp:' .. tweaks.colors.base .. ' ' .. hg[data.shot.hitgroup+1] .. '-' .. data.shot.damage .. tweaks.colors.gray .. ', ') or '',
                tweaks.colors.base .. (data.backtrack or data.shot.backtrack) .. tweaks.colors.gray .. 't'
            ))

            output.Screen(string.format(
                tweaks.colors.gray .. 'FF%s ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF\'s ' .. tweaks.colors.base .. 'FF%s ' .. tweaks.colors.gray ..'FFfor ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF hp %s',
                (hit and 'Hit' or 'Missed'),
                entity.get_player_name(data.target),
                hg[data.hitgroup + 1] or '?',
                (data.damage or data.shot.damage),
                (hit and '' or tweaks.colors.base .. 'FF~ ' .. tweaks.colors.gray .. 'FF' .. data.reason)
            ))

            if not entity.is_alive(data.target) then
                output.Console(string.format(
                    tweaks.colors.base .. 'â€¢ ' .. tweaks.colors.gray .. 'You killed ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' in ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. '!',
                    entity.get_player_name(data.target),
                    hg[data.hitgroup + 1] or '?'
                ))

                output.Screen(string.format(
                    tweaks.colors.gray .. 'FFYou killed ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF in ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF!',
                    entity.get_player_name(data.target),
                    hg[data.hitgroup + 1] or '?'
                ))
            end
        end,
        ['Damage'] = function(data)
            output.Console(string.format(
                tweaks.colors.red .. 'â€¢ ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' damaged ' .. tweaks.colors.base .. 'You' .. tweaks.colors.gray .. ' in ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' for ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. 'hp',
                entity.get_player_name(data.attacker),
                hg[data.hitgroup + 1],
                (data.dmg_health or 0)
            ))

            output.Screen(string.format(
                tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF damaged ' .. tweaks.colors.base .. 'FFYou' .. tweaks.colors.gray .. 'FF in ' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF (' .. tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FFhp)',
                entity.get_player_name(data.attacker),
                hg[data.hitgroup + 1],
                (data.dmg_health or 0)
            ))

            if data.health <= 0 then
                output.Console(string.format(
                    tweaks.colors.red .. 'â€¢ ' .. tweaks.colors.base .. '%s' .. tweaks.colors.gray .. ' killed ' .. tweaks.colors.base .. 'You' .. tweaks.colors.gray .. ' in ' .. tweaks.colors.base .. '%s',
                    entity.get_player_name(data.attacker),
                    hg[data.hitgroup + 1]
                ))
                output.Screen(string.format(
                    tweaks.colors.base .. 'FF%s' .. tweaks.colors.gray .. 'FF killed ' .. tweaks.colors.base .. 'FFYou' .. tweaks.colors.gray .. 'FF in ' .. tweaks.colors.base .. 'FF%s',
                    entity.get_player_name(data.attacker),
                    hg[data.hitgroup + 1]
                ))
            end
        end,
    }

    local unpack_events, unpack_output = {}, {}

    for i, v in pairs(output) do table.insert(unpack_output, i) end 
    for i, v in pairs(events) do table.insert(unpack_events, i) end

    local ui_events = ui.new_multiselect(t, l, format('Hit-logs', 'Events'), unpack(unpack_events))
    ui_output = ui.new_multiselect(t, l, format('Hit-logs', 'Output'), unpack(unpack_output))

    visuals:add(ui_events, function() return ui.get(checkbox) end)
    visuals:add(ui_output, function() return ui.get(checkbox) end)

    local connected = {}

    local aim_log = {}

    -- RAGEBOT:

    client.set_event_callback('aim_fire', function(data) aim_log[data.id] = data end)
    client.set_event_callback('aim_miss', function(data)
        if not aim_log[data.id] or not table.find(ui.get(ui_events), 'Ragebot') or not ui.get(checkbox) then return false end

        local full = data
        full.shot = aim_log[data.id]        
        full.backtrack = globals.tickcount() - full.shot.tick 

        events.Ragebot(false, full)
    end)
    client.set_event_callback('aim_hit', function(data)
        if not aim_log[data.id] or not table.find(ui.get(ui_events), 'Ragebot') or not ui.get(checkbox) then return false end

        local full = data
        full.shot = aim_log[data.id]        
        full.backtrack = globals.tickcount() - full.shot.tick  

        events.Ragebot(true, full)
    end)

    -- DAMAGE:

    client.set_event_callback('player_hurt', function(data)
        if not ui.get(checkbox) or not table.find(ui.get(ui_events), 'Damage') then return false end

        local vid, aid = data.userid, data.attacker
        if not vid or not aid then return false end

        local victim, attacker = client.userid_to_entindex(vid), client.userid_to_entindex(aid)

        data.attacker = attacker

        if victim == entity.get_local_player() and entity.is_enemy(attacker) then events.Damage(data) end
    end)

    -- --

    local scrW, scrH = client.screen_size()

    local w, h = 400, 150
    local x, y = scrW / 2 - w / 2, scrH - h - 200

    local function render_log(i, data)
        local anim = widget.animate
        local x, y, w, h = anim.x, anim.y, anim.w, anim.h

        if #logs >= i + 4 then data.disabled = true end

        local tW, tH = renderer.measure_text('c', data.text)

        data.start = data.start or client.timestamp()
        data.timeout = data.timeout or 5000
        data.pos_lerp = data.pos_lerp or .75
        data.alpha_lerp = data.alpha_lerp or 0
        data.widht = data.widht or 1

        if data.disabled and data.alpha_lerp < .05 then table.remove(logs, i) return false end
        
        data.alpha_lerp = Lerp(globals.frametime() * 10, data.alpha_lerp, data.disabled and 0 or 1)
        data.pos_lerp = Lerp(globals.frametime() * 4, data.pos_lerp, data.disabled and 2 or 1)
        
        local w, h = (15 + tW) * data.alpha_lerp, 24
        w = math.floor(w)
        
        data.widht = Lerp(globals.frametime() * 10, data.widht, data.disabled and 1 or w)
        data.y_pos = data.y_pos or y + h
        data.x_pos = data.x_pos or anim.x + (anim.w / 2 - w / 2)
        data.x_pos = Lerp(globals.frametime() * 10, data.x_pos, anim.x + (anim.w / 2 - w / 2))
        data.y_pos = Lerp(globals.frametime() * 10, data.y_pos, y + 10 + (h * 1.5 * (i - 1)))
        
        render.rectangle(data.x_pos, data.y_pos * data.pos_lerp, w, h, 0, 0, 0, 125 * data.alpha_lerp, 4)
        renderer.text(data.x_pos + w / 2, (data.y_pos + h / 2) *  data.pos_lerp, 255, 255, 255, 255, 'c', data.widht, data.text)

        if client.timestamp() - data.start >= data.timeout then data.disabled = true end
    end

    widget = widgets.new('hit_log', function()

        for i, data in ipairs(logs) do
            local status, err = pcall(function() return render_log(i, data) end)
            if not status then assert(err) end
        end
        
    end, x, y, w, h, nil, true, true)

    ui.set_callback(checkbox, function()
        widget.paint = ui.get(checkbox)
    end)

    widget.paint = ui.get(checkbox)

    process_end('Hit-logs')
end

--[[ -- -- -- -- -- -- END: -- -- -- -- -- --  ]]--

printf('')
process_end('Tweaks.lua')