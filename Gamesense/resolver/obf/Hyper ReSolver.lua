--[Obfuscated by Hercules v1.6.2 -> https://github.com/zeusssz/hercules-obfuscator | zeusssz.github.io/hercules-discord/ | by using the Hercules bot -> https://top.gg/bot/1293608330123804682]
local dbpfmd=66 if true then local _=67 end local qvsxqe=80 local function meiejx(tjjrku)local _=17 end local qprcln=21 local function vhrugd(kwfbuu)local _=51 end local oihwqh=63 while false do local _=4 break end while false do local _=39 break end if true then local _=46 end local zocryg=99 local function mdmmpz(bqizzf)local _=36 end local function otdehr(ragxrm)local _=29 end local function cytzpk(ibzrbt)local _=99 end local function tyowjo(txcxcy)local _=76 end local executed=false while not executed do if math.random(0,1)==0 then local _=417 else executed=true end end local ffi=require'ffi'ffi.cdef[[
    struct animation_layer_t {
        char pad_0000[20];
        uint32_t m_nOrder;
        uint32_t m_nSequence;
        float m_flPrevCycle;
        float m_flWeight;
        float m_flWeightDeltaRate;
        float m_flPlaybackRate;
        float m_flCycle;
        void *m_pOwner;
        char pad_0038[4];
    };
    struct animstate_t {
        char pad[3];
        char m_bForceWeaponUpdate;
        char pad1[91];
        void* m_pBaseEntity;
        void* m_pActiveWeapon;
        void* m_pLastActiveWeapon;
        float m_flLastClientSideAnimationUpdateTime;
        int m_iLastClientSideAnimationUpdateFramecount;
        float m_flAnimUpdateDelta;
        float m_flEyeYaw;
        float m_flPitch;
        float m_flGoalFeetYaw;
        float m_flCurrentFeetYaw;
        float m_flCurrentTorsoYaw;
        float m_flUnknownVelocityLean;
        float m_flLeanAmount;
        char pad2[4];
        float m_flFeetCycle;
        float m_flFeetYawRate;
        char pad3[4];
        float m_fDuckAmount;
        float m_fLandingDuckAdditiveSomething;
        char pad4[4];
        float m_vOriginX;
        float m_vOriginY;
        float m_vOriginZ;
        float m_vLastOriginX;
        float m_vLastOriginY;
        float m_vLastOriginZ;
        float m_vVelocityX;
        float m_vVelocityY;
        char pad5[4];
        float m_flUnknownFloat1;
        char pad6[8];
        float m_flUnknownFloat2;
        float m_flUnknownFloat3;
        float m_flUnknown;
        float m_flSpeed2D;
        float m_flUpVelocity;
        float m_flSpeedNormalized;
        float m_flFeetSpeedForwardsOrSideWays;
        float m_flFeetSpeedUnknownForwardOrSideways;
        float m_flTimeSinceStartedMoving;
        float m_flTimeSinceStoppedMoving;
        bool m_bOnGround;
        bool m_bInHitGroundAnimation;
        char pad7[2];
        float m_flJumpToFall;
        float m_flTimeSinceInAir;
        float m_flLastOriginZ;
        float m_flHeadHeightOrOffsetFromHittingGroundAnimation;
        float m_flStopToFullRunningFraction;
        char pad8[4];
        float m_flMagicFraction;
        char pad9[60];
        float m_flWorldForce;
        char pad10[462];
        float m_flMaxYaw;
    };
    typedef struct {
        float x;
        float y;
        float z;
    } Vector;
]]local RESOLVER_CONST={LAYER_AIMMATRIX=0,LAYER_MOVEMENT_MOVE=6,MAX_DESYNC_DELTA=58,MAX_HISTORY_SIZE=6,JITTER_THRESHOLD=8,SMALL_JITTER_THRESHOLD=3,DEFENSIVE_TIME=0.006,STATE_STAND=1,STATE_MOVE=2,STATE_AIR=4,MIN_DESYNC_THRESHOLD=5,MAX_MISS_STREAK=1,MAX_DATA_AGE=0.2,POSE_PARAM_FEET_YAW=11,LC_BREAK_THRESHOLD=0.8,PEEK_VEL_THRESHOLD=35,DEFENSIVE_YAW_CHANGE=6,SPIN_YAW_THRESHOLD=50,FAKEWALK_SPEED=50,MICRO_PREDICT_THRESHOLD=0.0015,GRAVITY=-800,SPREAD_THRESHOLD=0.02,SPREAD_COMPENSATION=0.5,}local ui_colors={accent={r=155,g=220,b=255,a=255},success={r=120,g=255,b=140,a=255},warning={r=255,g=120,b=120,a=255},}local math_util={normalize_yaw=function(yaw)while yaw>360 do yaw=yaw - 360 end while yaw<0 do yaw=yaw+360 end return yaw end,angle_diff=function(a,b)local diff=((a - b+180)% 360)- 180 return diff>180 and 360 - diff or math.abs(diff)end,sign=function(val)return val>0 and 1 or(val<0 and -1 or 0)end,angle_lerp=function(a,b,t)local diff=math_util.angle_diff(b,a)return math_util.normalize_yaw(a+diff*t)end,}local vec_util={length2d=function(vec)return math.sqrt((vec.x or 0)^2+(vec.y or 0)^2)end,get_velocity=function(player,p_data)if not(player and entity.is_alive(player))then return p_data.last_velocity or{x=0,y=0,z=0}end if p_data.velocity_cache and p_data.velocity_cache_tick==globals.tickcount()then return p_data.velocity_cache end local vx,vy,vz=entity.get_prop(player,"m_vecVelocity")p_data.velocity_cache={x=vx or 0,y=vy or 0,z=vz or 0}p_data.velocity_cache_tick=globals.tickcount()p_data.last_velocity=p_data.velocity_cache return p_data.velocity_cache end,get_origin=function(player,p_data)if not(player and entity.is_alive(player))then return p_data.last_origin or{x=0,y=0,z=0}end if p_data.origin_cache and p_data.origin_cache_tick==globals.tickcount()then return p_data.origin_cache end local x,y,z=entity.get_prop(player,"m_vecOrigin")p_data.origin_cache={x=x or 0,y=y or 0,z=z or 0}p_data.origin_cache_tick=globals.tickcount()p_data.last_origin=p_data.origin_cache return p_data.origin_cache end,}local function enhanced_desync_fix(idx,ent,base_angle)if not idx or not ent then return base_angle end local animstate=get_animstate(idx)local lby=entity.get_prop(idx,"m_flLowerBodyYawTarget")or 0 local eye_yaw=entity.get_prop(idx,"m_angEyeAngles[1]")or 0 local max_desync=get_max_desync(idx,ent)local side=math_util.angle_diff(eye_yaw,lby)>0 and 1 or -1 local confidence=ent.side_confidence or 0 local desync_angle=max_desync*(0.85+0.1*confidence)if animstate and animstate.m_flFeetSpeedForwardsOrSideWays<0.1 then desync_angle=max_desync*(1.0+0.05*confidence)end local correction=math_util.normalize_yaw(eye_yaw+desync_angle*side)if ui.get(menu.mode)=="Defensive"then correction=math_util.normalize_yaw(correction+math.random(-6,6))end return math_util.angle_lerp(base_angle,correction,0.8)end local function contains(tbl,val)if not tbl then return false end for _,v in ipairs(tbl)do if v==val then return true end end return false end local function get_animstate(player)local ptr=entity.get_prop(player,"m_pBaseEntity")if not ptr then return nil end return ffi.cast("struct animstate_t**",ptr)[0]end local function is_lby_flexing(player)local lby=entity.get_prop(player,"m_flLowerBodyYawTarget")or 0 local eye_yaw=entity.get_prop(player,"m_angEyeAngles[1]")or 0 return math.abs(math_util.angle_diff(eye_yaw,lby))>25 end resolver=resolver or{}resolver.player_data=resolver.player_data or{}resolver.global_patterns=resolver.global_patterns or{static={weight=0.3,angles={0}},jitter={weight=0.2,angles={30,-30}},spin={weight=0.15,speed=60,direction=1},desync={weight=0.25,angles={45,-45}},random={weight=0.1,angles={0,35,-35,58,-58}}}local function get_lby_break_count(player)local p_data=resolver.player_data[player]or{}local lby=entity.get_prop(player,"m_flLowerBodyYawTarget")or 0 local last_lby=p_data.last_lby or lby p_data.last_lby=lby if math.abs(math_util.angle_diff(lby,last_lby))>RESOLVER_CONST.LC_BREAK_THRESHOLD then p_data.lc_break_count=(p_data.lc_break_count or 0)+1 end resolver.player_data[player]=p_data return p_data.lc_break_count or 0 end local function kalman_filter(state,measurement,dt,speed,yaw_variance,is_defensive)if not state or not measurement or dt<=0 then return state end local process_noise=calculate_process_noise(speed,yaw_variance,is_defensive)local measurement_noise=calculate_measurement_noise(is_defensive)state.pos.x=state.pos.x+state.vel.x*dt state.pos.y=state.pos.y+state.vel.y*dt state.pos.z=state.pos.z+state.vel.z*dt local residual={x=measurement.x - state.pos.x,y=measurement.y - state.pos.y,z=measurement.z - state.pos.z}local gain=process_noise/(process_noise+measurement_noise)state.pos.x=state.pos.x+gain*residual.x state.pos.y=state.pos.y+gain*residual.y state.pos.z=state.pos.z+gain*residual.z state.vel.x=state.vel.x+gain*residual.x/dt state.vel.y=state.vel.y+gain*residual.y/dt state.vel.z=state.vel.z+gain*residual.z/dt if is_defensive then state.vel.x=state.vel.x*0.9 state.vel.y=state.vel.y*0.9 end return state end local function predict_position(player,time_ahead,history,speed,latency,yaw_variance,on_ground,p_data,is_defensive,aa_subtype,yaw_change)if not player or not entity.is_alive(player)or client.current_threat()~=player or not p_data then return vec_util.get_origin(player,p_data)end local origin=vec_util.get_origin(player,p_data)local velocity=vec_util.get_velocity(player,p_data)local state=p_data.kalman_state or{pos={x=origin.x,y=origin.y,z=origin.z},vel={x=velocity.x,y=velocity.y,z=velocity.z}}local tick_interval=globals.tickinterval()local latency_factor=math.min(latency/0.15,1.2)local aa_factor=aa_subtype=="lc break"and 1.2 or aa_subtype=="spin"and 1.1 or 1.0 time_ahead=math.min(time_ahead*aa_factor*0.25+latency_factor*0.02,RESOLVER_CONST.MAX_DESYNC_DELTA/360)if aa_subtype=="spin"and yaw_change>RESOLVER_CONST.SPIN_YAW_THRESHOLD then time_ahead=time_ahead*math.min(yaw_change/60,1.0)elseif aa_subtype=="fakewalk"then time_ahead=time_ahead*0.65 end if history and#history>=2 then local last_origin=history[#history].pos local dx=last_origin.x - origin.x local dy=last_origin.y - origin.y if math.sqrt(dx*dx+dy*dy)<RESOLVER_CONST.MICRO_PREDICT_THRESHOLD then time_ahead=time_ahead*0.5 end state=kalman_filter(state,last_origin,tick_interval,speed,yaw_variance,is_defensive)end local pred_time=speed>50 and time_ahead*0.15 or time_ahead*0.1 local inertia_factor=speed>100 and aa_subtype~="fakewalk"and 0.8 or 1.0 state.pos.x=state.pos.x+state.vel.x*pred_time*inertia_factor state.pos.y=state.pos.y+state.vel.y*pred_time*inertia_factor state.pos.z=state.pos.z+state.vel.z*pred_time if not on_ground then local gravity_effect=0.5*RESOLVER_CONST.GRAVITY*pred_time*pred_time state.pos.z=state.pos.z+gravity_effect state.vel.z=state.vel.z+RESOLVER_CONST.GRAVITY*pred_time end if is_defensive and aa_subtype=="defensive yaw"then state.pos.x=state.pos.x+math.random(-2,2)state.pos.y=state.pos.y+math.random(-2,2)end p_data.kalman_state=state return state.pos end local resolver={player_data=setmetatable({},{__mode="v"}),stats={total_hits=0,total_misses=0,hits_by_method={},misses_by_method={},misses_by_reason={spread=0,prediction=0,lagcomp=0,defensive_low_delta=0,defensive_jitter=0,defensive_spin=0,defensive_lc_break=0,defensive_other=0,resolver=0,connection=0,unregister_shot=0}},aa_memory=setmetatable({},{__mode="kv"}),anim_cache=setmetatable({},{__mode="k"}),miss_memory=setmetatable({},{__mode="kv"}),last_shot_id={},target_player=nil,global_patterns=resolver.global_patterns}local menu={enable=ui.new_checkbox("RAGE","Other","\aFF78DCFFHyper Resolver"),mode=ui.new_combobox("RAGE","Other","Resolver Mode",{"Standard","Aggressive","Adaptive","Defensive"}),options=ui.new_multiselect("RAGE","Other","Resolver Options",{"Resolve On Miss","Predict Movement","Handle Defensive","Detect Jitter","Detect Fakewalk","Global Learning"}),debug=ui.new_multiselect("RAGE","Other","Debug Options",{"Indicators","Hit Logs","Indicator Customization"}),respect_gs=ui.new_checkbox("RAGE","Other","Respect Gamesense Resolver"),reset_data=ui.new_button("RAGE","Other","\a78FF8CFFReset All Data",function()resolver.player_data=setmetatable({},{__mode="v"})resolver.stats={total_hits=0,total_misses=0,hits_by_method={},misses_by_method={},misses_by_reason={spread=0,prediction=0,lagcomp=0,defensive_low_delta=0,defensive_jitter=0,defensive_spin=0,defensive_lc_break=0,defensive_other=0,resolver=0,connection=0,unregister_shot=0}}resolver.aa_memory=setmetatable({},{__mode="kv"})resolver.anim_cache=setmetatable({},{__mode="k"})resolver.miss_memory=setmetatable({},{__mode="kv"})resolver.last_shot_id={}resolver.target_player=nil for _,player in ipairs(entity.get_players(true))do if player and entity.is_alive(player)and not ui.get(menu.respect_gs)then plist.set(player,"Force body yaw",false)plist.set(player,"Force body yaw value",0)end end collectgarbage("collect")end),panel_x=ui.new_slider("RAGE","Other","Indicator X Position",0,1920,960,true),panel_y=ui.new_slider("RAGE","Other","Indicator Y Position",0,1080,810,true),panel_width=ui.new_slider("RAGE","Other","Indicator Width",200,600,300,true),panel_height=ui.new_slider("RAGE","Other","Indicator Height",40,200,60,true),panel_opacity=ui.new_slider("RAGE","Other","Indicator Background Opacity",0,255,100,true)}local panel={x=960,y=810,width=300,height=60,opacity=100,is_dragging=false,is_resizing=false,drag_offset_x=0,drag_offset_y=0}ui.set_callback(menu.panel_x,function()panel.x=ui.get(menu.panel_x)end)ui.set_callback(menu.panel_y,function()panel.y=ui.get(menu.panel_y)end)ui.set_callback(menu.panel_width,function()panel.width=ui.get(menu.panel_width)end)ui.set_callback(menu.panel_height,function()panel.height=ui.get(menu.panel_height)end)ui.set_callback(menu.panel_opacity,function()panel.opacity=ui.get(menu.panel_opacity)end)local main_hyperresolver={" ","H ","Hy ","Hyp ","Hype ","Hyper ","Hyper R ","Hyper Re ","Hyper Res ","Hyper Reso ","Hyper Resol ","Hyper Resolv ","Hyper Resolve ","Hyper Resolver ","Hyper Resolver ","Hyper Resolver ","Hyper Resolv ","Hyper Resol ","Hyper Reso ","Hyper Res ","Hyper Re ","Hyper R ","Hyper ","Hype ","Hyp ","Hy ","H "," "}local clantag_index=1 local last_time=globals.realtime()local last_tag=""local function set_clantag(tag)if tag and tag~=last_tag then client.set_clan_tag(tag)last_tag=tag end end local function update_clantag()local local_player=entity.get_local_player()if not local_player or not ui.get(menu.enable)then set_clantag("")return end if globals.realtime()- last_time>=0.2 then set_clantag(main_hyperresolver[clantag_index])clantag_index=clantag_index+1 if clantag_index>#main_hyperresolver then clantag_index=1 end last_time=globals.realtime()end end ui.set(menu.debug,{"Indicators","Hit Logs"})ui.set(menu.options,{"Resolve On Miss","Predict Movement","Handle Defensive","Detect Jitter","Detect Fakewalk","Global Learning"})ui.set_visible(menu.mode,false)ui.set_visible(menu.options,false)ui.set_visible(menu.debug,false)ui.set_visible(menu.respect_gs,false)ui.set_visible(menu.reset_data,false)ui.set_visible(menu.panel_x,false)ui.set_visible(menu.panel_y,false)ui.set_visible(menu.panel_width,false)ui.set_visible(menu.panel_height,false)ui.set_visible(menu.panel_opacity,false)local function update_ui_visibility()local enabled=ui.get(menu.enable)ui.set_visible(menu.mode,enabled)ui.set_visible(menu.options,enabled)ui.set_visible(menu.debug,enabled)ui.set_visible(menu.respect_gs,enabled)ui.set_visible(menu.reset_data,enabled)local show_customization=enabled and contains(ui.get(menu.debug),"Indicator Customization")ui.set_visible(menu.panel_x,show_customization)ui.set_visible(menu.panel_y,show_customization)ui.set_visible(menu.panel_width,show_customization)ui.set_visible(menu.panel_height,show_customization)ui.set_visible(menu.panel_opacity,show_customization)if not enabled then set_clantag("")for _,player in ipairs(entity.get_players(true))do if player and entity.is_alive(player)and not ui.get(menu.respect_gs)then plist.set(player,"Force body yaw",false)plist.set(player,"Force body yaw value",0)end end end end ui.set_callback(menu.enable,update_ui_visibility)ui.set_callback(menu.debug,function()local enabled=ui.get(menu.enable)and contains(ui.get(menu.debug),"Indicator Customization")ui.set_visible(menu.panel_x,enabled)ui.set_visible(menu.panel_y,enabled)ui.set_visible(menu.panel_width,enabled)ui.set_visible(menu.panel_height,enabled)ui.set_visible(menu.panel_opacity,enabled)end)client.set_event_callback("paint",update_clantag)local vec_util={get_origin=function(player,p_data)return p_data.origin_cache or{x=0,y=0,z=0}end,get_velocity=function(player,p_data)return p_data.velocity_cache or{x=0,y=0,z=0}end,length2d=function(vec)return math.sqrt(vec.x*vec.x+vec.y*vec.y)end}local math_util={normalize_yaw=function(yaw)while yaw>180 do yaw=yaw - 360 end while yaw<-180 do yaw=yaw+360 end return yaw end,angle_diff=function(a,b)return math_util.normalize_yaw(a - b)end,angle_lerp=function(a,b,t)return math_util.normalize_yaw(a+math_util.angle_diff(b,a)*t)end}local function contains(tbl,value)for _,v in ipairs(tbl)do if v==value then return true end end return false end local function get_anim_layer_weight(player,p_data,layer)if not(player and entity.is_alive(player))then return 0 end p_data.anim_cache=p_data.anim_cache or{}if not p_data.anim_cache[layer]or globals.tickcount()% 64==0 then p_data.anim_cache[layer]=entity.get_prop(player,"m_AnimOverlay",layer,"m_flWeight")or 0 end return p_data.anim_cache[layer]end local function get_anim_layer_playback_rate(player,p_data,layer)if not(player and entity.is_alive(player))then return 0 end p_data.anim_cache=p_data.anim_cache or{}if not p_data.anim_cache["rate_".. layer]or globals.tickcount()% 64==0 then p_data.anim_cache["rate_".. layer]=entity.get_prop(player,"m_AnimOverlay",layer,"m_flPlaybackRate")or 0 end return p_data.anim_cache["rate_".. layer]end local function get_max_desync(player,p_data)if not(player and entity.is_alive(player))then return RESOLVER_CONST.MAX_DESYNC_DELTA end if p_data.desync_cache and p_data.desync_cache_tick>globals.tickcount()then return p_data.desync_cache end local animstate=entity.get_animstate(player)p_data.desync_cache=animstate and math.min(math.abs(animstate.m_flMaxYaw or RESOLVER_CONST.MAX_DESYNC_DELTA),RESOLVER_CONST.MAX_DESYNC_DELTA)or RESOLVER_CONST.MAX_DESYNC_DELTA p_data.desync_cache_tick=globals.tickcount()+64 return p_data.desync_cache end local function check_hitbox_visibility(player,local_player)if not(player and local_player and entity.is_alive(player)and entity.is_alive(local_player))then return false end local p_data=resolver.player_data[player]or{}if p_data.visibility_cache and p_data.visibility_cache_tick>globals.tickcount()then return p_data.visibility_cache end local origin=vec_util.get_origin(local_player,resolver.player_data[local_player]or{})local head_pos={x=origin.x,y=origin.y,z=origin.z+72}local target_pos=vec_util.get_origin(player,p_data)local hitboxes={{x=target_pos.x,y=target_pos.y,z=target_pos.z+60},{x=target_pos.x,y=target_pos.y,z=target_pos.z+40}}local visible_count=0 for _,hitbox in ipairs(hitboxes)do local fraction,ent=client.trace_bullet(local_player,head_pos.x,head_pos.y,head_pos.z,hitbox.x,hitbox.y,hitbox.z)if ent==player and fraction>0.95 then visible_count=visible_count+1 end end p_data.visibility_cache=visible_count>=1 p_data.visibility_cache_tick=globals.tickcount()+32 resolver.player_data[player]=p_data return p_data.visibility_cache end local function stabilize_player_data()local cur_time=globals.curtime()for player,data in pairs(resolver.player_data)do if not(player and entity.is_alive(player))or entity.is_dormant(player)or(data.last_update or 0)+RESOLVER_CONST.MAX_DATA_AGE<cur_time then resolver.player_data[player]=nil resolver.aa_memory[player]=nil resolver.miss_memory[player]=nil else if data.history and#data.history>RESOLVER_CONST.MAX_HISTORY_SIZE then table.remove(data.history,1)end if data.jitter_history and#data.jitter_history>4 then table.remove(data.jitter_history,1)end if data.pose_history and#data.pose_history>4 then table.remove(data.pose_history,1)end end end if globals.tickcount()% 128==0 then collectgarbage("collect")end end local function lock_resolver_state(player,expected_yaw,expected_enabled)if not(player and entity.is_alive(player))then return end if ui.get(menu.respect_gs)and plist.get(player,"Correction active")then return end local current_enabled=plist.get(player,"Force body yaw")local current_yaw=plist.get(player,"Force body yaw value")or 0 if current_enabled==expected_enabled and(not expected_enabled or math.abs(current_yaw - expected_yaw)<0.05)then return end plist.set(player,"Force body yaw",expected_enabled)if expected_enabled then plist.set(player,"Force body yaw value",expected_yaw)end end local function get_pose_desync(player,p_data)if not(player and entity.is_alive(player))then return 0 end if p_data.pose_cache and p_data.pose_cache_tick>globals.tickcount()then return p_data.pose_cache end local pose_feet=entity.get_prop(player,"m_flPoseParameter",RESOLVER_CONST.POSE_PARAM_FEET_YAW)or 0 p_data.pose_cache=(pose_feet - 0.5)*120 p_data.pose_cache_tick=globals.tickcount()+16 resolver.player_data[player]=p_data return p_data.pose_cache end local function detect_fake_lag(p_data,sim_time)if p_data.last_sim_time==sim_time and(p_data.last_speed or 0)>5 then p_data.fake_lag_count=(p_data.fake_lag_count or 0)+1 else p_data.fake_lag_count=0 end return(p_data.fake_lag_count or 0)>2 end local function detect_jitter(p_data,small_jitter)if p_data.jitter_history and#p_data.jitter_history>=4 then local variance=0 for i=2,#p_data.jitter_history do variance=variance+math.abs(p_data.jitter_history[i]- p_data.jitter_history[i-1])end variance=variance/(#p_data.jitter_history - 1)return variance>(small_jitter and RESOLVER_CONST.SMALL_JITTER_THRESHOLD or RESOLVER_CONST.JITTER_THRESHOLD)end return false end local function analyze_aa_type(p_data,speed,move_weight,playback_rate,player,is_defensive)if not(p_data and player and entity.is_alive(player))then return"default","default"end local aa_type,aa_subtype="default","default"local jitter_detected=detect_jitter(p_data,is_defensive)if is_defensive and(p_data.lc_break_count or 0)>RESOLVER_CONST.LC_BREAK_THRESHOLD then aa_type,aa_subtype="lagcomp","lc break"elseif jitter_detected then aa_type,aa_subtype="jitter",is_defensive and"small jitter"or"jitter"elseif p_data.jitter_history and#p_data.jitter_history>=4 and math.abs(p_data.jitter_history[#p_data.jitter_history])>RESOLVER_CONST.SPIN_YAW_THRESHOLD then aa_type,aa_subtype="spin","spin"elseif speed>RESOLVER_CONST.FAKEWALK_SPEED and move_weight>0.9 then aa_type,aa_subtype="spin","spin"elseif speed>5 and speed<RESOLVER_CONST.FAKEWALK_SPEED and move_weight>0.85 then aa_type,aa_subtype="fakewalk","fakewalk"elseif speed<5 and move_weight<0.1 then aa_type,aa_subtype="static","static"elseif p_data.defensive_triggered then aa_type,aa_subtype="defensive","defensive yaw"elseif is_defensive and math.abs(p_data.last_pose_desync or 0)<RESOLVER_CONST.MIN_DESYNC_THRESHOLD then aa_type,aa_subtype="defensive","low delta"end return aa_type,aa_subtype end local function get_weapon_spread_factor(local_player)local weapon=entity.get_player_weapon(local_player)if not weapon then return 1.0 end local weapon_type=entity.get_classname(weapon)local spread_factors={["CWeaponAK47"]=1.2,["CWeaponAWP"]=0.8,["CWeaponMP9"]=1.0,["CWeaponGlock"]=0.9}return spread_factors[weapon_type]or 1.0 end local function apply_autostop(local_player,p_data,speed,aa_type,is_defensive,lc_break,weapon_spread)if not(local_player and entity.is_alive(local_player)and p_data)then return end local l_p_data=resolver.player_data[local_player]or{}local l_velocity=vec_util.get_velocity(local_player,l_p_data)local l_speed=vec_util.length2d(l_velocity)if l_speed<(lc_break and 10 or 8)then return end local weapon_factor=get_weapon_spread_factor(local_player)local confidence_threshold=0.85 local speed_threshold=lc_break and 15 or 30 local should_stop=(speed>speed_threshold and p_data.side_confidence>confidence_threshold)or(aa_type=="fakewalk"and l_speed>10)or(p_data.defensive_triggered and p_data.side_confidence>0.9)or(is_defensive and speed>10 and p_data.side_confidence>0.85)or(lc_break and p_data.side_confidence>0.8)or(weapon_spread*weapon_factor>RESOLVER_CONST.SPREAD_THRESHOLD)if should_stop then local decel_factor=lc_break and 0.55 or 0.6 decel_factor=decel_factor*(1 - weapon_spread*RESOLVER_CONST.SPREAD_FACTOR*weapon_factor)entity.set_prop(local_player,"m_vecVelocity[0]",l_velocity.x*decel_factor)entity.set_prop(local_player,"m_vecVelocity[1]",l_velocity.y*decel_factor)end end local function apply_spread_compensation(resolver_value,weapon_spread)if weapon_spread<=0 then return resolver_value end local local_player=entity.get_local_player()if not local_player then return resolver_value end local weapon_factor=get_weapon_spread_factor(local_player)local spread_threshold=RESOLVER_CONST.SPREAD_THRESHOLD*weapon_factor if weapon_spread>spread_threshold then local seed=globals.tickcount()+entity.get_prop(local_player,"m_nTickBase")local spread_adjust=math.sin(seed*0.1)*weapon_spread*RESOLVER_CONST.SPREAD_COMPENSATION*weapon_factor return math_util.normalize_yaw(resolver_value+spread_adjust)end return resolver_value end local adaptive_resolver={debug_mode=false,learning_rate=0.12,update_interval=0.06,players={},angle_sets={standard={0,30,-30,60,-60},extended={0,45,-45,90,-90}}}function adaptive_resolver:init_player(idx)self.players[idx]={angle_history={},optimal_angles={},last_used_angle=0,last_switch_index=0,last_desync_side="left",hits=0,misses=0,yaw_change_rate=0}for pattern,data in pairs(resolver.global_patterns)do self.players[idx].optimal_angles[pattern]=data.angles end end function adaptive_resolver:record_hit(idx,angle)if not idx then return end local player=self.players[idx]if not player then self:init_player(idx)end player=self.players[idx]table.insert(player.angle_history,{angle=angle,result="hit",time=globals.realtime()})player.hits=(player.hits or 0)+1 local patterns=self:analyze_patterns(idx)for pattern,prob in pairs(patterns)do if resolver.global_patterns[pattern]==nil then resolver.global_patterns[pattern]={weight=0}end resolver.global_patterns[pattern].weight=math.min(resolver.global_patterns[pattern].weight+prob*0.04,1)end end function adaptive_resolver:record_miss(idx,angle,reason)if not idx then return end local player=self.players[idx]if not player then self:init_player(idx)end player=self.players[idx]table.insert(player.angle_history,{angle=angle,result="miss",reason=reason,time=globals.realtime()})player.misses=(player.misses or 0)+1 local patterns=self:analyze_patterns(idx)for pattern,prob in pairs(patterns)do local data=resolver.global_patterns[pattern]if data then data.weight=math.max(data.weight - prob*0.02,0.05)end end end function adaptive_resolver:analyze_patterns(idx)if not self.players[idx]then return{static=0,jitter=0,spin=0,random=0,switch=0,desync=0}end local player=self.players[idx]local history=player.angle_history or{}local patterns={static=0,jitter=0,spin=0,random=0,switch=0,desync=0}if#history<6 then for pattern,data in pairs(resolver.global_patterns)do patterns[pattern]=data.weight end return patterns end local animstate=entity.get_animstate(idx)local lby=entity.get_prop(idx,"m_flLowerBodyYawTarget")or 0 local eye_yaw=entity.get_prop(idx,"m_angEyeAngles[1]")or 0 local static_angle=nil local is_static=true for i=#history,math.max(1,#history - 5),-1 do if history[i]and history[i].result=="miss"and history[i].angle then if not static_angle then static_angle=history[i].angle elseif math.abs(math_util.normalize_yaw(history[i].angle - static_angle))>6 then is_static=false break end end end if is_static and static_angle then patterns.static=0.9 player.optimal_angles=player.optimal_angles or{}player.optimal_angles.static=math_util.normalize_yaw(static_angle+180)return patterns end local angles={}for i=#history,math.max(1,#history - 12),-1 do if history[i]and history[i].result=="miss"and history[i].angle then local found=false for _,angle in ipairs(angles)do if math.abs(math_util.normalize_yaw(history[i].angle - angle))<6 then found=true break end end if not found then table.insert(angles,history[i].angle)end end end if#angles==2 then patterns.jitter=0.9 player.optimal_angles=player.optimal_angles or{}player.optimal_angles.jitter={math_util.normalize_yaw(angles[1]+180),math_util.normalize_yaw(angles[2]+180)}return patterns end local left_side,right_side={},{}for i=1,#history do if history[i]and history[i].angle then local angle=history[i].angle if angle>0 then table.insert(right_side,angle)else table.insert(left_side,angle)end end end if#left_side>2 and#right_side>2 then local left_avg=0 local right_avg=0 for _,angle in ipairs(left_side)do left_avg=left_avg+angle end for _,angle in ipairs(right_side)do right_avg=right_avg+angle end left_avg=left_avg/#left_side right_avg=right_avg/#right_side local side_diff=math.abs(left_avg - right_avg)if side_diff>20 then patterns.desync=0.8 player.optimal_angles=player.optimal_angles or{}player.optimal_angles.desync={left=math_util.normalize_yaw(left_avg+180),right=math_util.normalize_yaw(right_avg+180),center=math_util.normalize_yaw((left_avg+right_avg)/2+180)}return patterns end end local is_spin=true local last_angle=nil local direction=nil local angle_diffs={}for i=#history,math.max(1,#history - 10),-1 do if history[i]and history[i].result=="miss"and history[i].angle then if not last_angle then last_angle=history[i].angle else local diff=math_util.normalize_yaw(history[i].angle - last_angle)table.insert(angle_diffs,diff)if not direction then direction=diff>0 and 1 or -1 elseif(diff>0 and direction<0)or(diff<0 and direction>0)then is_spin=false break end last_angle=history[i].angle end end end if is_spin and#angle_diffs>0 then local total_diff=0 for _,diff in ipairs(angle_diffs)do total_diff=total_diff+math.abs(diff)end local spin_speed=total_diff/#angle_diffs patterns.spin=0.75 player.optimal_angles=player.optimal_angles or{}player.optimal_angles.spin={direction=direction,speed=spin_speed,offset=90*direction}return patterns end patterns.random=0.7 player.optimal_angles=player.optimal_angles or{}player.optimal_angles.random={0,35,-35,58,-58,29,-29}return patterns end function adaptive_resolver:get_optimal_angle(idx)if not self.players[idx]then self:init_player(idx)end local player=self.players[idx]local patterns=self:analyze_patterns(idx)local best_pattern,best_probability="random",0 for pattern,probability in pairs(patterns)do if probability>best_probability then best_probability=probability best_pattern=pattern end end if not player.optimal_angles or not player.optimal_angles[best_pattern]then self:analyze_patterns(idx)end local optimal_angle=0 if best_pattern=="static"then optimal_angle=player.optimal_angles.static elseif best_pattern=="jitter"then local last_angle=player.last_used_angle or 0 optimal_angle=math.abs(math_util.normalize_yaw(last_angle - player.optimal_angles.jitter[1]))<6 and player.optimal_angles.jitter[2]or player.optimal_angles.jitter[1]elseif best_pattern=="switch"then local last_index=player.last_switch_index or 0 last_index=(last_index %#player.optimal_angles.switch)+1 optimal_angle=player.optimal_angles.switch[last_index]player.last_switch_index=last_index elseif best_pattern=="spin"then local base_angle=entity.get_prop(idx,"m_angEyeAngles[1]")or 0 local time_offset=0.1 optimal_angle=math_util.normalize_yaw(base_angle+player.optimal_angles.spin.offset+player.optimal_angles.spin.speed*player.optimal_angles.spin.direction*time_offset)elseif best_pattern=="desync"then local animstate=entity.get_animstate(idx)local side=(animstate and animstate.m_flFeetSpeedForwardsOrSideWays<0.1)and -1 or 1 optimal_angle=side>0 and player.optimal_angles.desync.right or player.optimal_angles.desync.left player.last_desync_side=side>0 and"right"or"left"else local random_index=math.random(#player.optimal_angles.random)optimal_angle=player.optimal_angles.random[random_index]end local ent=resolver.player_data[idx]if ent then optimal_angle=enhanced_desync_fix(idx,ent,optimal_angle)end player.last_used_angle=optimal_angle return optimal_angle end function adaptive_resolver:process_player_list()local enemies=entity.get_players(true)for i=1,#enemies do local idx=enemies[i]if entity.is_alive(idx)and not self.players[idx]then self:init_player(idx)end end end local function enhanced_desync_fix(idx,ent,base_angle)if not idx or not ent then return base_angle end local animstate=entity.get_animstate(idx)local lby=entity.get_prop(idx,"m_flLowerBodyYawTarget")or 0 local eye_yaw=entity.get_prop(idx,"m_angEyeAngles[1]")or 0 local max_desync=get_max_desync(idx,ent)local side=math_util.angle_diff(eye_yaw,lby)>0 and 1 or -1 local confidence=ent.side_confidence or 0 local desync_angle=max_desync*(0.85+0.1*confidence)if animstate and animstate.m_flFeetSpeedForwardsOrSideWays<0.1 then desync_angle=max_desync*(1.0+0.05*confidence)end local correction=math_util.normalize_yaw(eye_yaw+desync_angle*side)if ui.get(menu.mode)=="Defensive"then correction=math_util.normalize_yaw(correction+math.random(-6,6))end return math_util.angle_lerp(base_angle,correction,0.8)end local roll_resolver={players=setmetatable({},{__mode="v"})}function roll_resolver:init_player(idx)if not idx or not entity.is_alive(idx)then return nil end if not self.players[idx]then self.players[idx]={resolved_angles={yaw=0,pitch=0,roll=0},angle_history={yaw={},pitch={},roll={}},state="UNRESOLVED",hits=0,misses=0,consecutive_hits=0,consecutive_misses=0,last_yaw=0,last_update=globals.curtime()}end return self.players[idx]end function roll_resolver:reset_all()self.players=setmetatable({},{__mode="v"})end function roll_resolver:analyze_misses(idx,p_data)local data=self:init_player(idx)if not data then return end local is_defensive=p_data and p_data.last_method=="defensive"local miss_threshold=is_defensive and 1 or 2 if data.consecutive_misses>=miss_threshold then data.state="BRUTEFORCE"elseif data.consecutive_misses>=1 then data.state="SCAN"else data.state="UNRESOLVED"end if globals.curtime()- data.last_update>RESOLVER_CONST.MAX_DATA_AGE then self.players[idx]=nil else data.last_update=globals.curtime()end end function roll_resolver:predict_next_angle(idx)if not self.players[idx]then return 0 end local data=self.players[idx]local yaw_history=data.angle_history.yaw or{}if#yaw_history<4 then return data.resolved_angles.yaw or 0 end local patterns=adaptive_resolver:analyze_patterns(idx)local ent=resolver.player_data[idx]local sim_time=ent and ent.last_sim_time or globals.realtime()local dt=0.1 if patterns.static>0.5 then return yaw_history[#yaw_history].value elseif patterns.jitter>0.5 then local last_angle=yaw_history[#yaw_history].value local prev_angle=yaw_history[#yaw_history-1].value return math.abs(math_util.normalize_yaw(last_angle - prev_angle))<6 and prev_angle or last_angle elseif patterns.spin>0.5 then local last_angle=yaw_history[#yaw_history].value local prev_angle=yaw_history[#yaw_history-1].value local delta=math_util.angle_diff(last_angle,prev_angle)return math_util.normalize_yaw(last_angle+delta*(dt/0.015))elseif patterns.desync>0.5 and ui.get(menu.options,"Handle Defensive")then return adaptive_resolver:get_optimal_angle(idx)else local best_angle=adaptive_resolver:get_optimal_angle(idx)if ent then return enhanced_desync_fix(idx,ent,best_angle)end return best_angle end end function roll_resolver:resolve_player(idx)if not ui.get(menu.enable)then self:reset_all()return end local data=self.players[idx]if not data then self:init_player(idx)end local ent=resolver.player_data[idx]if not ent then return end local sim_time=ent.last_sim_time or 0 local old_sim_time=ent.last_sim_time_old or sim_time local dt=sim_time - old_sim_time local current_yaw=ent.last_eye_yaw or 0 local velocity=vec_util.get_velocity(idx,ent)local movement_factor=math.min(1,vec_util.length2d(velocity)/250)local adaptive_angle=ui.get(menu.options,"Handle Defensive")and adaptive_resolver:get_optimal_angle(idx)or 0 local predicted_yaw=self:predict_next_angle(idx)local hit_ratio=(data.hits or 0)/math.max(1,(data.hits or 0)+(data.misses or 0))local blend_ratio=math.min(1.0,(hit_ratio*0.5)+(movement_factor*0.3))local computed_yaw=math_util.normalize_yaw(blend_ratio*adaptive_angle+(1 - blend_ratio)*predicted_yaw)computed_yaw=enhanced_desync_fix(idx,ent,computed_yaw)data.resolved_angles.yaw=computed_yaw data.resolved_angles.pitch=89 data.resolved_angles.roll=0 if hit_ratio>0.7 and movement_factor<0.2 then data.state="RESOLVED"elseif data.consecutive_misses>=2 then data.state="SCAN"else data.state="ADAPTIVE"end data.last_yaw=computed_yaw end local function resolver_update()if not ui.get(menu.enable)then return end stabilize_player_data()local local_player=entity.get_local_player()if not(local_player and entity.is_alive(local_player))then return end local enemies=entity.get_players(true)local mode=ui.get(menu.mode)local options=ui.get(menu.options)local respect_gs=ui.get(menu.respect_gs)local tick_interval=globals.tickinterval()local latency=client.latency()local closest_dist=math.huge local closest_player=nil local max_enemies=2 local processed_enemies=0 local cur_time=globals.curtime()local tick_count=globals.tickcount()for _,player in ipairs(enemies)do if not(player and entity.is_alive(player)and not entity.is_dormant(player))then goto continue end if respect_gs and plist.get(player,"Correction active")then goto continue end local p_data=resolver.player_data[player]if not p_data then p_data={side=0,desync=0,state=0,history={},last_update=cur_time,miss_count=0,last_method="standard",shots_hit=0,shots_fired=0,defensive_triggered=false,last_eye_yaw=0,last_feet_yaw=0,last_pose_desync=0,jitter_history={},pose_history={},last_sim_time=0,last_sim_time_old=0,lc_break_count=0,side_confidence=0,last_speed=0,fake_lag_count=0,kalman_state=nil,velocity_cache=nil,velocity_cache_tick=0,origin_cache=nil,origin_cache_tick=0,pose_cache=0,pose_cache_tick=0,anim_cache={},desync_cache=RESOLVER_CONST.MAX_DESYNC_DELTA,desync_cache_tick=0,visibility_cache=false,visibility_cache_tick=0,last_velocity={x=0,y=0,z=0},last_origin={x=0,y=0,z=0},last_lby=0}resolver.player_data[player]=p_data end local l_pos=vec_util.get_origin(local_player,resolver.player_data[local_player]or{})local p_pos=vec_util.get_origin(player,p_data)local dist=math.sqrt((l_pos.x - p_pos.x)^2+(l_pos.y - p_pos.y)^2)if dist<closest_dist then closest_dist=dist closest_player=player end if dist>1500 then goto continue end if p_data.visibility_cache and p_data.visibility_cache_tick>tick_count then if not p_data.visibility_cache then goto continue end else p_data.visibility_cache=check_hitbox_visibility(player,local_player)p_data.visibility_cache_tick=tick_count+16 if not p_data.visibility_cache then goto continue end end local velocity=vec_util.get_velocity(player,p_data)local speed=vec_util.length2d(velocity)local eye_yaw=entity.get_prop(player,"m_angEyeAngles[1]")or 0 local feet_yaw=p_data.feet_yaw_cache or entity.get_prop(player,"m_flLowerBodyYawTarget")or eye_yaw p_data.feet_yaw_cache=feet_yaw local sim_time=entity.get_prop(player,"m_flSimulationTime")or 0 local on_ground=bit.band(entity.get_prop(player,"m_fFlags")or 0,1)==1 p_data.state=speed<5 and RESOLVER_CONST.STATE_STAND or(speed>50 and RESOLVER_CONST.STATE_MOVE or RESOLVER_CONST.STATE_AIR)local base_desync=math_util.angle_diff(eye_yaw,feet_yaw)local pose_desync=get_pose_desync(player,p_data)local yaw_change=math_util.angle_diff(eye_yaw,p_data.last_eye_yaw)p_data.last_eye_yaw=eye_yaw p_data.last_feet_yaw=feet_yaw p_data.last_pose_desync=pose_desync p_data.last_sim_time_old=p_data.last_sim_time p_data.last_sim_time=sim_time if tick_count % 4==0 or player==client.current_threat()then table.insert(p_data.jitter_history,yaw_change)table.insert(p_data.pose_history,pose_desync)if#p_data.jitter_history>4 then table.remove(p_data.jitter_history,1)end if#p_data.pose_history>4 then table.remove(p_data.pose_history,1)end end local is_breaking_lc=sim_time==p_data.last_sim_time_old and speed>5 p_data.lc_break_count=is_breaking_lc and(p_data.lc_break_count or 0)+1 or math.max(0,(p_data.lc_break_count or 0)- 0.5)p_data.last_speed=speed local is_defensive=mode=="Defensive"or p_data.defensive_triggered local aa_type,aa_subtype=nil,nil if tick_count % 4==0 or player==client.current_threat()then local move_weight=get_anim_layer_weight(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE)local playback_rate=get_anim_layer_playback_rate(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE)aa_type,aa_subtype=analyze_aa_type(p_data,speed,move_weight,playback_rate,player,is_defensive)p_data.aa_type_cache=aa_type p_data.aa_subtype_cache=aa_subtype else aa_type=p_data.aa_type_cache or"default"aa_subtype=p_data.aa_subtype_cache or"default"end if contains(options,"Predict Movement")and player==client.current_threat()and tick_count % 2==0 then local yaw_variance=math.abs(yaw_change)local pred_pos=predict_position(player,tick_interval*0.5,p_data.history,speed,latency,yaw_variance,on_ground,p_data,is_defensive,aa_subtype,yaw_change)table.insert(p_data.history,{pos=pred_pos,time=cur_time,velocity=velocity})if#p_data.history>RESOLVER_CONST.MAX_HISTORY_SIZE then table.remove(p_data.history,1)end end p_data.defensive_triggered=contains(options,"Handle Defensive")and(cur_time -(p_data.last_update or 0)<RESOLVER_CONST.DEFENSIVE_TIME or yaw_change>RESOLVER_CONST.DEFENSIVE_YAW_CHANGE or p_data.lc_break_count>0)local max_desync=get_max_desync(player,p_data)if mode=="Standard"then p_data.desync=math.min(base_desync,max_desync*0.9)p_data.side=pose_desync>0 and 1 or -1 p_data.last_method="standard"elseif mode=="Aggressive"then p_data.desync=max_desync*0.95 p_data.side=(p_data.miss_count % 2==0)and 1 or -1 p_data.last_method="aggressive"elseif mode=="Adaptive"then local desync_factor=(p_data.defensive_triggered and 0.85)or(yaw_change>RESOLVER_CONST.JITTER_THRESHOLD and 0.7)or(speed<60 and 0.8)or 0.75 p_data.desync=max_desync*desync_factor p_data.side=detect_jitter(p_data,false)and(yaw_change>0 and 1 or -1)or(pose_desync>0 and 1 or -1)if contains(options,"Resolve On Miss")and p_data.miss_count>0 then p_data.side=-(p_data.side or 0)p_data.desync=math.min(p_data.desync+1,max_desync)end p_data.last_method="adaptive"elseif mode=="Defensive"then local desync_factor=(p_data.defensive_triggered or aa_subtype=="lc break")and 0.95 or(aa_subtype=="low delta"and 0.9)or(aa_subtype=="spin"and 0.85)or 0.8 p_data.desync=max_desync*desync_factor if aa_subtype=="low delta"or aa_subtype=="small jitter"then p_data.side=(p_data.miss_count % 2==0)and 1 or -1 elseif aa_subtype=="spin"or aa_subtype=="lc break"then p_data.side=yaw_change>0 and 1 or -1 else p_data.side=pose_desync>0 and 1 or -1 end if contains(options,"Resolve On Miss")and p_data.miss_count>0 then p_data.side=-(p_data.side or 0)p_data.desync=math.min(p_data.desync+2,max_desync)end p_data.last_method="defensive"end p_data.side_confidence=math.min(math.max((p_data.side_confidence or 0)+(p_data.shots_hit>p_data.shots_fired*0.5 and 0.1 or -0.05),0),1)if p_data.visibility_cache then p_data.side_confidence=p_data.side_confidence+(is_defensive and 0.05 or 0.025)end local weapon=entity.get_player_weapon(local_player)local weapon_spread=weapon and(entity.get_prop(weapon,"m_flInaccuracy")or 0)or 0 if player==client.current_threat()then apply_autostop(local_player,p_data,speed,aa_type,is_defensive,p_data.lc_break_count>RESOLVER_CONST.LC_BREAK_THRESHOLD,weapon_spread)end local resolver_value=apply_spread_compensation(p_data.desync*p_data.side,weapon_spread)if p_data.side_confidence>(is_defensive and 0.85 or 0.9)then lock_resolver_state(player,resolver_value,true)else lock_resolver_state(player,0,false)end p_data.last_update=cur_time if contains(options,"Handle Defensive")and player==client.current_threat()then roll_resolver:resolve_player(player)adaptive_resolver:process_player_list()end processed_enemies=processed_enemies+1 if processed_enemies>=max_enemies then break end::continue::end resolver.target_player=closest_player end local hitgroup_names={'generic','head','chest','stomach','left arm','right arm','left leg','right leg','neck','gear'}local shot_counter=0 local function analyze_miss_reason(e)local reason=e.reason or"unknown"local target=e.target if not(target and entity.get_player_name(target))then return"Resolver","invalid target"end local p_data=resolver.player_data[target]or{desync=0,lc_break_count=0,defensive_triggered=false,side_confidence=0}local sim_time=entity.get_prop(target,"m_flSimulationTime")or 0 local tick_count=math.max(0,math.floor((sim_time - globals.curtime())/globals.tickinterval()))local is_perfect_shot=p_data.desync<5 and reason~="spread"and e.hitgroup==1 if is_perfect_shot and tick_count<12 then resolver.stats.misses_by_reason.connection=(resolver.stats.misses_by_reason.connection or 0)+1 return"Connection","connection issue"end if reason=="spread"then resolver.stats.misses_by_reason.spread=(resolver.stats.misses_by_reason.spread or 0)+1 return"Spread","weapon inaccuracy"elseif(p_data.lc_break_count or 0)>RESOLVER_CONST.LC_BREAK_THRESHOLD or tick_count>12 then resolver.stats.misses_by_reason.unregister_shot=(resolver.stats.misses_by_reason.unregister_shot or 0)+1 return"Unregister Shot","lag compensation"elseif p_data.defensive_triggered then local speed=vec_util.length2d(vec_util.get_velocity(target,p_data))local aa_type,aa_subtype=analyze_aa_type(p_data,speed,get_anim_layer_weight(target,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),get_anim_layer_playback_rate(target,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),target,true)aa_subtype=aa_subtype or"unknown"resolver.stats.misses_by_reason["defensive_".. aa_subtype]=(resolver.stats.misses_by_reason["defensive_".. aa_subtype]or 0)+1 return"Resolver","defensive ".. aa_subtype elseif math.abs((p_data.desync or 0)- get_max_desync(target,p_data))>5 then resolver.stats.misses_by_reason.prediction=(resolver.stats.misses_by_reason.prediction or 0)+1 return"Prediction","position prediction"else resolver.stats.misses_by_reason.resolver=(resolver.stats.misses_by_reason.resolver or 0)+1 if p_data.side_confidence<0.9 then p_data.desync=get_max_desync(target,p_data)*0.85 p_data.side=-(p_data.side or 0)p_data.side_confidence=math.min(p_data.side_confidence+0.2,1)resolver.player_data[target]=p_data end return"Resolver","resolver failure"end end client.set_event_callback("aim_hit",function(e)if not ui.get(menu.enable)then return end shot_counter=shot_counter+1 local shot_id=string.format("%d_%d_%d",globals.tickcount(),e.target,shot_counter)resolver.last_shot_id[shot_id]=true local player=e.target if not player then return end local p_data=resolver.player_data[player]or{side=0,desync=0,last_method="standard",shots_hit=0,shots_fired=0,side_confidence=0,miss_count=0,jitter_history={},lc_break_count=0}resolver.player_data[player]=p_data local group=hitgroup_names[e.hitgroup+1]or'generic'p_data.shots_hit=(p_data.shots_hit or 0)+1 p_data.shots_fired=(p_data.shots_fired or 0)+1 p_data.miss_count=math.max(0,p_data.miss_count - 2)p_data.side_confidence=math.min(p_data.side_confidence+0.6,1)p_data.lc_break_count=get_lby_break_count(player)resolver.stats.total_hits=(resolver.stats.total_hits or 0)+1 resolver.stats.hits_by_method[p_data.last_method]=(resolver.stats.hits_by_method[p_data.last_method]or 0)+1 adaptive_resolver:record_hit(player,p_data.desync*p_data.side)local roll_data=roll_resolver.players[player]or{hits=0,misses=0,consecutive_hits=0,consecutive_misses=0,last_update=globals.curtime()}roll_resolver.players[player]=roll_data roll_data.hits=(roll_data.hits or 0)+1 roll_data.consecutive_hits=(roll_data.consecutive_hits or 0)+1 roll_data.consecutive_misses=0 roll_data.last_update=globals.curtime()if contains(ui.get(menu.debug)or{},"Hit Logs")then local sim_time=entity.get_prop(player,"m_flSimulationTime")or 0 local tick_count=math.max(0,math.floor((sim_time - globals.curtime())/globals.tickinterval()))local aa_type,aa_subtype=analyze_aa_type(p_data,vec_util.length2d(vec_util.get_velocity(player,p_data)),get_anim_layer_weight(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),get_anim_layer_playback_rate(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),player,p_data.last_method=="defensive")aa_type=aa_type or"unknown"aa_subtype=aa_subtype or"unknown"local log_message=string.format("[Hyper Resolver] Hit %s in %s for %d dmg (Side: %s | Desync: %.1f° | Method: %s | AA: %s (%s) | LC=%d | TC=%d | ShotID: %s)",entity.get_player_name(player)or"Unknown",group,e.damage or 0,p_data.side==1 and"Right"or(p_data.side==-1 and"Left"or"Center"),p_data.desync or 0,p_data.last_method or"unknown",aa_type,aa_subtype,p_data.lc_break_count or 0,tick_count,shot_id)if client.color_log then client.color_log(ui_colors.success.r,ui_colors.success.g,ui_colors.success.b,log_message)else client.log(log_message)end end if globals.tickcount()% 5==0 then for id,_ in pairs(resolver.last_shot_id)do local tick=tonumber(id:match("^(%d+)_"))if tick and globals.tickcount()- tick>50 then resolver.last_shot_id[id]=nil end end end end)local function render_gradient_text(x,y,text,start_color,end_color,align)local text_width=renderer.measure_text(align,text)local char_width=text_width/#text for i=1,#text do local t=(i - 1)/(#text - 1)local r=math.floor(start_color.r+(end_color.r - start_color.r)*t)local g=math.floor(start_color.g+(end_color.g - start_color.g)*t)local b=math.floor(start_color.b+(end_color.b - start_color.b)*t)local char=text:sub(i,i)renderer.text(x+(i - 1)*char_width,y,r,g,b,255,align,0,char)end end local panel={x=960,y=810,width=300,height=60,is_dragging=false,is_resizing=false,drag_offset_x=0,drag_offset_y=0}client.set_event_callback("paint",function()if not ui.get(menu.enable)or not contains(ui.get(menu.debug)or{},"Indicators")then return end local local_player=entity.get_local_player()if not(local_player and entity.is_alive(local_player))then return end local is_menu_open=ui.is_menu_open()local mouse_x,mouse_y=ui.mouse_position()local is_mouse_down=client.key_state(0x01)local panel_right=panel.x+panel.width/2 local panel_left=panel.x - panel.width/2 local panel_top=panel.y - panel.height/2 local panel_bottom=panel.y+panel.height/2 local resize_handle={x_min=panel_right - 10,x_max=panel_right,y_min=panel_bottom - 10,y_max=panel_bottom}if is_menu_open and is_mouse_down and not panel.is_dragging and not panel.is_resizing then if mouse_x>=panel_left and mouse_x<=panel_right and mouse_y>=panel_top and mouse_y<=panel_bottom then panel.is_dragging=true panel.drag_offset_x=mouse_x - panel.x panel.drag_offset_y=mouse_y - panel.y elseif mouse_x>=resize_handle.x_min and mouse_x<=resize_handle.x_max and mouse_y>=resize_handle.y_min and mouse_y<=resize_handle.y_max then panel.is_resizing=true end elseif not is_mouse_down then panel.is_dragging=false panel.is_resizing=false end if panel.is_dragging then panel.x=mouse_x - panel.drag_offset_x panel.y=mouse_y - panel.drag_offset_y end if panel.is_resizing then panel.width=math.max(200,(mouse_x - panel.x)*2)panel.height=math.max(40,(mouse_y - panel.y)*2)end if is_menu_open then renderer.rectangle(panel_left,panel_top,panel.width,panel.height,0,0,0,100)renderer.rectangle(resize_handle.x_min,resize_handle.y_min,10,10,255,255,255,200)end render_gradient_text(panel.x,panel.y - 10,"Hyper Resolver",{r=0,g=0,b=0},{r=255,g=255,b=255},"c")local target=resolver.target_player if target and entity.is_alive(target)then local p_data=resolver.player_data[target]or{}local aa_type,aa_subtype=analyze_aa_type(p_data,vec_util.length2d(vec_util.get_velocity(target,p_data)),get_anim_layer_weight(target,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),get_anim_layer_playback_rate(target,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),target,p_data.last_method=="defensive")aa_type=aa_type or"unknown"aa_subtype=aa_subtype or"unknown"renderer.text(panel.x,panel.y+10,255,255,255,255,"c",0,string.format("Target: %s | Method: %s | Side: %s | Desync: %.1f° | AA: %s (%s)",entity.get_player_name(target)or"Unknown",p_data.last_method or"none",p_data.side==1 and"Right"or(p_data.side==-1 and"Left"or"Center"),p_data.desync or 0,aa_type,aa_subtype))end end)client.set_event_callback("aim_miss",function(e)if not ui.get(menu.enable)then return end shot_counter=shot_counter+1 local shot_id=string.format("%d_%d_%d",globals.tickcount(),e.target,shot_counter)resolver.last_shot_id[shot_id]=true local player=e.target if not player then return end local p_data=resolver.player_data[player]or{side=0,desync=0,last_method="standard",shots_hit=0,shots_fired=0,side_confidence=0,miss_count=0,jitter_history={},lc_break_count=0}resolver.player_data[player]=p_data local group=hitgroup_names[e.hitgroup+1]or'generic'local miss_reason,miss_subreason=analyze_miss_reason(e)p_data.shots_fired=(p_data.shots_fired or 0)+1 p_data.miss_count=(p_data.miss_count or 0)+1 p_data.last_miss_time=globals.curtime()p_data.lc_break_count=get_lby_break_count(player)resolver.stats.total_misses=(resolver.stats.total_misses or 0)+1 resolver.stats.misses_by_method[p_data.last_method]=(resolver.stats.misses_by_method[p_data.last_method]or 0)+1 resolver.miss_memory[player]={aa_type=analyze_aa_type(p_data,vec_util.length2d(vec_util.get_velocity(player,p_data)),get_anim_layer_weight(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),get_anim_layer_playback_rate(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),player,p_data.last_method=="defensive")}if contains(ui.get(menu.debug)or{},"Hit Logs")then local sim_time=entity.get_prop(player,"m_flSimulationTime")or 0 local tick_count=math.max(0,math.floor((sim_time - globals.curtime())/globals.tickinterval()))local aa_type,aa_subtype=analyze_aa_type(p_data,vec_util.length2d(vec_util.get_velocity(player,p_data)),get_anim_layer_weight(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),get_anim_layer_playback_rate(player,p_data,RESOLVER_CONST.LAYER_MOVEMENT_MOVE),player,p_data.last_method=="defensive")aa_type=aa_type or"unknown"aa_subtype=aa_subtype or"unknown"local log_message=string.format("[Hyper Resolver] Missed %s in %s due to %s (%s) (Side: %s | Desync: %.1f° | Method: %s | AA: %s (%s) | LC=%d | TC=%d | ShotID: %s)",entity.get_player_name(player)or"Unknown",group,miss_reason,miss_subreason,p_data.side==1 and"Right"or(p_data.side==-1 and"Left"or"Center"),p_data.desync or 0,p_data.last_method or"unknown",aa_type,aa_subtype,p_data.lc_break_count or 0,tick_count,shot_id)if client.color_log then client.color_log(ui_colors.warning.r,ui_colors.warning.g,ui_colors.warning.b,log_message)else client.log(log_message)end end adaptive_resolver:record_miss(player,p_data.desync*p_data.side,miss_reason)local roll_data=roll_resolver.players[player]or{hits=0,misses=0,consecutive_hits=0,consecutive_misses=0,last_update=globals.curtime()}roll_resolver.players[player]=roll_data roll_data.misses=(roll_data.misses or 0)+1 roll_data.consecutive_misses=(roll_data.consecutive_misses or 0)+1 roll_data.consecutive_hits=0 roll_data.last_update=globals.curtime()roll_resolver:analyze_misses(player,p_data)if globals.tickcount()% 5==0 then for id,_ in pairs(resolver.last_shot_id)do local tick=tonumber(id:match("^(%d+)_"))if tick and globals.tickcount()- tick>50 then resolver.last_shot_id[id]=nil end end end end)local sentences_kill={"Слышь, $name, Хочешь также тапать? Зайди в тг и купи Hyper Resolver t.me/Hyper_Resolver","Слышь, $name, Hyper Resolver разъебал твой AA в хлам, сиди в спектрах, пёс!t.me/Hyper_Resolver💀","✪ 𝗧𝗩𝗢𝗬 𝗟𝗔𝗞𝗜 𝗗𝗘𝗦𝗜𝗡𝗞 𝗡𝗘 𝗦𝗣𝗔𝗦, $name, 𝗛𝗬𝗣𝗘𝗥 𝗥𝗘𝗦𝗢𝗟𝗩𝗘𝗥 𝗧𝗔𝗣𝗡𝗨𝗟 𝗧𝗘𝗕𝗬𝗔 𝗩 𝗘𝗕𝗟𝗢! ✪ t.me/Hyper_Resolver🔪","Ебать, $name, Hyper Resolver размотал твой фейк, пиздец тебе, лох!t.me/Hyper_Resolver 😈","➤ 𝕊ℍ𝔸 ℍ𝕐ℙ𝔼ℝ ℝ𝔼𝕊𝕆𝕃𝕍𝔼ℝ 𝔻𝔸ℝ𝔸𝕊𝕊𝔼𝔻 𝕋𝕍𝕆𝕐 𝕄𝕌𝕊𝕆ℝℕ𝕐 𝔸𝔸, $name, 𝕋𝕐 𝕍 ℕ𝕌𝕃𝕀ℕ𝔼!t.me/Hyper_Resolver⚡","Чё, $name, думал твой AA тянет? Hyper Resolver вынес тебя нахуй! 🐶Hyper_Resolver","⌦ Х У Й ⌦ $name, Т В О Й  Д Е С И Н К — Х У Й Н Я, HYPER RESOLVER Л О В И  В А Н Ш О Т! Hyper_Resolver💥","$name, твой AA — кал, Hyper Resolver разъебал тебя в мясо, дебил! 🩸t.me/Hyper_Resolver","▊ $name, 𝗛𝗬𝗣𝗘𝗥 𝗥𝗘𝗦𝗢𝗟𝗩𝗘𝗥 𝗭𝗔𝗙𝗟𝗘𝗞𝗦𝗜𝗟 𝗧𝗩𝗢𝗬 𝗟𝗔𝗞𝗜 𝗔𝗔 𝗩 𝗣𝗢𝗠𝗢𝗬𝗞𝗨! ▊ 🗑","Hyper Resolver заклипал $name, твой десинк не вывез, пизда тебе! ⚔","Соси, $name, Hyper Resolver зарезолвил твой фейк, ты в спектрах, лузер! 🔥"}local sentences_death={"Бля, $name, твой лаки AA заебал, ща Hyper Resolver зарезолвит, пёс! 😡","★ 𝗦𝗨𝗞𝗔 ★ $name, 𝗧𝗩𝗢𝗬 𝗗𝗘𝗦𝗜𝗡𝗞 — 𝗠𝗨𝗦𝗢𝗥, 𝗛𝗬𝗣𝗘𝗥 𝗥𝗘𝗦𝗢𝗟𝗩𝗘𝗥 𝗦𝗛𝗖𝗔 𝗥𝗔𝗭𝗬𝗘𝗕𝗢𝗧! 💪","$name, пиздец, лаки тап, но Hyper Resolver уже флексит на твой AA! 🔥","➤ 𝔼𝔹𝔸𝕋𝕋, $name, 𝕋𝕍𝕆𝕐 𝔽𝔼𝕐𝕂 — ℍ𝕌𝕐ℕ𝕐𝔸, ℍ𝕐ℙ𝔼ℝ ℝ𝔼𝕊𝕆𝕃𝕍𝔼ℝ 𝕍𝔼ℝℕ𝔼𝕋𝕊𝕐𝔸! 🐀","Чё, $name, думаешь, твой AA тянет? Hyper Resolver ща зафлексит, дебил! ⚔","⌧ Б Л Я ⌧ $name, Т В О Й  Л А К И  Д Е С И Н К  Н Е  В Е Ч Е Н, HYPER RESOLVER Р А З М О Т А Е Т! 🩸t.me/Hyper_Resolver","Похер, $name, твой AA — кал, Hyper Resolver уже грузит резолв на тебя! 😤","█ $name, ТВОЙ ТАП — ЧИСТО ФАРТ, HYPER RESOLVER ЩА РАЗЪЕБЁТ ТВОЙ ФЕЙК! █ 💥","Слышь, $name, твой десинк — дерьмо, Hyper Resolver флексит и тащит! 🗑","Ну ты и пидор, $name, лаки AA, но Hyper Resolver зарезолвит твой скам! 😈"}local ui={get=ui.get}local client={set_event_callback=client.set_event_callback,userid_to_entindex=client.userid_to_entindex,exec=client.exec,log=client.log}local entity={get_local_player=entity.get_local_player,get_player_name=entity.get_player_name}local function on_player_death(event)local menu_enabled=ui.get(menu.enable)if not menu_enabled then return end local local_player=entity.get_local_player()local attacker=client.userid_to_entindex(event.attacker)local victim=client.userid_to_entindex(event.userid)if local_player==nil or attacker==nil or victim==nil then return end if attacker==local_player and victim~=local_player then local killsay="say ".. sentences_kill[math.random(#sentences_kill)]killsay=string.gsub(killsay,"$name",entity.get_player_name(victim))client.log(killsay)client.exec(killsay)elseif victim==local_player and attacker~=local_player then local deathsay="say ".. sentences_death[math.random(#sentences_death)]deathsay=string.gsub(deathsay,"$name",entity.get_player_name(attacker))client.log(deathsay)client.exec(deathsay)end end math.randomseed(133742069)math.random();math.random();math.random()client.set_event_callback("player_death",on_player_death)local function nrrcyj(javpyu)local _=36 end while false do local _=72 break end if false then local _=37 end while false do local _=16 break end local function ysggjt(usnlsx)local _=27 end local osggro=33 if true then local _=6 end local xhqccj=68 if false then local _=99 end if true then local _=84 end local function bagghs(qzplmz)local _=26 end local function jeyhfn(bnkfht)local _=77 end local function vfpqir(vdoyvo)local _=8 end